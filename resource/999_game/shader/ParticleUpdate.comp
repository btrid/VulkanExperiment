#version 450

//#pragma optionNV (unroll none)
#pragma optionNV (inline all)
//#pragma optionNV(fastmath on)
//#pragma optionNV(strict on)

#extension GL_GOOGLE_cpp_style_line_directive : require
#include </Common.glsl>

#define SETPOINT_PARTICLE 0
#include </Particle.glsl>

#define SETPOINT_MAP 1
#include </Map.glsl>

layout (local_size_x = 1024, local_size_y = 1) in;

layout(push_constant) uniform UpdateConstantBlock
{
	float m_deltatime;
	uint m_src_offset;
	uint m_dst_offset;
} constant;

void main()
{
	uint index = gl_GlobalInvocationID.x;
	if(index >= u_particle_info.m_max_num){
		return;
	}

	ParticleData p = b_particle[constant.m_src_offset + index];
	b_particle[constant.m_src_offset + index].m_life = -1.;
	p.m_life -= constant.m_deltatime;
	if(p.m_life <= 0.){
		return;
	}

	MapInfo map_info = u_map_info;
	float progress = p.m_vel.w * constant.m_deltatime;
	vec3 cell_size = map_info.cell_size.xyz;
	float particle_size = p.m_pos.w;

	ivec3 map_index = p.m_map_index.xyz;
	for(;;)
	{
		vec3 dir = p.m_vel.xyz;
		ivec3 prev_index = map_index;

		vec3 cell_origin = map_index*cell_size;
		vec3 cell_p = p.m_pos.xyz - cell_origin;
		float x = dir.x < 0. ? cell_p.x : (map_info.m_cell_size.x- cell_p.x);
		float z = dir.z < 0. ? cell_p.z : (map_info.m_cell_size.z- cell_p.z);

		vec3 dist = vec3(99.);
		dist.x = abs(dir.x) < FLT_EPSIRON ? 99.9 : abs(x / dir.x);
		dist.z = abs(dir.z) < FLT_EPSIRON ? 99.9 : abs(z / dir.z);
		float rate = min(dist.x, dist.z);
		rate = abs(dir.x) < FLT_EPSIRON ? dist.z : rate;
		rate = abs(dir.z) < FLT_EPSIRON ? dist.x : rate;

		vec3 prog = dir * rate;
		float progLength = length(dir * rate);
		if(progress < progLength)
		{
			// 移動完了
			p.m_pos.xyz += dir * progress;
			p.m_pos.xyz = clamp(p.m_pos.xyz, (map_index * cell_size)+particle_size+FLT_EPSIRON, (map_index+ivec3(1, 0, 1)) * cell_size-particle_size-FLT_EPSIRON);
			break;
		}
		progress -= progLength;

		ivec3 next = ivec3(0);
		if(dist.x < dist.z){
			next.x = dir.x < 0. ? -1 : 1;
		}
		else
		{
			next.z = dir.z < 0. ? -1 : 1;
		}

		vec3 next_pos = p.m_pos.xyz + prog + vec3(next);
		uint map = imageLoad(t_map, (map_index + next).xz ).x;
		if(map == 1) 
		{
			vec3 wall = vec3(next);
			p.m_vel.xyz = reflect(p.m_vel.xyz, wall);
		}else{
			map_index += next;
		}
		p.m_pos.xyz = next_pos;
		p.m_pos.xyz = clamp(p.m_pos.xyz, (map_index * cell_size)+particle_size+FLT_EPSIRON, (map_index+ivec3(1, 0, 1)) * cell_size-particle_size-FLT_EPSIRON);
	}

	uint dst_index = atomicAdd(b_draw_cmd.vertexCount, 1);
	p.m_map_index.xyz = map_index;
	b_particle[constant.m_dst_offset + dst_index] = p;
}