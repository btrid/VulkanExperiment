#version 450

//#pragma optionNV (unroll none)
#pragma optionNV (inline all)
//#pragma optionNV(fastmath on)
//#pragma optionNV(strict on)

#extension GL_GOOGLE_cpp_style_line_directive : require

#include <ConvertDimension.glsl>
#include </Common.glsl>

#define SETPOINT_BOID 0
#include </Boid.glsl>
#define SETPOINT_BULLET 1
#include </Bullet.glsl>
#define SETPOINT_MAP 2
#include </Map.glsl>


layout (local_size_x = 32, local_size_y = 32) in;


layout(push_constant) uniform UpdateConstantBlock
{
	float m_deltatime;
	uint m_double_buffer_dst_index;
} constant;

void main()
{
	uvec2 map_index = gl_GlobalInvocationID.xy;
	if(any(greaterThanEqual(map_index, u_map_info.m_cell_num.xy)))
	{
		return;
	}

	uint enemy_offset = (u_boid_info.m_soldier_max/2) * (constant.m_double_buffer_dst_index);
	uint bullet_offset = (u_bullet_info.m_max_num/2) * (constant.m_double_buffer_dst_index);
	uint map_offset = u_map_info.m_cell_num.x*u_map_info.m_cell_num.y * (constant.m_double_buffer_dst_index);

	uint map_id = convert2DTo1D(map_index, u_map_info.m_cell_num.xy);
	for(uint i = b_soldier_head[map_id + map_offset]; i != 0xFFFFFFFF;)
	{
		SoldierData soldier = b_soldier[enemy_offset + i];
		i = soldier.m_ll_next;
		vec4 enemy_pos = soldier.m_pos;
		vec4 inertia = vec4(0.);
		for(uint bullet_index = b_bullet_head[map_id]; bullet_index != 0xFFFFFFFF;)
		{
			BulletData bullet = b_bullet[bullet_offset + bullet_index];
			bullet_index = bullet.m_ll_next;
			if(distance(bullet.m_pos.xyz, soldier.m_pos.xyz) < 5.5)
			{
				inertia.xyz += normalize((bullet.m_vel).xyz) * 10.1;
			}
		}
		b_soldier[enemy_offset + i].m_inertia = inertia;

	}


}
