#version 450

//#pragma optionNV (unroll none)
#pragma optionNV (inline all)
//#pragma optionNV(fastmath on)
//#pragma optionNV(strict on)

#extension GL_GOOGLE_cpp_style_line_directive : require

#include </Common.glsl>

#define SETPOINT_BOID 0
#include </Boid.glsl>
#define SETPOINT_BULLET 1
#include </Bullet.glsl>
#define SETPOINT_MAP 2
#include </Map.glsl>

#include <ConvertDimension.glsl>

layout (local_size_x = 1024, local_size_y = 1) in;


layout(push_constant) uniform UpdateConstantBlock
{
	float m_deltatime;
	uint m_double_buffer_dst_index;
} constant;

void main()
{
	uvec2 map_index = gl_GlobalInvocationID.xy;
//	if(map_index >= u_boid_info.m_soldier_max)
//	{
//		return;
//	}

	uint map_id = convert2DTo1D(map_index, u_map_info.m_cell_num.xy);
	for(uint i = b_soldier_head[map_id]; i != INVALID_INDEX;)
	{
		SoldierData soldier = b_soldier[i];
		i = soldier.m_ll_next;
		vec4 enemy_pos = soldier.m_pos;
		vec4 inertia = soldier.m_inertia;

		for(uint bullet_index = b_bullet_head[map_id]; bullet_index != INVALID_INDEX;)
		{
			BulletData bullet = b_bullet[bullet_index];
			bullet_index = bullet.m_ll_next;
			if(distance(bullet.m_pos.xyz, enemy_pos.xyz) < enemy_pos.w+bullet.m_pos.w)
			{
				inertia.xyz += normalize((enemy_pos - bullet.m_pos).xyz) * 0.3;
			}

		}
		b_soldier[i].m_inertia = inertia;

	}


}
