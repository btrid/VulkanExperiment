#version 450

//#pragma optionNV (unroll none)
#pragma optionNV (inline all)
//#pragma optionNV(fastmath on)
//#pragma optionNV(strict on)

#extension GL_GOOGLE_cpp_style_line_directive : require
#include </Particle.glsl>
#define FLT_EPSIRON (0.001)

layout (local_size_x = 1024, local_size_y = 1) in;

layout(std140, set=0, binding=0) uniform ParticleInfoUniform {
	ParticleInfo u_particle_info;
};

layout(std430, set=0, binding=1) restrict buffer ParticleDataBuffer {
	ParticleData b_particle[];
};
layout(std430, set=0, binding=2) restrict buffer CounterBuffer {
	DrawIndirectCommand b_draw_cmd;
};

struct MapInfo
{
	vec3 cell_size;
};
layout(set=1, binding=0, r8ui) uniform readonly uimage2D t_map;
layout(std140, set=1, binding=1) uniform MapInfoUniform {
	MapInfo u_map_info;
};


layout(push_constant) uniform UpdateConstantBlock
{
	float m_deltatime;
	uint m_src_offset;
	uint m_dst_offset;
} constant;

#if 1
ivec3 marchDistance(inout vec3 pos, inout float progress, in vec3 dir, in vec3 cell_size)
{
//	progress = 0.;
//	return ivec3(0);
	vec3 p = mod(pos, cell_size);
	float x = dir.x < 0. ? p.x : (cell_size.x- p.x);
	float z = dir.z < 0. ? p.z : (cell_size.z- p.z);
	vec3 dist = vec3(99.);
#if 1
	// 0除算回避版。不要？
	dist.x = abs(dir.x) < FLT_EPSIRON ? 99999.9 : abs(x / dir.x);
	dist.z = abs(dir.z) < FLT_EPSIRON ? 99999.9 : abs(z / dir.z);
#else
	dist = abs(vec3(x, y, z) / dir);
#endif

	float rate = min(dist.x, dist.z);
	vec3 prog = dir * rate;
	float progLength = length(dir * rate);
	float minProgLength = min(progLength, progress);
	ivec3 next = ivec3(0);
	progress -= minProgLength;
	if(progress >= FLT_EPSIRON)
	{
		if(dist.x < dist.z){
			next.x = dir.x < 0. ? -1 : 1;
		}
		else
		{
			next.z = dir.z < 0. ? -1 : 1;
		}
	}

	prog = prog * (minProgLength / progLength);
//	progress = 0.;
	pos += prog + vec3(next)*FLT_EPSIRON; // ちょっとずれちゃうけど・・・
	return next;
}
#else

ivec3 marchDistance(inout vec3 pos, inout float progress, in vec3 dir, in vec3 cell_size)
{
	vec3 p = mod(pos, cell_size);
	float x = dir.x < 0. ? p.x : (cell_size.x- p.x);
	float z = dir.z < 0. ? p.z : (cell_size.z- p.z);
//	vec3 dist = vec3(x, 0, z) / (abs(dir));
	vec3 dist = vec3(0.);
	dist.x = abs(dir.x) < FLT_EPSIRON ? 99999.9 : abs(x / dir.x);
	dist.z = abs(dir.z) < FLT_EPSIRON ? 99999.9 : abs(z / dir.z);

	float near_rate = min(dist.x, dist.z);
	float near_dist = dist.x < dist.z ? x : z;
	
	if(near_dist <= progress)
	{
		pos += dir * progress;
		progress = 0.;
		return ivec3(0);
	}
	progress -= near_dist;
	ivec3 next = ivec3(0);
	if(dist.x < dist.z)
	{
		next.x = dir.x < 0. ? -1 : 1;
	}
	else
	{
		next.z = dir.z < 0. ? -1 : 1;
	}
	pos += dir*near_dist + vec3(next)*FLT_EPSIRON; // ちょっとずれちゃうけど・・・
	return next;
}
#endif
void main()
{
	uint index = gl_GlobalInvocationID.x;
	if(index >= u_particle_info.m_max_num){
		return;
	}

	ParticleData p = b_particle[constant.m_src_offset + index];
	b_particle[constant.m_src_offset + index].m_life = -1.;
	p.m_life -= constant.m_deltatime;
	if(p.m_life <= 0.){
		return;
	}
#if 0
	p.m_pos.xyz += p.m_vel.xyz * p.m_vel.w * constant.m_deltatime;
#else
	float progress = p.m_vel.w * constant.m_deltatime;
	ivec3 map_index = ivec3(p.m_pos.xyz / u_map_info.cell_size);
	MapInfo map_info = u_map_info;
	for(;;)
	{
		ivec3 prev_index = map_index;
		map_index = marchDistance(p.m_pos.xyz, progress, p.m_vel.xyz, map_info.cell_size) + map_index;
		if(progress < FLT_EPSIRON) {
			break;
		}
		uint map = imageLoad(t_map, map_index.xz).x;
		if(map == 1) {
			vec3 wall = vec3(map_index-prev_index);
			p.m_vel.xyz = reflect(p.m_vel.xyz, wall);
			p.m_pos.xyz -= wall*FLT_EPSIRON;
			map_index = ivec3(p.m_pos.xyz / u_map_info.cell_size);
//			if(any(notEqual(map_index.xz, prev_index.xz))){
//				while(true);
//			}
		}
	}
#endif
	uint dst_index = atomicAdd(b_draw_cmd.vertexCount, 1);
	b_particle[constant.m_dst_offset + dst_index] = p;
}