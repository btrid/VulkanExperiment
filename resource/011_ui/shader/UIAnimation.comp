#version 450

#extension GL_GOOGLE_cpp_style_line_directive : require

#define USE_UI 0
#define USE_UI_ANIME 1
#include <UI.glsl>

#define USE_SYSTEM 2
#include <applib/System.glsl>

layout (local_size_x = 1024, local_size_y = 1) in;

void main() 
{
	uint index = gl_GlobalInvocationID.x;
	if(index >= u_anime_info.m_anime_num){ return; }

	float frame = b_anime_play_info[0].m_frame;
	int offset = int(getKeyOffset(u_anime_data_info[0].m_list[index]));
	int num = int(getKeyNum(u_anime_data_info[0].m_list[index]));
	int type = int(getKeyType(u_anime_data_info[0].m_list[index]));
	uint key_flag = getFlag(u_anime_data_info[0].m_list[index]);
	uint target = getTargetIndex(u_anime_data_info[0].m_list[index]);
	int key_index = offset;
	for(; key_index < num+offset; key_index++)
	{
		if(frame < b_anime_key[key_index].m_frame){
			break;
		}
	}

	UIAnimeKey a = b_anime_key[clamp(key_index-1, offset, offset+num-1)];
	UIAnimeKey b = b_anime_key[clamp(key_index, offset, offset+num-1)];
	float rate = 0.;
//	if(!inOn(a.m_flag, AnimeKey_interp_switch))
	{
		uint diff = b.m_frame - a.m_frame;
		rate = diff == 0 ? 1. : ((frame-a.m_frame) / diff);
	}
	vec4 av = vec4(0.);
	vec4 bv = vec4(0.);
	switch(type)
	{
		case AnimeDataInfo_type_pos_xy:
		case AnimeDataInfo_type_size_xy:
			av = vec4(i32Toi16(a.m_value), 0., 0.);
			bv = vec4(i32Toi16(b.m_value), 0., 0.);
			break;
		case AnimeDataInfo_type_color_rgba:
		{
			uint ua = uint(a.m_value);
			uint ub = uint(b.m_value);
			av = vec4(getBit(ua, 0, 8), getBit(ua, 8, 8), getBit(ua, 16, 8), getBit(ua, 24, 8));
			bv = vec4(getBit(ub, 0, 8), getBit(ub, 8, 8), getBit(ub, 16, 8), getBit(ub, 24, 8));
			break;
		}
		case AnimeDataInfo_type_disable_order:
			b_scene.m_is_disable_order = a.m_value;
			break;
	}
	vec4 value = mix(av, bv, rate);
	if(type == AnimeDataInfo_type_pos_xy){
		b_work[target].m_position += value.xy;
	}else if(type == AnimeDataInfo_type_size_xy)
		b_work[target].m_size += value.xy;
	else if(type == AnimeDataInfo_type_color_rgba)
		b_work[target].m_color += value;
}

