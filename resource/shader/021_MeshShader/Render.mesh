
#version 450

#extension GL_GOOGLE_include_directive : require
#extension GL_NV_mesh_shader : require

#define WARP_SIZE 32
layout(local_size_x=WARP_SIZE) in;

#define NVMESHLET_VERTEX_COUNT      64
#define NVMESHLET_PRIMITIVE_COUNT   126
layout(max_vertices=NVMESHLET_VERTEX_COUNT, max_primitives=NVMESHLET_PRIMITIVE_COUNT) out;
layout(triangles) out;
/*
layout (location = 0)out gl_MeshPerVertexNV 
{
	vec4  gl_Position;
	perviewNV vec4 gl_PositionPerViewNV[];  // NVX_multiview_per_view_attributes
	float gl_PointSize;
	float gl_ClipDistance[];
	perviewNV float gl_ClipDistancePerViewNV[][];
} gl_MeshVerticesNV[];

layout (location = 1)perprimitiveNV out gl_MeshPerPrimitiveNV 
{
	int gl_PrimitiveID;
	int gl_Layer;
	perviewNV int gl_LayerPerViewNV[];
	int gl_ViewportIndex;
	int gl_ViewportMask[];          // NV_viewport_array2
	perviewNV int gl_ViewportMaskPerViewNV[][];
} gl_MeshPrimitivesNV[];
*/
// Custom vertex output block
layout (location = 0) out PerVertexData
{
  vec4 color;
} v_out[];  // [max_vertices]
 
const vec3 vertices[3] = {vec3(-1,-1,0), vec3(0,1,0), vec3(1,-1,0)};
const vec3 colors[3] = {vec3(1.0,0.0,0.0), vec3(0.0,1.0,0.0), vec3(0.0,0.0,1.0)};
 
void main()
{
  // Vertices position
  gl_MeshVerticesNV[0].gl_Position = vec4(vertices[0], 1.0); 
  gl_MeshVerticesNV[1].gl_Position = vec4(vertices[1], 1.0); 
  gl_MeshVerticesNV[2].gl_Position = vec4(vertices[2], 1.0); 
 
  // Vertices color
  v_out[0].color = vec4(colors[0], 1.0);
  v_out[1].color = vec4(colors[1], 1.0);
  v_out[2].color = vec4(colors[2], 1.0);
 
  // Triangle indices
  gl_PrimitiveIndicesNV[0] = 0;
  gl_PrimitiveIndicesNV[1] = 1;
  gl_PrimitiveIndicesNV[2] = 2;
 
  // Number of triangles  
  gl_PrimitiveCountNV = 1;
}