#version 450
#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_ballot: enable
#extension GL_KHR_shader_subgroup_arithmetic: enable

#define USE_GI2D 0
#define USE_GI2D_Path 1
#include "GI2D/GI2D.glsl"
#include "GI2D/GI2DPath.glsl"

layout (local_size_x = 1024) in;

// https://github.com/zerowidth/jps-explained
// https://zerowidth.com/2013/05/05/jump-point-search-explained.html


layout(push_constant, std430) uniform InputVertex
{
	i16vec2 target[10];
	i16vec2 target_num;
	i16vec2 reso;
} constant;


uvec4 neighor_check_list[] =
{
	uvec4(2,6,1,7), // diagonal_path 
	uvec4(3,5,4,4), // diagonal_wall
	uvec4(1,7,4,4), // straight_path
	uvec4(2,6,4,4), // straight_wall
};

struct Node
{
	i16vec2 pos;
//	uint dir_type:4;
//	uint cost:28;
	uint data;
};

shared Node s_open[1024*5];
shared uvec2 s_open_counter;

void explore(in ivec2 pos, uint dir_type, uint cost)
{
	pos += g_neighbor[dir_type];
	int index = pos.x + pos.y * constant.reso.x;

	{
		// 斜め方向は優先
		uint data = dir_type |((dir_type%2==0?1:0)<<4) | ((cost+(dir_type%2==0?1:1))<<5);
		uint prev = atomicMin(b_path_data[index].data, data);
		if(data >= prev)
		{
			return;
		}
	}

	// 新しい探索のチェック
	{
		uint neighbor = uint(b_neighbor[index]);
		int dir_types = u_neighbor_table[int(neighbor+dir_type*256)];
		uint active_index = atomicAdd(s_open_counter[0], bitCount(dir_types));

		while(dir_types!=0)
		{
			int dir = findMSB(dir_types);
			dir_types &= ~(1<<dir);
			s_open[active_index++ % s_open.length()] = Node(i16vec2(pos), dir|((cost+((dir%2)==0?1:1))<<5));
		}
	}
}

void main() 
{	
	if(gl_LocalInvocationIndex == 0)
	{
		s_open_counter = uvec2(0);
	}

	memoryBarrierShared();
	barrier();

	if(gl_LocalInvocationIndex < constant.target_num.x*8)
	{
		ivec2 pos = ivec2(constant.target[gl_LocalInvocationIndex/8]);
		uint dir_type = gl_LocalInvocationIndex%8;
		int index = pos.x + pos.y * constant.reso.x;
		uint neighbor = uint(b_neighbor[index]);
		if((~neighbor & (1<<dir_type)) != 0)
		{
			explore(pos, dir_type, 0);
		}
		if((gl_LocalInvocationIndex %8) == 0 )
		{
			b_path_data[index].data = 0;
		}

	}

//	for(int i = 0; i < constant.target_num.y; i++)
	for(int i = 0; i < 5000; i++)
	{
		memoryBarrierShared();
		memoryBarrierBuffer();
		barrier();

		uint accum = s_open_counter[0];
		uint consume = s_open_counter[1];
		uint count = min(accum-consume, gl_WorkGroupSize.x);
		if(count == 0){ break; }

		bool is_open = gl_LocalInvocationIndex < count;

		barrier();

		if(gl_LocalInvocationIndex == 0)
		{
			s_open_counter[1] += count;

			// 調査用
			atomicMax(b_connect, accum-consume);
		}

		if(is_open)
		{
			Node node = s_open[(consume+gl_LocalInvocationIndex) % s_open.length()];
			uint dir_type = (node.data>>0)&((1<<4)-1);
			uint cost = (node.data>>5)&((1<<27)-1);

			explore(node.pos, dir_type, cost);
		}
	}
}
