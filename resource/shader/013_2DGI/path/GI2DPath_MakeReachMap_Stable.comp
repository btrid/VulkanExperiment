// 安定的経路探索
#version 450
#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_ballot: enable
#extension GL_KHR_shader_subgroup_arithmetic: enable

#define USE_GI2D 0
#define USE_GI2D_Path 1
#include "GI2D/GI2D.glsl"
#include "GI2D/GI2DPath.glsl"

layout (local_size_x = 1024) in;

// https://github.com/zerowidth/jps-explained
// https://zerowidth.com/2013/05/05/jump-point-search-explained.html


layout(push_constant, std430) uniform InputVertex
{
	i16vec2 target[10];
	i16vec2 target_num;
	i16vec2 reso;
} constant;


uvec4 neighor_check_list[] =
{
	uvec4(2,6,1,7), // diagonal_path 
	uvec4(3,5,4,4), // diagonal_wall
	uvec4(1,7,4,4), // straight_path
	uvec4(2,6,4,4), // straight_wall
};


struct Node
{
	i16vec2 pos;
};
shared Node s_active[2][1024*4];
shared ivec2 s_active_counter[2];

void tryPushOpen(ivec2 pos, uint dir_type, uint cost)
{
	pos += g_neighbor[dir_type];
	int index = pos.x + pos.y * constant.reso.x;

	{
		// すでにチェック済みなら終わり

		// 斜め優先
		uint prev_cost = atomicMin(b_path_data[index].data, dir_type|(int((dir_type%2)==1)<<4)|((cost+1)<<5));
		if(prev_cost == -1)
		{
			uint active_index = atomicAdd(s_active_counter[(cost+1)%2][0], 1);
			s_active[(cost+1)%2][active_index % s_active[(cost+1)%2].length()].pos = i16vec2(pos);
		}
		else
		{

		}
	}

}

void explore(in ivec2 pos, uint dir_type, uint cost)
{
	int index = pos.x + pos.y * constant.reso.x;

	// 新しい探索のチェック
	{
		uint neighbor = uint(b_neighbor[index]);
		uvec4 path_check = (dir_type.xxxx + neighor_check_list[(dir_type%2)*2]) % uvec4(8);
		uvec4 wall_check = (dir_type.xxxx + neighor_check_list[(dir_type%2)*2+1]) % uvec4(8);
		uvec4 path_bit = uvec4(1)<<path_check;
		uvec4 wall_bit = uvec4(1)<<wall_check;

		bvec4 is_path = notEqual((~neighbor.xxxx) & path_bit, uvec4(0));
		bvec4 is_wall = notEqual(neighbor.xxxx & wall_bit, uvec4(0));
		uvec4 is_open = uvec4(is_path) * uvec4(is_wall.xy, 1-ivec2(dir_type%2));

		uint is_advance = uint(((~neighbor) & (1u << dir_type)) != 0) * uint(any(is_path.zw));

		for(int i = 0; i < 4; i++)
		{
			if(is_open[i]==0){ continue; }
			tryPushOpen(pos, path_check[i], cost);
		}

		if(is_advance != 0)
		{
			tryPushOpen(pos, dir_type, cost);
		}
	}
}

void main() 
{
	if(gl_LocalInvocationIndex == 0)
	{
		s_active_counter[0] = ivec2(0);
		s_active_counter[1] = ivec2(0);
	}

	memoryBarrierShared();
	barrier();

	if(gl_LocalInvocationIndex < constant.target_num.x*8)
	{
		ivec2 pos = ivec2(constant.target[gl_LocalInvocationIndex/8]);
		uint dir_type = gl_LocalInvocationIndex%8;
		uint neighbor = uint(b_neighbor[pos.x + pos.y * constant.reso.x]);
		if((~neighbor & (1<<dir_type)) != 0)
		{
			explore(pos, dir_type, 0);
		}
	}

	for(int age = 1; age < 5000; age++)
	{
		memoryBarrierShared();
		barrier();

		int accum = s_active_counter[age%2][0];
		int consume = s_active_counter[age%2][1];
		int count = accum-consume;
		if(count == 0){ break; }

		if(gl_LocalInvocationIndex == 0)
		{
			s_active_counter[age%2][1] = accum;
		}

		while(count != 0)
		{
			bool is_active = gl_LocalInvocationIndex < count;
			Node node = is_active ? s_active[age%2][(consume+gl_LocalInvocationIndex) % s_active[age%2].length()] : Node(i16vec2(0));
			ivec2 pos = ivec2(node.pos);
			int index = pos.x + pos.y * constant.reso.x;
			int data = is_active ? int(b_path_data[index].data) : 0;
			int dir_type = (data>>0)&((1<<4)-1);
//			int cost = (data>>5)&((1<<27)-1);

			if(is_active)
			{
				explore(pos, dir_type, age);
			}

			count = max(count - int(gl_WorkGroupSize.x), 0);
			consume = min(int(gl_WorkGroupSize.x)+consume, accum);
		}
	}
}
