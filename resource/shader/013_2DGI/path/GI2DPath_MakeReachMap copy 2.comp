#version 450
#extension GL_GOOGLE_include_directive : require
#extension GL_KHR_shader_subgroup_ballot: enable
#extension GL_KHR_shader_subgroup_arithmetic: enable

#define USE_GI2D 0
#define USE_GI2D_Path 1
#include "GI2D/GI2D.glsl"
#include "GI2D/GI2DPath.glsl"

layout (local_size_x = 1024) in;

// https://github.com/zerowidth/jps-explained
// https://zerowidth.com/2013/05/05/jump-point-search-explained.html


layout(push_constant, std430) uniform InputVertex
{
	i16vec2 target[10];
	i16vec2 target_num;
	i16vec2 reso;
} constant;


uvec4 neighor_check_list[] =
{
	uvec4(2,6,1,7), // diagonal_path 
	uvec4(3,5,4,4), // diagonal_wall
	uvec4(1,7,4,4), // straight_path
	uvec4(2,6,4,4), // straight_wall
};

struct OpenNode
{
	i16vec2 pos;
//	uint dir_type:4;
//	uint cost:28;
	uint data;
};

shared OpenNode s_open[2][1024*2];
shared uvec2 s_open_counter[2];
shared uint s_age;
shared uint s_consume;

void explore(ivec2 pos, uint dir_type, uint cost)
{
//	pos += g_neighbor[dir_type];
	int index = pos.x + pos.y * constant.reso.x;
	{

		uint prev_cost = atomicCompSwap(b_path_data[index].data, -1, (dir_type) | (cost<<4));
		if(prev_cost != -1)
		{
			return;
		}
	}

	// 新しい探索のチェック
	{
		uint neighbor = uint(b_neighbor[index]);
		uvec4 path_check = (dir_type.xxxx + neighor_check_list[(dir_type%2)*2]) % u8vec4(8);
		uvec4 wall_check = (dir_type.xxxx + neighor_check_list[(dir_type%2)*2+1]) % u8vec4(8);
		u8vec4 path_bit = u8vec4(1)<<path_check;
		u8vec4 wall_bit = u8vec4(1)<<wall_check;

		bvec4 is_path = notEqual((~neighbor.xxxx) & path_bit, uvec4(0));
		bvec4 is_wall = notEqual(neighbor.xxxx & wall_bit, uvec4(0));
		uvec4 is_open = uvec4(is_path) * uvec4(is_wall.xy, 1-ivec2(dir_type%2));

		uint is_advance = uint(((~neighbor) & (1u << dir_type)) != 0) * uint(any(is_path.zw));


		uint num = is_open.x+is_open.y+is_open.z+is_open.w + is_advance;
		if(num != 0)
		{
			OpenNode node;
			node.pos = i16vec2(pos);
			
			for(int i = 0; i < 4; i++)
			{
				if(is_open[i]==0){ continue; }
				node.data = path_check[i] | ((cost+1)<<4);
				uint active_index = atomicAdd(s_open_counter[path_check[i]%2][0], 1);
				s_open[path_check[i]%2][active_index % s_open[path_check[i]%2].length()] = node;
			}

			if(is_advance != 0)
			{
				node.data = dir_type | ((cost+1)<<4);
				uint active_index = atomicAdd(s_open_counter[dir_type%2][0], 1);
				s_open[dir_type%2][active_index % s_open[dir_type%2].length()] = node;
			}
		}
	}
}

void main() 
{
	if(gl_LocalInvocationIndex == 0)
	{
		s_open_counter[0] = uvec2(0);
		s_open_counter[1] = uvec2(0);
	}
	memoryBarrierShared();
	barrier();

	if(gl_LocalInvocationIndex < constant.target_num.x*8)
	{
		ivec2 pos = ivec2(constant.target[gl_LocalInvocationIndex/8]);
		uint dir_type = gl_LocalInvocationIndex%8;
		int index = pos.x + pos.y * constant.reso.x;
		uint neighbor = uint(b_neighbor[index]);
		if((~neighbor & (1<<dir_type)) != 0)
		{
			pos += g_neighbor[dir_type];
			explore(pos, dir_type, 0);
		}
		if((gl_LocalInvocationIndex %8) == 0 )
		{
			b_path_data[index].data = 0;
//			b_parent[index] = uint8_t(0);
		}
	}


	for(int age = 1; age < constant.target_num.y; age++)
	{
		uvec2 count = uvec2(0);
		for(int n = 0; n < 2; n++)
		{
			memoryBarrierShared();
			memoryBarrierBuffer();
			barrier();

			uint accum = s_open_counter[n][0];
			uint consume = s_open_counter[n][1];
			count[n] = min(accum-consume, gl_WorkGroupSize.x);
			if(count[n] == 0){ continue; }


			bool is_open = gl_LocalInvocationIndex < count[n];
			OpenNode node = is_open ? s_open[n][(consume+gl_LocalInvocationIndex) % s_open[n].length()] : OpenNode(i16vec2(0), 0);

			uint cost = (node.data>>4)&((1<<28)-1);

			if(gl_LocalInvocationIndex == 0)
			{
				s_consume = count[n];
			}
			memoryBarrierShared();
			barrier();

			if(is_open && age != cost)
			{
				atomicMin(s_consume, gl_LocalInvocationIndex);
			}

			memoryBarrierShared();
			barrier();

			if(gl_LocalInvocationIndex == 0)
			{
				s_open_counter[n][1] += s_consume;
			}

			if(is_open && age == cost)
			{
				uint dir_type = node.data&((1<<4)-1);
//				uint cost = (parent.data>>4)&((1<<28)-1);
				ivec2 pos = node.pos + g_neighbor[dir_type];

				explore(pos, dir_type, cost);
			}

			if(s_consume != count[n]){ continue; }
		}
		if(all(equal(count, uvec2(0)))){ break; }
	}
}
