#version 450
#extension GL_GOOGLE_include_directive : require

#include "btrlib/ConvertDimension.glsl"
#include "btrlib/Common.glsl"
#include "btrlib/Math.glsl"

#define USE_GI2D 0
#include "GI2D.glsl"
#define USE_GI2D_SDF 1
#include "GI2DSDF.glsl"

layout (local_size_x = 8, local_size_y = 8) in;

layout(push_constant) uniform Input
{
	int distance;
	uint offset;
} constant;

shared i16vec2 s_cell[100];


// state.x = invalid cell
// state.y = inner or outer
void nearest(inout i16vec2 cell, inout float current_d, in bvec2 state, in ivec2 offset)
{
//	ivec2 target = (ivec2(gl_GlobalInvocationID.xy) + offset) * constant.distance;
	ivec2 target = (ivec2(gl_LocalInvocationID.xy) + offset  + ivec2(gl_WorkGroupID.xy)) * constant.distance;
	if(any(lessThan(target, ivec2(0))) || any(greaterThanEqual(target, u_gi2d_info.m_resolution.xy))){ return;}

	ivec2 local_target = ivec2(1) + ivec2(gl_LocalInvocationID.xy) + offset;
	i16vec2 target_cell = s_cell[local_target.x + local_target.y*10];
	bvec2 target_state = notEqual(target_cell & i16vec2(0x8000), i16vec2(0));

	if(target_state.y == state.y)
	{
		if(target_state.x)
		{
			return;
		}
		target = target_cell & i16vec2(0x7fff);
	}

	float d = distance(vec2(target), vec2(gl_LocalInvocationID.xy * constant.distance + gl_WorkGroupID.xy));
	if(d < current_d)
	{
		current_d = d;
		cell = i16vec2(target);
	}

}
void main() 
{
	if(gl_LocalInvocationIndex < 50)
	{
		for(int i = 0; i < 2; i++)
		{
			ivec2 local_xy = ivec2(gl_LocalInvocationIndex % 10, gl_LocalInvocationIndex / 10 + 5*i);
			ivec2 access_index = (ivec2(-1) + local_xy) * constant.distance + ivec2(gl_WorkGroupID.xy);
			bool invalid = any(lessThan(access_index, ivec2(0))) || any(greaterThanEqual(access_index, ivec2(u_gi2d_info.m_resolution)));
			i16vec2 cell = invalid ? i16vec2(0xffff) : b_jfa[access_index.x + access_index.y*u_gi2d_info.m_resolution.x/* + constant.offset*/];
			s_cell[local_xy.x + local_xy.y * 10] = cell;

		}
	}
	barrier();
	memoryBarrierShared();

	uvec2 current = ivec2(gl_LocalInvocationID.xy * constant.distance + gl_WorkGroupID.xy);
	if(any(greaterThanEqual(current, u_gi2d_info.m_resolution.xy))){ return; }

	ivec2 local_target = ivec2(1) + ivec2(gl_LocalInvocationID.xy);
	i16vec2 cell = s_cell[local_target.x + local_target.y*10];
	bvec2 state = notEqual(cell & i16vec2(0x8000), i16vec2(0));
	cell = cell & i16vec2(0x7fff);

	float d = !state.x ? distance(vec2(current), vec2(cell)) : 99999999.;
	const float old_d = d;

	const ivec3 offset = ivec3(-1, 0, 1);
	nearest(cell, d, state, offset.xx);
	nearest(cell, d, state, offset.xy);
	nearest(cell, d, state, offset.xz);
	nearest(cell, d, state, offset.yx);
	nearest(cell, d, state, offset.yz);
	nearest(cell, d, state, offset.zx);
	nearest(cell, d, state, offset.zy);
	nearest(cell, d, state, offset.zz);

	if(d != old_d)
	{
		b_jfa[current.x + current.y*u_gi2d_info.m_resolution.x/* + constant.offset*/] = cell | i16vec2(0, int16_t(state.y)<<15);
	}
}
