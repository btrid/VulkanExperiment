#version 450
#extension GL_GOOGLE_include_directive : require

#include "btrlib/ConvertDimension.glsl"
#include "btrlib/Common.glsl"
#include "btrlib/Math.glsl"

#define USE_PM 0
#define USE_PM_RENDER 1
#include "PM.glsl"

/*
layout(push_constant) uniform BounceInfo
{
	int bounce_count;
	int store_photon_index;
} constant;
*/
#define u16_max (0xffff)
#define fragment_state_non (0)
#define fragment_state_wall (1)
#define fragment_state_light (2)
#define fragment_state_bounce (3)
#define fragment_state_bounce_hit (4)

layout (local_size_x = 8, local_size_y = 8) in;

uint64_t popcnt(in uint64_t n)
{
    uint64_t c = (n & 0x5555555555555555ul) + ((n>>1) & 0x5555555555555555ul);
    c = (c & 0x3333333333333333ul) + ((c>>2) & 0x3333333333333333ul);
    c = (c & 0x0f0f0f0f0f0f0f0ful) + ((c>>4) & 0x0f0f0f0f0f0f0f0ful);
    c = (c & 0x00ff00ff00ff00fful) + ((c>>8) & 0x00ff00ff00ff00fful);
    c = (c & 0x0000ffff0000fffful) + ((c>>16) & 0x0000ffff0000fffful);
    c = (c & 0x00000000fffffffful) + ((c>>32) & 0x00000000fffffffful);
    return c;
}
u64vec4 popcnt4(in u64vec4 n)
{
    u64vec4 c = (n & 0x5555555555555555ul) + ((n>>1) & 0x5555555555555555ul);
    c = (c & 0x3333333333333333ul) + ((c>>2) & 0x3333333333333333ul);
    c = (c & 0x0f0f0f0f0f0f0f0ful) + ((c>>4) & 0x0f0f0f0f0f0f0f0ful);
    c = (c & 0x00ff00ff00ff00fful) + ((c>>8) & 0x00ff00ff00ff00fful);
    c = (c & 0x0000ffff0000fffful) + ((c>>16) & 0x0000ffff0000fffful);
    c = (c & 0x00000000fffffffful) + ((c>>32) & 0x00000000fffffffful);
    return c;
}
shared uint64_t s_is_hit[1];
shared uint64_t s_is_occlude[1];
void main()
{
	if(gl_LocalInvocationIndex < 1){
		s_is_hit[gl_LocalInvocationIndex] = b_emission_reached[gl_WorkGroupID.x + gl_WorkGroupID.y*gl_NumWorkGroups.x];
		s_is_occlude[gl_LocalInvocationIndex] = b_emission_occlusion[gl_WorkGroupID.x + gl_WorkGroupID.y*gl_NumWorkGroups.x];
	}

	barrier();
	memoryBarrierShared();

	const ivec4 reso = ivec4(u_pm_info.m_resolution.xy, u_pm_info.m_resolution.xy/8);


	vec3 illuminance = vec3(0.);

	vec2 end = vec2(gl_GlobalInvocationID.xy);

	ivec2 map_index_hie = ivec2(end);
	ivec4 fragment_index = ivec4(map_index_hie/8, map_index_hie%8);
	ivec2 shift = fragment_index.zw;

	ivec4 findex = fragment_index.xxxx + ivec4(0,0,1,1) + (fragment_index.yyyy + ivec4(0,1,0,1))*(reso.zzzz);
	uint64_t b0 = b_fragment_map[findex.x];
	uint64_t b1 = b_fragment_map[findex.y];
	uint64_t b2 = b_fragment_map[findex.z];
	uint64_t b3 = b_fragment_map[findex.w];
	uint64_t bit_mask = 1ul << gl_LocalInvocationIndex;
	uint64_t occlude_emit_num = popcnt(s_is_occlude[0]);

	const ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
	const ivec2 tile_index_2d = pixel / ivec2(u_pm_info.m_emission_tile_size.xy);
	const int tile_index = int(tile_index_2d.x + tile_index_2d.y*u_pm_info.m_emission_tile_num.x);
	for(int i = b_emission_tile_linkhead[tile_index]; i != -1; i= b_emission_tile_linklist[i].next)
	{
		Emission light;
		vec2 start;
		{
			int emission_index = b_emission_tile_linklist[i].target;
//			int eoffset = u_pm_info.m_emission_buffer_offset[constant.bounce_count];
			light = b_emission[emission_index];
//			ivec2 e_index_2d = ivec2(emission_index%bounce_reso.x, emission_index/bounce_reso.x);
			ivec2 e_index_2d = ivec2(emission_index%u_pm_info.m_resolution.x, emission_index/u_pm_info.m_resolution.x);
			start = vec2(e_index_2d);
		}
	
		const float ray_dist = distance(end, start);
//		vec3 radiance = (light.emission.xyz / (1.+ray_dist/**ray_dist*/));
		vec3 radiance = vec3(1., 1., 1.);
//		radiance *= float(popcnt(s_is_hit[0])+occlude_emit_num) / 64.;
//		radiance *= float(64-occlude_emit_num) / 64.;
		radiance = ((b0&bit_mask) == 0) ? radiance : vec3(0.) ;

		illuminance += ((s_is_hit[0]&bit_mask) != 0) ? radiance : vec3(0.) ;
//		illuminance += radiance;

		illuminance = ray_dist <= 10. ? vec3(1., 0., 1.) : illuminance;

	}

	imageStore(t_color[0], pixel, vec4(illuminance.xyz, 1.));
}
