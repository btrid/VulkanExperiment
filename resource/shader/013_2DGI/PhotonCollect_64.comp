#version 450
#extension GL_GOOGLE_include_directive : require

#include "btrlib/ConvertDimension.glsl"
#include "btrlib/Common.glsl"
#include "btrlib/Math.glsl"

#define USE_PM 0
#define USE_PM_RENDER 1
#include "PM.glsl"

/*
layout(push_constant) uniform BounceInfo
{
	int bounce_count;
	int store_photon_index;
} constant;
*/
#define u16_max (0xffff)
#define fragment_state_non (0)
#define fragment_state_wall (1)
#define fragment_state_light (2)
#define fragment_state_bounce (3)
#define fragment_state_bounce_hit (4)

layout (local_size_x = 8, local_size_y = 8) in;

uint64_t popcnt(in uint64_t n)
{
    uint64_t c = (n & 0x5555555555555555ul) + ((n>>1) & 0x5555555555555555ul);
    c = (c & 0x3333333333333333ul) + ((c>>2) & 0x3333333333333333ul);
    c = (c & 0x0f0f0f0f0f0f0f0ful) + ((c>>4) & 0x0f0f0f0f0f0f0f0ful);
    c = (c & 0x00ff00ff00ff00fful) + ((c>>8) & 0x00ff00ff00ff00fful);
    c = (c & 0x0000ffff0000fffful) + ((c>>16) & 0x0000ffff0000fffful);
    c = (c & 0x00000000fffffffful) + ((c>>32) & 0x00000000fffffffful);
    return c;
}
u64vec4 popcnt4(in u64vec4 n)
{
    u64vec4 c = (n & 0x5555555555555555ul) + ((n>>1) & 0x5555555555555555ul);
    c = (c & 0x3333333333333333ul) + ((c>>2) & 0x3333333333333333ul);
    c = (c & 0x0f0f0f0f0f0f0f0ful) + ((c>>4) & 0x0f0f0f0f0f0f0f0ful);
    c = (c & 0x00ff00ff00ff00fful) + ((c>>8) & 0x00ff00ff00ff00fful);
    c = (c & 0x0000ffff0000fffful) + ((c>>16) & 0x0000ffff0000fffful);
    c = (c & 0x00000000fffffffful) + ((c>>32) & 0x00000000fffffffful);
    return c;
}
shared uint64_t s_is_hit[1];
shared uint64_t s_is_occlude[1];
void main()
{
	if(gl_LocalInvocationIndex < 1){
		s_is_hit[gl_LocalInvocationIndex] = b_emission_reached[gl_WorkGroupID.x + gl_WorkGroupID.y*gl_NumWorkGroups.x];
		s_is_occlude[gl_LocalInvocationIndex] = b_emission_occlusion[gl_WorkGroupID.x + gl_WorkGroupID.y*gl_NumWorkGroups.x];
	}

	barrier();
	memoryBarrierShared();

	const ivec4 reso = ivec4(u_pm_info.m_resolution.xy, u_pm_info.m_resolution.xy/8);


	vec3 illuminance = vec3(0.);

	vec2 end = vec2(gl_GlobalInvocationID.xy);

	ivec2 map_index_hie = ivec2(end);
	ivec4 fragment_index = ivec4(map_index_hie/8, map_index_hie%8);
	ivec2 shift = fragment_index.zw;

	int findex_ = fragment_index.x + fragment_index.y*reso.z;
	uint64_t b = b_fragment_map[findex_.x];
	uint64_t bit_mask = 1ul << gl_LocalInvocationIndex;

//	ivec2 f_idx_offset = ivec2(greaterThanEqual(fragment_index.zw, uvec2(4))) * 2 - 1;
	uint64_t reached_map;
	{
		ivec2 f_idx_offset = ivec2(0);
		ivec4 findex = fragment_index.xxxx + ivec4(0,0,1,1)+f_idx_offset.xxxx + (fragment_index.yyyy + ivec4(0,1,0,1)+f_idx_offset.yyyy)*(reso.zzzz);
		uint64_t r0 = b_emission_reached[findex.x];
		uint64_t r1 = b_emission_reached[findex.y];
		uint64_t r2 = b_emission_reached[findex.z];
		uint64_t r3 = b_emission_reached[findex.w];
		u64vec4 r = u64vec4(r0, r1,r2,r3);

		uint64_t x_line_mask2 = 0xfful & ((1ul << (shift.x)) - 1ul);
		uint64_t x_mask_inv2 = x_line_mask2 | (x_line_mask2 << 8) | (x_line_mask2 << 16) | (x_line_mask2 << 24) | (x_line_mask2 << 32) | (x_line_mask2 << 40) | (x_line_mask2 << 48) | (x_line_mask2 << 56);
		uint64_t y_mask_inv2 = 0xfffffffffffffffful & ((1ul << ((shift.y) * 8)) - 1);
		uint64_t x_mask2 = ~x_mask_inv2;
		uint64_t y_mask2 = ~y_mask_inv2;
		r &= u64vec4(x_mask2 & y_mask2, x_mask2 & ~y_mask2, ~x_mask2 & y_mask2, ~x_mask2 & ~y_mask2);

		ivec4 rs = shift.yyyy*ivec4(8,0,8,0) + shift.xxxx*ivec4(1,1,0,0);
		ivec4 ls = (8-shift.yyyy)*ivec4(0,8,0,8) + (8-shift.xxxx)*ivec4(0,0,1,1);

		r >>= rs;
		r <<= ls;

		reached_map = r.x|r.y|r.z|r.w;
		
	}

	uint64_t occlude_emit_num = popcnt(s_is_occlude[0]);

	const ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
	const ivec2 tile_index_2d = pixel / ivec2(u_pm_info.m_emission_tile_size.xy);
	const int tile_index = int(tile_index_2d.x + tile_index_2d.y*u_pm_info.m_emission_tile_num.x);
	for(int i = b_emission_tile_linkhead[tile_index]; i != -1; i= b_emission_tile_linklist[i].next)
	{
		Emission light;
		vec2 start;
		{
			int emission_index = b_emission_tile_linklist[i].target;
//			int eoffset = u_pm_info.m_emission_buffer_offset[constant.bounce_count];
			light = b_emission[emission_index];
//			ivec2 e_index_2d = ivec2(emission_index%bounce_reso.x, emission_index/bounce_reso.x);
			ivec2 e_index_2d = ivec2(emission_index%u_pm_info.m_resolution.x, emission_index/u_pm_info.m_resolution.x);
			start = vec2(e_index_2d);
		}
	
		const float ray_dist = distance(end, start);
//		vec3 radiance = (light.emission.xyz / (1.+ray_dist/**ray_dist*/));
		vec3 radiance = vec3(1., 1., 1.);
//		radiance *= float(popcnt(reached_map)) / 64.;
//		radiance *= float(64-occlude_emit_num) / 64.;
		radiance = ((s_is_hit[0]&bit_mask) != 0) ? radiance : vec3(1., 0., 0.);
		radiance = ((b&bit_mask) == 0) ? radiance : vec3(0., 0., 1.);

		illuminance += radiance;

		illuminance = ray_dist <= 5. ? vec3(1., 1., 0.) : illuminance;

	}

	imageStore(t_color[0], pixel, vec4(illuminance.xyz, 1.));
}
