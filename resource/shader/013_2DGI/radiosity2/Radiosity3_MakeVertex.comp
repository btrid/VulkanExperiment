#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Radiosity2 1
#include "GI2D.glsl"
#include "Radiosity2.glsl"

layout (local_size_x = 32, local_size_y = 32) in;

shared uint64_t s_map[10][10];

void main() 
{

	if(gl_LocalInvocationID.x < 10 && gl_LocalInvocationID.y < 10)
	{
		uint i = gl_LocalInvocationID.x+gl_LocalInvocationID.y*10;
		uvec2 offset_xy = gl_LocalInvocationID.xy-1;
		uvec2 index = gl_WorkGroupID.xy*8 + offset_xy;

		uint64_t map = -1ul;
		if(all(lessThan(index, u_gi2d_info.m_resolution.zw)))
		{
			map = b_fragment_map[index.x + index.y * u_gi2d_info.m_resolution.z];
		}
		s_map[gl_LocalInvocationID.y][gl_LocalInvocationID.x] = map;
	}

	memoryBarrierShared();
	barrier();

	ivec2 index_frame_offset = ivec2(u_radiosity_info.frame%2,u_radiosity_info.frame/2) + ivec2(-1);
	bool is_diffuse = false;
	for(int i = 0; i < 4; i++)
	{
		ivec2 ii = ivec2(gl_LocalInvocationID.xy)*2 + ivec2(i%2,i/2) + ivec2(8);
		ii += index_frame_offset;
		ivec2 map_index = ii / 8;
		ivec2 map_bit = ii % 8;
		if((s_map[map_index.y][map_index.x] & (1ul<<(map_bit.x+map_bit.y*8))) != 0ul)
		{
			is_diffuse = true;
			break;
		}
	}

	if(is_diffuse)
	{
		vec3 rad = vec3(0.);
		vec3 albedo = vec3(0.);
		int count = 0;
		for(int i = 0; i < 4; i++)
		{
			ivec2 index = ivec2(gl_GlobalInvocationID.xy)*2 + ivec2(i%2,i/2) + ivec2(8);
			index += index_frame_offset;
			if(any(lessThan(index, ivec2(0))) || any(greaterThanEqual(index, u_gi2d_info.m_resolution.xy))) 
			{
				continue; 
			}
			
			int ii = index.x+index.y*u_gi2d_info.m_resolution.x;
			vec3 color = vec3(getRGB(b_fragment[ii]));
			rad += color * vec3(isEmissive(b_fragment[ii])) * 0.3;
			albedo += color;
			count++;
		}
		u64vec3 emissive_u3 = u64vec3(round(rad * vec3(1024.))) / ((count==0)?1:count);
		uint64_t packed = emissive_u3.x + (emissive_u3.y<<21ul) + (emissive_u3.z<<42ul);

		uint index = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * (u_gi2d_info.m_resolution.x/2);
		b_radiance[index] = packed;
		b_radiance[index+u_gi2d_info.m_resolution.x*u_gi2d_info.m_resolution.y/4] = packed;
		b_albedo[index] = f16vec4(albedo / ((count==0)?1:count), 1.);

		uvec2 map = gl_GlobalInvocationID.xy / 8;
		uvec2 bit = gl_GlobalInvocationID.xy % 8;
		atomicOr(b_edge[map.x + map.y*(u_gi2d_info.m_resolution.z/2)], 1ul<<(bit.x+bit.y*8));

	}
}
