#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Path 1
#include "GI2D.glsl"
#include "GI2DPath.glsl"

layout (local_size_x = 32, local_size_y = 32) in;

layout(push_constant) uniform InputVertex
{
	ivec2 reso;
	i16vec2 target[2];
} constant;


shared uint64_t s_map[36];

void main() 
{
//	if(gl_LocalInvocationIndex < 36)
	if(gl_LocalInvocationID.x < 6 && gl_LocalInvocationID.y < 6)
	{
		uint i = gl_LocalInvocationID.x+gl_LocalInvocationID.y*6;
		ivec2 offset_xy = ivec2(gl_LocalInvocationID.xy)-1;
		ivec2 index = ivec2(gl_NumWorkGroups.xy*4) + offset_xy;

		if(any(greaterThanEqual(index, u_gi2d_info.m_resolution.zw)) || any(lessThan(index, ivec2(0))))
		{
			// 範囲外は壁
			s_map[i] = -1ul;
		}
		else
		{
			s_map[i] = b_diffuse_map[getMemoryOrder(index)];
		}
	}

	barrier();
	memoryBarrierShared();

	const i16vec2 g_offset[4] = { i16vec2(1, 0), i16vec2(-1, 0), i16vec2(0, 1), i16vec2(0, -1) };
	uint8_t state = uint8_t(0);
	for(int i = 0; i < 4; i++)
	{
		ivec2 access = ivec2(gl_GlobalInvocationID.xy) + g_offset[i];
		if (any(lessThan(access, ivec2(0))) || any(greaterThanEqual(access, constant.reso)))
		{
			state |= uint8_t(1<<i);
			continue;
		}

		ivec2 map_index = ivec2(gl_LocalInvocationID.xy + g_offset[i] + ivec2(8))/8;
		ivec2 map_bit = ivec2(gl_LocalInvocationID.xy + g_offset[i] + ivec2(8))%8;
		if((s_map[map_index.x+map_index.y*6] & (1<<(map_bit.x+map_bit.y*8))) != 0)
		{
			state |= uint8_t(1<<i);
			continue;
		}
	}

	b_state[gl_GlobalInvocationID.x*gl_GlobalInvocationID.y] = state;

}
