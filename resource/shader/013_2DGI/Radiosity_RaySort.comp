#version 450
#extension GL_GOOGLE_include_directive : require

#include "btrlib/ConvertDimension.glsl"
#include "btrlib/Common.glsl"
#include "btrlib/Math.glsl"

#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#include "GI2D.glsl"


#define Density (1)
layout (local_size_x = 128, local_size_y = 1) in;
void main()
{
	const ivec4 reso = ivec4(u_gi2d_info.m_resolution.xy, u_gi2d_info.m_resolution.xy/8);

	float angle = 6.28 / gl_NumWorkGroups.y;
	angle += angle * (gl_GlobalInvocationID.z / gl_NumWorkGroups.z);
	vec2 dir = rotate(angle * gl_GlobalInvocationID.y);
	dir.x = abs(dir.x) < 0.0001 ? 0.0001 : dir.x;
	dir.y = abs(dir.y) < 0.0001 ? 0.0001 : dir.y;
	vec2 inv_dir = abs(1./dir);
	dir *= min(inv_dir.x, inv_dir.y);

	vec2 floorp;
	floorp.x = dir.x >= 0 ? 0. : reso.x;
	floorp.y = dir.y >= 0 ? 0. : reso.y;
	vec2 floordir;
	floordir.x = abs(dir.x) > abs(dir.y) ? 0. : 1.;
	floordir.y = abs(dir.x) > abs(dir.y) ? 1. : 0.;

	vec2 p0 = intersectRayRay(vec2(0, 0), dir, floorp, floordir);
	vec2 p1 = intersectRayRay(vec2(reso.x, 0), dir, floorp, floordir);
	vec2 p2 = intersectRayRay(vec2(0, reso.y), dir, floorp, floordir);
	vec2 p3 = intersectRayRay(vec2(reso.x, reso.y), dir, floorp, floordir);

	vec2 minp = min(min(min(p0, p1), p2), p3);
	vec2 maxp = max(max(max(p0, p1), p2), p3);

	vec2 pos = minp + floordir * (8./Density) * gl_LocalInvocationIndex;
	pos += floordir * (8./Density) * (gl_GlobalInvocationID.z / gl_NumWorkGroups.z);
	if(!marchToAABB(pos, dir, vec2(0.), reso.xy)){return;}

}
