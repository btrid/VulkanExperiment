#version 450
#extension GL_GOOGLE_include_directive : require

#include "btrlib/ConvertDimension.glsl"
#include "btrlib/Common.glsl"
#include "btrlib/Math.glsl"

#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#include "GI2D.glsl"

#define RAY_PER_PIXEL (127)
layout (local_size_x=RAY_PER_PIXEL, local_size_y=4) in;
void main()
{
	if(ActiveRayAllNum() >= u_radiosity_info.ray_num_max){ return; }

	const int hierarchy = u_gi2d_scene.m_hierarchy;
	const ivec4 reso = ivec4(u_gi2d_info.m_resolution.xy, u_gi2d_info.m_resolution.xy/8);

	float a = 6.283 / gl_WorkGroupSize.x;
	float angle = a * gl_LocalInvocationID.x;
	angle += a*(0.25*gl_WorkGroupID.z + 0.125);// 0除算回避の0.125

	vec2 dir = rotate(angle);
	vec2 inv_dir = abs(1./dir);

	vec2 segment_one = dir*max(inv_dir.x, inv_dir.y);

	vec2 pos;
	pos.x = gl_GlobalInvocationID.y==3 ? reso.x-1 : 0;
	pos.y = gl_GlobalInvocationID.y==1 ? reso.y-1 : 0;
	pos += 0.5;
	vec2 pdir;
	pdir.x = gl_GlobalInvocationID.y/2==0 ? 1 : 0;
	pdir.y = gl_GlobalInvocationID.y/2==1 ? 1 : 0;

	pos += pdir * abs(segment_one)*gl_WorkGroupID.x;
	vec2 begin = pos;
	ivec2 map_index = ivec2(pos);
	dir *= min(inv_dir.x, inv_dir.y);

	int march_count = 0;
	for(; march_count <5000; march_count++)
	{
		// march
		{
			// DDA
			pos = begin + march_count*dir;
			map_index = ivec2(pos);
		}
		// 範囲外?
		{
			ivec2 is_die = ivec2(greaterThanEqual(map_index, reso.xy)) + ivec2(lessThan(map_index, ivec2(0)));
			if(any(notEqual(is_die.xy, ivec2(0))))
			{
				break;
			}
		}
	}

	if(march_count <= 1) { return; }
	D2Ray ray;
	ray.origin = begin;
	ray.angle = angle;
	ray.march = march_count;
	
	int buffer_index = atomicAdd(b_ray_counter[4].x, 1);
	if(buffer_index >= u_radiosity_info.ray_num_max){ return; }
	b_ray[buffer_index] = ray;

	int index = atomicAdd(b_ray_counter[gl_WorkGroupID.z].w, 1);
	if(index%1024 == 0){
		atomicAdd(b_ray_counter[gl_WorkGroupID.z].x, 1);
	}
}
