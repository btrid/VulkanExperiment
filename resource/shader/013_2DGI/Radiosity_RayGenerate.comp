#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#include "GI2D.glsl"

//#define HALF_PI (1.5708)
//#define TWO_PI (6.2832)
//#define QUARTER_PI (0.7854)

#define HALF_PI radians(90.)
#define TWO_PI radians(360.)
#define PI radians(180.)
#define QUARTER_PI radians(45.)

layout (local_size_x=128) in;

bool intersection(in vec4 aabb, in vec2 pos, in vec2 inv_dir, out int march)
{
	vec4 t = ((aabb - pos.xyxy)*inv_dir.xyxy);
	t = vec4(lessThan(t, vec4(0.f))) * 999999.f + t;
	vec2 tmin2 = min(t.xy, t.zw);
	vec2 tmax2 = max(t.xy, t.zw);

	march = int(min(tmin2.x, tmin2.y));

//	float tmin = max(tmin2.x, tmin2.y);
//	float tmax = min(tmax2.x, tmax2.y);
	return min(tmax2.x, tmax2.y) >= max(tmin2.x, tmin2.y);
}

D2Ray makeRay(in uint x, in uint y)
{
	const ivec4 reso = u_gi2d_info.m_resolution;

	float a = TWO_PI / (gl_NumWorkGroups.y);
	float c = (a / gl_NumWorkGroups.z) * (gl_WorkGroupID.z);
	float angle = fma(a, float(y), c);
	
	uint area = uint(angle / HALF_PI);

	vec2 pos;
	pos.x = (area==0) ? (reso.x+0.5) : -0.5;
	pos.y = (area==1) ? (reso.y+0.5) : -0.5;

	vec2 pdir;
	pdir.x = (area%2==1) ? 1 : 0;
	pdir.y = (area%2==0) ? 1 : 0;

	pos += pdir*x;


	ivec2 map_index = ivec2(pos);

	angle += QUARTER_PI;
	vec2 dir = calcDir(angle);

	pos.x += ((area%2)==1&&dir.x>=0.)?-reso.x:0;
	pos.y += ((area%2)==0&&dir.y>=0.)?-reso.y:0;

	vec2 inv_dir = 1. / dir;
	inv_dir = vec2(isnan(inv_dir)) * 99999999. + inv_dir;
	int march = 0;
	if(!intersection(vec4(vec2(0., 0.), vec2(reso.xy)), pos, inv_dir, march))
	{
		D2Ray ray;
		ray.origin = vec2(512.);
		ray.angle = 999.;
		ray.march = -1;
		return ray;
	}
	vec2 begin = fma(dir, vec2(march), pos);

	if(!intersection(vec4(vec2(0., 0.), vec2(reso.xy)), begin+dir, inv_dir, march))
	{
		D2Ray ray;
		ray.origin = vec2(512.);
		ray.angle = 9999.;
		ray.march = -1;
		return ray;
	}

	D2Ray ray;
	ray.origin = begin;
	ray.angle = angle;
	ray.march = march+1;

	return ray;
}

void main()
{
	uint buffer_offset = u_radiosity_info.ray_frame_max*gl_WorkGroupID.z;
	D2Ray ray = makeRay(gl_GlobalInvocationID.x, gl_WorkGroupID.y);
	b_ray[gl_GlobalInvocationID.x + gl_WorkGroupID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x + buffer_offset] = ray;

}
