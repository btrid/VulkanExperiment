#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#include "GI2D/GI2D.glsl"
#include "GI2D/Radiosity.glsl"

layout (local_size_x = 1024) in;

bool intersection(in ivec4 aabb, in ivec2 pos, in int R)
{
	// https://yal.cc/rectangle-circle-intersection-test/
	int delta_x = pos.x - max(aabb.x, min(pos.x, aabb.z));
	int delta_y = pos.y - max(aabb.y, min(pos.y, aabb.w));
	return delta_x*delta_x+delta_y*delta_y < R*R;
}
void main() 
{
	vec3 color = vec3(b_emissive[gl_GlobalInvocationID.x].color.xyz);
	int emissive_power = clamp(int(ceil(sqrt(dot(color, vec3(1.)) / 3.)))-1, 0, 7);

	uint cmd_index = gl_GlobalInvocationID.x;

	if(!intersection(ivec4(0, 0, u_gi2d_info.m_resolution.xy-1), b_emissive[gl_GlobalInvocationID.x].pos, 1)
	{
		// マップ範囲外(todo mapとレンダリング矩形を分ける)
		v_emissive_draw_command[cmd_index] = uvec4(0, 0, 0, 0);
		return;
	}
	if(emissive_power <= 6)
	{
		if(!intersection(ivec4(0, 0, u_gi2d_info.m_resolution.xy-1), b_emissive[gl_GlobalInvocationID.x].pos, (emissive_power+1)*100))
		{
			// レンダリング範囲外
			v_emissive_draw_command[cmd_index] = uvec4(0, 0, 0, 0);
			return;
		}

	}

	if(emissive_power>= 7)
	{
		uint v_num = (u_gi2d_info.m_resolution.x+u_gi2d_info.m_resolution.y)*2;
		v_emissive_draw_command[cmd_index] = uvec4(v_num, 1, 0, cmd_index);
		b_emissive[cmd_index].flag = u16vec2(emissive_power, uint16_t(0xffff));
	}
	else
	{

		uint v_num = u_circle_mesh_count[emissive_power/4][emissive_power%4];
		v_emissive_draw_command[cmd_index] = uvec4(v_num*8+2, 1, 0, cmd_index);
		b_emissive[cmd_index].flag = u16vec2(emissive_power, v_num);
	}
}
