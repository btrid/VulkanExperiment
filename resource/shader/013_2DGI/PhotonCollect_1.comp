#version 450
#extension GL_GOOGLE_include_directive : require

#include "btrlib/ConvertDimension.glsl"
#include "btrlib/Common.glsl"
#include "btrlib/Math.glsl"

#define USE_PM 0
#define USE_PM_RENDER 1
#include "PM.glsl"

/*
layout(push_constant) uniform BounceInfo
{
	int bounce_count;
	int store_photon_index;
} constant;
*/
#define u16_max (0xffff)
#define fragment_state_non (0)
#define fragment_state_wall (1)
#define fragment_state_light (2)
#define fragment_state_bounce (3)
#define fragment_state_bounce_hit (4)

layout (local_size_x = 32, local_size_y = 32) in;

void main()
{
	uint64_t is_reached = b_emission_reached[gl_GlobalInvocationID.x + gl_GlobalInvocationID.y*u_pm_info.m_resolution.x];

	vec3 illuminance = vec3(0.);
	vec2 end = vec2(gl_GlobalInvocationID.xy);

	int light_count = 0;
	const ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
	const ivec2 tile_index_2d = pixel / ivec2(u_pm_info.m_emission_tile_size.xy);
	const int tile_index = int(tile_index_2d.x + tile_index_2d.y*u_pm_info.m_emission_tile_num.x);
	for(int i = b_emission_tile_linkhead[tile_index]; i != -1; i= b_emission_tile_linklist[i].next)
	{
		Emission light;
		vec2 start;
		{
			int emission_index = b_emission_tile_linklist[i].target;
//			int eoffset = u_pm_info.m_emission_buffer_offset[constant.bounce_count];
			light = b_emission[emission_index];
//			ivec2 e_index_2d = ivec2(emission_index%bounce_reso.x, emission_index/bounce_reso.x);
			ivec2 e_index_2d = ivec2(emission_index%u_pm_info.m_resolution.x, emission_index/u_pm_info.m_resolution.x);
			start = vec2(e_index_2d/*<<constant.bounce_count*/);
		}
	
		const float ray_dist = distance(end, start);
		vec3 radiance = (light.emission.xyz / (1.+ray_dist/**ray_dist*/));
		uint64_t bit_mask = 1ul << light_count;
		illuminance += ((is_reached&bit_mask) != 0) ? radiance : vec3(0.) ;
		light_count++;
	}

	imageStore(t_color[0], pixel, illuminance.xyzz);
}
