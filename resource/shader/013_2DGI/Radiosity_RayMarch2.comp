#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#include "GI2D.glsl"

#define HALF_PI (1.5707963)
#define TWO_PI (6.28318530)
#define QUARTER_PI (0.7853981633)

layout (local_size_x=64) in;

shared u64vec2 s_fragment[17];
shared ivec2 s_base_index;
void main()
{
	const ivec4 reso = u_gi2d_info.m_resolution;

	uint ray_index = gl_GlobalInvocationID.x;
	D2Ray ray = b_ray[gl_GlobalInvocationID.x];
	vec2 dir = calcDir(ray.angle);
	int y = int(ray.angle / HALF_PI);
	ivec2 idir = ivec2(sign(dir) * 0.5 + 0.5);
	int dir_type = y%2; // 横:0 縦:1
	int dir_sign = (y/2) * 2 - 1;
	ivec2 pdir = ((dir_type==1) ? ivec2(1, 0) : ivec2(0, 1)) * int(gl_LocalInvocationID.x);
	int fragment_offset = dir_type * reso.z*reso.w; // 縦ほうこうに進む場合

	D2Segment seg;
	seg.ray_index = ray_index;
	seg.begin = 0;
	seg.march = 0;
	seg.radiance = 0;
	int march_count = 0;
	for(; march_count < ray.march; )
	{
		{
			vec2 pos = fma(dir, float(march_count).xx, ray.origin);
			ivec2 index = ivec2(pos);
			ivec2 map_index = index >> 3;
			if(gl_LocalInvocationIndex < 17)
			{
				ivec2 mi = map_index + idir;
				s_fragment[gl_LocalInvocationIndex] = b_fragment_map[mi.x + mi.y*reso.z + fragment_offset];
			}
			
		}

		for(uint i = 0; i < 8; i++)
		{
			vec2 pos = fma(dir, float(march_count).xx, ray.origin);
			if(gl_LocalInvocationIndex == 0)
			{
				s_base_index = ivec2(pos) % 8 + (1-idir)*8;
			}
			memoryBarrierShared();
			barrier();

			ivec2 local_index = s_base_index + pdir;
			ivec2 map_local_index = local_index >> 3;
			ivec2 cell_sub = local_index%8;
			u64vec2 map = s_fragment[map_local_index[dir_type]];

			bvec2 attr = notEqual((map & (1ul<<(cell_sub.x+cell_sub.y*8))), u64vec2(0));
			if(attr.y)
			{
				seg.radiance += b_light[getMemoryOrder(uvec2(pos))];
			}
			if(attr.x)
			{
				if(seg.march > 1)
				{
					int index = atomicAdd(b_segment_counter.w, 1);
					if(index%1024==0){
						atomicAdd(b_segment_counter.x, 1);
					}
					b_segment[index] = seg;
				}
				seg.begin = march_count;
				seg.march = 0;
				seg.radiance = 0;
			}
			seg.march++;
			march_count++;
		}
	}

	// 行きすぎたら戻す
	seg.march -= march_count-ray.march;
	if(seg.march > 1)
	{
		int index = atomicAdd(b_segment_counter.w, 1);
		if(index%1024==0){
			atomicAdd(b_segment_counter.x, 1);
		}
		b_segment[index] = seg;
	}


}
