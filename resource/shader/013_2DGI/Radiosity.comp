// セルをスキップしないレイトレ
#version 450
#extension GL_GOOGLE_include_directive : require

#include "btrlib/ConvertDimension.glsl"
#include "btrlib/Common.glsl"
#include "btrlib/Math.glsl"

#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#include "GI2D.glsl"

layout (local_size_x = 256*Ray_Density, local_size_y = 1) in;
void main()
{
	const ivec4 reso = ivec4(u_gi2d_info.m_resolution.xy, u_gi2d_info.m_resolution.xy/8);
	int hierarchy = u_gi2d_scene.m_hierarchy;

	float a = 6.28318530717958647692528676655900576 / gl_NumWorkGroups.y;
	float angle = a * gl_GlobalInvocationID.y;
	angle += a * 0.25*u_gi2d_scene.m_frame;

	vec2 dir = rotate(angle);
	vec2 inv_dir;
	inv_dir.x = dir.x == 0. ? 999999. : abs(1./dir.x);
	inv_dir.y = dir.y == 0. ? 999999. : abs(1./dir.y);

	vec2 floorp = vec2(lessThan(dir, vec2(0.))) * reso.xy;
	vec2 floordir = abs(dir.x) > abs(dir.y) ? vec2(0., 1.) : vec2(1., 0.);

	vec2 p0 = intersectRayRay(vec2(0, 0), dir, floorp, floordir);
	vec2 p1 = intersectRayRay(vec2(reso.x, 0), dir, floorp, floordir);
	vec2 p2 = intersectRayRay(vec2(0, reso.y), dir, floorp, floordir);
	vec2 p3 = intersectRayRay(vec2(reso.x, reso.y), dir, floorp, floordir);

	vec2 minp = min(min(min(p0, p1), p2), p3);
	vec2 maxp = max(max(max(p0, p1), p2), p3);

	u64vec4 hit_mask;
	ivec4 offset_x;
	ivec4 offset_y;
	{
		vec2 side = normalize(rotateZ(dir, 3.14*0.5));
		{
			vec2 inv_side;
			inv_side.x = side.x == 0. ? 99999. : abs(1./side.x);
			inv_side.y = side.y == 0. ? 99999. : abs(1./side.y);
			side *= min(inv_side.x, inv_side.y);
		}
		ivec2 origin;
		origin.x = side.x > 0. ? 0 : 7;
		origin.y = side.y > 0. ? 0 : 7;
		vec4 _offset = (vec4(0., 2., 4., 6.) + vec4(0.5)) / Ray_Density;
		offset_x = ivec4(side.xxxx * _offset + origin.xxxx);
		offset_y = ivec4(side.yyyy * _offset + origin.yyyy);

		// todo hierarchy対応
		hit_mask = u64vec4(1ul) << (offset_x + offset_y*8);
	}

//	float ray_space_rate = min(inv_dir.x, inv_dir.y);
	float ray_space_rate = 1.;
	vec2 pos = minp + floordir * ray_space_rate * (8./Ray_Density) * gl_LocalInvocationIndex;
	pos += floordir * ray_space_rate * (8./Ray_Density) * (u_gi2d_scene.m_frame %2);
	if(!marchToAABB(pos, dir, vec2(0.), reso.xy)){return;}


	// gpuで事前計算
	uint light_offset = 0;
	uint radiance_offset = reso.x*reso.y;
	int map_offset = 0;
	ivec2 map_reso = reso.zw;
	for(int i = 0; i < hierarchy; i++)
	{
		light_offset += (reso.x>>i)*(reso.y>>i);
		radiance_offset >>= 2;
		map_offset += (reso.z>>i)*(reso.w>>i);
		map_reso >>= 1;
	}
	radiance_offset *= u_gi2d_scene.m_frame;

	// raymarch用事前計算
	ivec2 map_index = ivec2(pos);
	ivec2 cell_origin = (ivec2(greaterThanEqual(dir, vec2(0.)))<<hierarchy);
	ivec2 map_index_sub = map_index - ((map_index>>hierarchy)<<hierarchy);
	vec2 tp = abs(cell_origin - (map_index_sub+fract(pos)));
	tp = tp + (0.5*(1<<hierarchy));
	tp *= inv_dir;
	vec2 delta = abs((1<<hierarchy)*inv_dir);
	ivec2 next = ivec2(greaterThanEqual(dir, vec2(0.))) * 2 - 1;
//	vec3 delta = vec3(abs((1<<hierarchy)*inv_dir), 0.);
//	ivec3 next = ivec3(ivec2(greaterThanEqual(dir, vec2(0.))) * 2 - 1, 0);

	uvec4 u_radiance = uvec4(0);
	u64vec4 d;
	u64vec4 l;
	for(int _i = 0; _i <5000; _i++)
	{
		// march
		{
#if 0
			bool axis = tp.x < tp.y;
			tp += axis ? delta.xz : delta.zy;
			map_index += (axis ? next.xz : next.zy) * (1<<hierarchy);
#else
			int axis = int(tp.x > tp.y);
			tp[axis] += delta[axis];
			int dir = (ivec2(greaterThanEqual(dir, vec2(0.)))[axis] * 2 - 1);
			map_index[axis] += dir * (1<<hierarchy);
#endif
		}
		// 範囲外?
		{
			ivec2 is_die = ivec2(greaterThanEqual(map_index, reso.xy)) + ivec2(lessThan(map_index, ivec2(0.)));
			if(any(notEqual(is_die.xy, ivec2(0))))
			{
				break;
			}
		}

		// hit確認
		{
			ivec2 mi = map_index>>hierarchy;
			ivec2 _fi = mi/8;
			{
				// 更新
				ivec4 offset_ = ivec4(0,0,1,1);
				ivec4 findex = (_fi.xxxx+offset_.xxzz) + (_fi.yyyy+offset_.ywyw)*(map_reso.xxxx) + ivec4(map_offset);
				d = u64vec4(b_diffuse_map[findex.x], b_diffuse_map[findex.y], b_diffuse_map[findex.z], b_diffuse_map[findex.w]);
				l = u64vec4(b_emissive_map[findex.x], b_emissive_map[findex.y], b_emissive_map[findex.z], b_emissive_map[findex.w]);
			}

			ivec2 shift = mi%8;
			uint64_t x_line_mask = 0xfful & ((1ul << (shift.x)) - 1ul);
			uint64_t x_mask = ~(x_line_mask | (x_line_mask << 8) | (x_line_mask << 16) | (x_line_mask << 24) | (x_line_mask << 32) | (x_line_mask << 40) | (x_line_mask << 48) | (x_line_mask << 56));
			uint64_t y_mask = ~(0xfffffffffffffffful & ((1ul << ((shift.y) * 8)) - 1));
			u64vec4 mask = u64vec4(x_mask & y_mask, x_mask & ~y_mask, ~x_mask & y_mask, ~x_mask & ~y_mask);
			ivec4 rs = shift.yyyy*ivec4(8,0,8,0) + shift.xxxx*ivec4(1,1,0,0);
			ivec4 ls = (8-shift.yyyy)*ivec4(0,8,0,8) + (8-shift.xxxx)*ivec4(0,0,1,1);

			u64vec4 _d = d & mask;
			_d >>= rs;
			_d <<= ls;
			u64vec4 _l = l & mask;
			_l >>= rs;
			_l <<= ls;
			uint64_t diffuse_map = _d.x|_d.y|_d.z|_d.w;
			uint64_t emissive_map = _l.x|_l.y|_l.z|_l.w;

			bvec4 is_light = bvec4(notEqual(u64vec4(emissive_map) & hit_mask, u64vec4(0)));

			uvec4 cell_x = (map_index.xxxx+offset_x);
			uvec4 cell_y = (map_index.yyyy+offset_y);
			cell_x >>= hierarchy;
			cell_y >>= hierarchy;
			uvec4 cell = getMemoryOrder4(cell_x,cell_y);
			uvec4 light_cell = uvec4(light_offset)+cell;
#if 0
			u_radiance[0] += is_light[0] ? b_light[light_cell.x] : 0;
			u_radiance[1] += is_light[1] ? b_light[light_cell.y] : 0;
			u_radiance[2] += is_light[2] ? b_light[light_cell.z] : 0;
			u_radiance[3] += is_light[3] ? b_light[light_cell.w] : 0;
#else
			u_radiance[0] += b_light[light_cell.x];
			u_radiance[1] += b_light[light_cell.y];
			u_radiance[2] += b_light[light_cell.z];
			u_radiance[3] += b_light[light_cell.w];
#endif
			uvec4 radiance_cell = uvec4(radiance_offset)+cell;
			u_radiance.x != 0 ? atomicAdd(b_radiance[radiance_cell.x], u_radiance[0]) : 0;
			u_radiance.y != 0 ? atomicAdd(b_radiance[radiance_cell.y], u_radiance[1]) : 0;
			u_radiance.z != 0 ? atomicAdd(b_radiance[radiance_cell.z], u_radiance[2]) : 0;
			u_radiance.w != 0 ? atomicAdd(b_radiance[radiance_cell.w], u_radiance[3]) : 0;

			// 拡散
			bvec4 is_diffuse = bvec4(notEqual(u64vec4(diffuse_map) & hit_mask, u64vec4(0)));
			u_radiance *= uvec4(equal(is_diffuse, bvec4(false)));
		}
	}
}
