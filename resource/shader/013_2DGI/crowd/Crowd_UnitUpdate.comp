#version 460
#extension GL_GOOGLE_include_directive : require

#define USE_Crowd2D 0
#include "GI2D/Crowd.glsl"
#define USE_GI2D 1
#include "GI2D/GI2D.glsl"
#define USE_GI2D_SDF 2
#include "GI2D/GI2DSDF.glsl"
#define USE_GI2D_Path 3
#include "GI2D/GI2DPath.glsl"

float remap(float original_value, float original_min, float original_max, float new_min, float new_max){ return (original_value - original_min) / (original_max - original_min) * (new_max - new_min) + new_min; }

layout (local_size_x = 64) in;

float calcAngle2(in vec2 x, in vec2 y)
{
	return acos(clamp(dot(x, y), -1., 1));
}
vec3 normalize_safe(in vec3 v, in vec3 a){ return dot(v, v) >= 0.001 ? normalize(v) : a;}
vec2 normalize_safe(in vec2 v, in vec2 a){ return dot(v, v) >= 0.001 ? normalize(v) : a;}

float acos_safe(in float a){ return acos(clamp(a, -1., 1.)); }
float atan2(in float y, in float x){ return x==0.0 ? sign(y)*(3.1415/2.) : atan(y, x); }

//int bit_table[] = { 0, 1, 2, 7, 0, 3, 6, 5, 4};
int bit_table_x[] = { 7, 31, 3};
int bit_table_y[] = { 1, 31, 5};

void main()
{
	uint index = gl_GlobalInvocationID.x;
	if(index >= u_crowd_info.unit_data_max)
	{
		return;
	}

	const ivec4 reso = u_gi2d_info.m_resolution;
	float deltatime = u_crowd_scene.m_deltatime;

	vec4 pos = b_unit_pos[index];
	vec2 inertia = b_unit_move[index];
	UnitInfo unit_info = u_unit_info[0];

	inertia = normalize_safe(inertia, vec2(0.)) * max(length(inertia) * pow(0.999, 1.+deltatime), unit_info.linear_speed*0.2);

	vec2 dir = rotate(pos.z);
	{
		// 目的地に向かう
		ivec2 ipos = ivec2(pos.xy);
		uint path_dir = PathData_dirtype(b_path_data[ipos.x+ipos.y*reso.x]);
		vec2 target_dir = normalize(-vec2(g_neighbor[path_dir]));
		float d = dot(dir, target_dir);
		if(d <= 0.95)
		{
			float rotate_angle = acos(d);
			rotate_angle = min(rotate_angle, unit_info.angler_speed);

			float c = cross(vec3(dir, 0.), vec3(target_dir, 0.)).z;
			pos.z += sign(c) * rotate_angle*deltatime;

		}
		else
		{
		}
		inertia += dir * pow(1.01, 1.+deltatime);
		inertia = normalize_safe(inertia, vec2(0.)) * min(length(inertia), unit_info.linear_speed);
	}

	dir = normalize_safe(inertia, vec2(0.));

	if(dot(dir, dir)> 0.001)
	{
		float a = 1./max(abs(dir.x), abs(dir.y));
//		dir *= a;
		float move = length(inertia*deltatime);
		float advance = 0.;

		// march
		while(advance<move)
		{
			vec2 pos_next = pos.xy + dir * clamp(move-advance, 0., a);
			advance += a;

			// hit確認
			ivec2 ipos = ivec2(pos.xy);
			ivec2 ipos_next = ivec2(pos_next);

			ivec4 fragment_index = ivec4(ipos_next/8, ipos_next%8);
			int findex = fragment_index.x + fragment_index.y*reso.z;
			uint64_t fragment_map = b_fragment_map[findex].x;

			ivec2 shift = fragment_index.zw;
			uint64_t bit = 1ul<<(shift.x+shift.y*8);
			if((fragment_map & bit) != 0)
			{
				// 壁にぶつかったので反射
#if 0
				vec2 push_dir = vec2(b_jfa[ipos_next.x + ipos_next.y*reso.x] - ipos_next);
#else
				ivec2 diff = ipos_next-ipos+1;
				int bit = diff.x+diff.y*3;

				uint8_t edge = b_edge[ipos_next.x+ipos_next.y*reso.x];
				bool is_wall_x = (edge&(1<<bit_table_x[diff.x])) != 0;
				bool is_wall_y = (edge&(1<<bit_table_y[diff.y])) != 0;
				vec2 push_dir = normalize_safe(vec2(is_wall_x, is_wall_y), vec2(0.1)) * -sign(dir);
#endif
				inertia = reflect(inertia, push_dir) * 0.3 + normalize(push_dir)*2.;
				dir = reflect(dir, push_dir);

				// 押し出し
				pos.xy += normalize(push_dir);
			}
			else
			{
				// 何もないのでそのまま進む
				pos.xy = pos_next;
			}
		}
	}
	pos.z=mod(pos.z+3.1415, 6.283)-3.1415;
	b_unit_pos[index] = pos;
	b_unit_move[index] = inertia;
}
