#version 460
#extension GL_GOOGLE_include_directive : require

#define USE_Crowd2D 0
#include "GI2D/Crowd.glsl"
#define USE_GI2D 1
#include "GI2D/GI2D.glsl"
#define USE_GI2D_Path 2
#include "GI2D/GI2DPath.glsl"


layout (local_size_x = 64) in;

float calcAngle2(in vec2 x, in vec2 y)
{
	return acos(clamp(dot(x, y), -1., 1));
}

vec3 normalize_safe(in vec3 v, in vec3 a)
{
	return dot(v, v) >= 0.001 ? normalize(v) : a; 
}

float acos_safe(in float a){ return acos(clamp(a, -1., 1.));}


void main()
{
	uint index = gl_GlobalInvocationID.x;
	if(index >= u_crowd_info.unit_data_max)
	{
		return;
	}
	const ivec4 reso = ivec4(u_gi2d_info.m_resolution.xy, u_gi2d_info.m_resolution.xy/8);

	float deltatime = u_crowd_scene.m_deltatime;
	vec4 pos = b_unit_pos[index];
	vec2 rot = b_unit_rot[index];
	CrowdData crowd = b_crowd[0];
	UnitInfo unit_info = u_unit_info[0];
	vec2 pos_old = pos.xy;

	float move = distance(pos.xy, pos.zw)*deltatime + 0.01;
	vec2 dir = rotate(rot.x);

	const int size = g_crowd_density_cell_size;


	{
		// 目的地に向かう
		ivec2 ipos = ivec2(pos.xy);
		uint path_dir = PathData_dirtype(b_path_data[ipos.x+ipos.y*reso.x]);
//		vec2 target_dir = normalize_safe(vec3(crowd.target - pos.xy, 0.), vec3(dir, 0.)).xy;
		vec2 target_dir = normalize(vec2(g_neighbor[7-path_dir]));
		float rotate_rad = dot(dir, target_dir);
		if(rotate_rad <= 0.998)
		{
			float rotate_angle = acos(rotate_rad);
			rotate_angle = min(rotate_angle, unit_info.angler_speed);

			float c = cross(vec3(dir, 0.), vec3(target_dir, 0.)).z;
			rot.x += sign(c) * rotate_angle*deltatime;
			move = clamp(move * pow(0.99, 1.+deltatime), unit_info.linear_speed*0.2, unit_info.linear_speed);
		}
		else
		{
			move = min(move*pow(1.01, 1.+deltatime), unit_info.linear_speed);
		}
	}

	{
	
//		march(unit.m_pos.xz, unit.m_map_index, unit.m_inertia.xz * deltatime);	
//		unit.m_inertia *= pow(0.92, 1. + deltatime);
	}
	{

		// march
		for(int _i = 0; move>0. && _i<2000; _i++)
		{
			ivec2 ipos = ivec2(pos.xy);
			vec2 pos_next = pos.xy + dir * clamp(1., 0., move-1.);
			move = max(move-1., 0.);
			ivec2 ipos_next = ivec2(pos.xy);

			// hit確認
			ivec4 fragment_index = ivec4(ipos_next/8, ipos_next%8);
			int findex = fragment_index.x + fragment_index.y*reso.z;
			uint64_t fragment_map = b_fragment_map[findex].x;

			ivec2 shift = fragment_index.zw;
			uint64_t bit = 1ul<<(shift.x+shift.y*8);
			if((fragment_map & bit) != 0)
			{
				// 壁にぶつかったので反射
//					vec2 next = vec2(ipos_next - ipos);
//					vec2 wall = vec2(pos_next.xy);
				rot.x = mod(3.14+rot.x, 6.28);
				dir = rotate(rot.x);

				// 更新はしない?
				// pos.xy = pos_next;
				// ipos = ipos_next;				

			}
			else
			{
				// 何もないのでそのまま進む
				pos.xy = pos_next;
				ipos = ipos_next;				

			}

		}


	}

	pos.zw = pos_old;
	b_unit_pos[index] = pos;
	b_unit_rot[index] = rot;
}
