#version 450
#extension GL_GOOGLE_include_directive : require

#include "btrlib/ConvertDimension.glsl"
#include "btrlib/Common.glsl"
#include "btrlib/Math.glsl"

#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#define USE_GI2D_SDF 2
#include "GI2D.glsl"
#include "GI2DSDF.glsl"

layout (local_size_x=1024) in;
void main()
{
	if(gl_GlobalInvocationID.x >= b_ray_counter[u_gi2d_scene.m_frame].w){ return; }

	const ivec4 reso = u_gi2d_info.m_resolution;

	D2Segment segment = b_segment[gl_GlobalInvocationID.x];
	D2Ray ray = b_ray[segment.ray_index+u_radiosity_info.ray_frame_max*u_gi2d_scene.m_frame];
	vec2 dir = rotate(ray.angle);

	vec2 origin = ray.origin + dir * segment.begin;
	ivec2 map_index = ivec2(ray.origin + dir * segment.begin);
	uint sdf_offset = reso.x*reso.y;

	uint radiance = 0;

	for(float march_count = 0.; march_count < ray.march; )
	{
		float sdf = b_sdf[map_index.x + map_index.y*reso.x + sdf_offset];

		if(sign(sdf) < 0.)
		{
			radiance += b_light[getMemoryOrder(map_index)];
		}

		// march
		{
			march_count += abs(sdf);
			map_index = ivec2(fma(dir, vec2(march_count), origin));
		}
	}

	if(radiance >= 1)
	{
		b_segment[gl_GlobalInvocationID.x].radiance = radiance;
	}


}
