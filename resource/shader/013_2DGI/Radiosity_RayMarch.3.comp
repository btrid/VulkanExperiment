#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#include "GI2D.glsl"

#define HALF_PI radians(90.)
#define TWO_PI radians(360.)
#define PI radians(180.)
#define QUARTER_PI radians(45.)

layout (local_size_x=128) in;
#define dir_reso_bit (7)
#define dir_reso (128)


bool intersection(in ivec4 aabb, in ivec2 pos, in ivec2 dir, out int n, out int f)
{
	aabb *= dir_reso;
	pos *= dir_reso;

	ivec4 t = (aabb - pos.xyxy)/dir.xyxy;
	t += ivec4(notEqual((aabb - pos.xyxy) % dir.xyxy, ivec4(0)));
	ivec2 tmin = min(t.xy, t.zw);
 	ivec2 tmax = max(t.xy, t.zw);
 
	n = max(tmin.x, tmin.y);
	f = min(tmax.x, tmax.y);

 	return min(tmax.x, tmax.y) > max(max(tmin.x, tmin.y), 0);
}

struct Ray
{
	ivec2 origin;
	ivec2 dir;
	ivec2 inv_dir;
	int begin, end;
	int area;
};

void calcDirEx(in float angle, out ivec2 dir)
{
	vec2 f_dir = vec2(cos(angle), sin(angle));
	f_dir.x = abs(f_dir.x)<GI2D_FLT_EPSILON ? (f_dir.x >= 0. ? 0.0001 : -0.0001) : f_dir.x;
	f_dir.y = abs(f_dir.y)<GI2D_FLT_EPSILON ? (f_dir.y >= 0. ? 0.0001 : -0.0001) : f_dir.y;
	vec2 f_inv_dir = 1./f_dir;
	f_dir = f_dir * min(abs(f_inv_dir.x), abs(f_inv_dir.y));

	dir = abs(ivec2(round(f_dir * dir_reso)));

}
Ray makeRay(in uint x, in uint y)
{
	const ivec4 reso = u_gi2d_info.m_resolution;
	Ray ray;

	float a = PI / Dir_Num;
	float angle = fma(a, float(y), a*0.25);
	ray.area = int(angle / HALF_PI);

	calcDirEx(angle, ray.dir);

	ray.origin.x = 0;
	ray.origin.y = 0;
	if (ray.dir.x>= ray.dir.y)
	{
		ray.origin.y += (reso.y-1) - int(ceil(ray.dir.y / float(ray.dir.x))) * int(x);
	}
	else
	{
		ray.origin.x += (reso.x-1) - int(ceil(ray.dir.x / float(ray.dir.y))) * int(x);
	}

	ivec4 aabb = ivec4(ivec2(0, 0), reso.xy);
	if(!intersection(aabb, ray.origin, ray.dir, ray.begin, ray.end))
	{
		ray.area = -1;
	}
	return ray;
}

void main()
{
	const ivec4 reso = u_gi2d_info.m_resolution;
	uint angle_index = gl_WorkGroupID.y;

	Ray ray = makeRay(gl_GlobalInvocationID.x, gl_WorkGroupID.y);

	if(ray.area<=-1){ return; }

//	ivec2 cell_origin = ivec2(greaterThanEqual(ray.dir, ivec2(0.))) * ivec2(8.);

	int begin = ray.begin;

	for(int march = ray.begin; march < ray.end; )
	{
		ivec2 mi = (march * ray.dir.xy + ray.origin * dir_reso) >> dir_reso_bit;
		if(ray.area==1) mi.x = (reso.x-1)-mi.x;

		ivec2 cell = mi>>3;
		uint64_t map = b_edge[cell.x + cell.y * reso.z];

//		ivec2 pos_sub = ray.origin - (cell << 3);

//		ivec2 tp = abs(cell_origin - pos_sub) * abs(ray.inv_dir.yx) + int(1).xx;
//		int skip = int(min(tp.x, tp.y));

//		if(map == 0ul)
//		{
//			march+=skip;
//			continue;
//		}

		for(;;)
		{
			ivec2 cell_sub = mi%8;
			bool attr = (map & (1ul<<(cell_sub.x+cell_sub.y*8))) != 0ul;
			if(attr)
			{
/*				ivec2 m2 = (begin * ray.dir.xy + ray.origin * dir_reso) >> dir_reso_bit;
				if(ray.area==1) m2.x = (reso.x-1)-m2.x;
				uint vi1 = mi.x + mi.y * reso.x;
				uint vi2 = m2.x + m2.y * reso.x;
				uvec2 array_index = uvec2(b_vertex_array_index[vi1], b_vertex_array_index[vi2]);
				if(array_index.x != -1)
				{
					b_vertex_array[array_index.x].vertex[angle_index] = VertexInfo(u16vec2(m2.xy), array_index.y);
				}

				if(array_index.y != -1)
				{
					b_vertex_array[array_index.y].vertex[angle_index+Dir_Num] = VertexInfo(u16vec2(mi.xy), array_index.x);
				}
*/

				ivec4 end = (ivec4(march.xx, begin.xx) * ray.dir.xyxy + ray.origin.xyxy * dir_reso) >> dir_reso_bit;
				if(ray.area==1) end.xz = (reso.xx-1)-end.xz;

				ivec2 vi = end.xz + end.yw * reso.xx;
				uvec2 array_index = uvec2(b_vertex_array_index[vi.x], b_vertex_array_index[vi.y]);
				if(array_index.x != -1)
				{
					b_vertex_array[array_index.x].vertex[angle_index] = VertexInfo(u16vec2(end.zw), array_index.y);
				}
				if(array_index.y != -1)
				{
					b_vertex_array[array_index.y].vertex[angle_index+Dir_Num] = VertexInfo(u16vec2(end.xy), array_index.x);
				}
				begin = march;
			}
			march++;

			mi = (march * ray.dir.xy + ray.origin * dir_reso) >> dir_reso_bit;
			if(ray.area==1) mi.x = (reso.x-1)-mi.x;
			if(any(notEqual(cell, mi>>3)))
			{
				break;
			}
		}

	}

	ivec4 end = (ivec4((ray.end-1).xx, begin.xx) * ray.dir.xyxy + ray.origin.xyxy * dir_reso) >> dir_reso_bit;
	if(ray.area==1) end.xz = (reso.xx-1)-end.xz;

	ivec2 vi = end.xz + end.yw * reso.xx;
	uvec2 array_index = uvec2(b_vertex_array_index[vi.x], b_vertex_array_index[vi.y]);
//	if(array_index.x != -1)
//	{
//		b_vertex_array[array_index.x].vertex[angle_index] = VertexInfo(u16vec2(end.zw), array_index.y);
//	}
	if(array_index.y != -1)
	{
		b_vertex_array[array_index.y].vertex[angle_index+Dir_Num] = VertexInfo(u16vec2(end.xy), array_index.x);
	}


}
