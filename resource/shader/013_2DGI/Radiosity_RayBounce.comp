#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#include "GI2D.glsl"
#include "Radiosity.glsl"

layout(push_constant) uniform Input
{
	int bounce;
} constant;

layout (local_size_x = 1024, local_size_y = 1) in;
void main()
{
	if(gl_GlobalInvocationID.x >= b_vertex_counter[u_radiosity_info.frame].instanceCount){ return; }
	uint vertex_offset = u_radiosity_info.vertex_max * u_radiosity_info.frame;

	if((b_vertex[vertex_offset+gl_GlobalInvocationID.x].flag & RV_FLAG_IS_BOUNDARY)!= 0)
	{
		return;
	}


	f16vec3 irradiance = f16vec3(0.);

	uvec2 prev = uvec2(-1);
	for(int i = 0; i < Dir_Num; i++)
	{
		VertexInfo v = b_vertex[vertex_offset+gl_GlobalInvocationID.x].vertex[i];

		
		if(v.id.x != gl_GlobalInvocationID.x && v.id.x != prev.x) 
		{
			f16vec3 bounce = b_vertex[vertex_offset+v.id.x].radiance[constant.bounce%2] * b_vertex[vertex_offset+v.id.x].albedo;
			irradiance = bounce * f16vec3(0.15) + irradiance;
		}
		if(v.id.y != gl_GlobalInvocationID.x && v.id.y!=prev.y) 
		{
			f16vec3 bounce = b_vertex[vertex_offset+v.id.y].radiance[constant.bounce%2] * b_vertex[vertex_offset+v.id.y].albedo;
			irradiance = bounce * f16vec3(0.15) + irradiance;
		}
		prev = v.id;
	}

	if(dot(irradiance, f16vec3(1.)) >= 0.02)
		b_vertex[vertex_offset+gl_GlobalInvocationID.x].radiance[(1-(constant.bounce%2))] += irradiance;

}
