#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#include "GI2D.glsl"

layout(push_constant) uniform Input
{
	int bounce;
} constant;

layout (local_size_x = 1024, local_size_y = 1) in;
void main()
{
	if(gl_GlobalInvocationID.x >= b_vertex_array_counter.instanceCount){ return; }

	u16vec2 pos = b_vertex_array[gl_GlobalInvocationID.x].pos;
	uint pos_index = pos.x+pos.y*u_gi2d_info.m_resolution.x;

	f16vec3 irradiance = f16vec3(0.);
	u16vec2 prev = u16vec2(-1);
	for(int i = 0; i < Vertex_Num; i++)
	{
		VertexInfo v = b_vertex_array[gl_GlobalInvocationID.x].vertex[i];
//		if(v.z == 0xffff) { continue; }
//		if(all(equal(v.xy, pos))){ continue;}
//		if(all(equal(v.xy, prev))){ continue;}
//		uint vi = b_vertex_array[gl_GlobalInvocationID.x].vertex_id[i];
//		uint vi = b_vertex_array_index[v.x+v.y*u_gi2d_info.m_resolution.x];

		f16vec3 power = b_vertex_array[v.id].radiance[constant.bounce%2];
		f16vec3 albedo = b_vertex_array[v.id].albedo;
		f16vec3 irra = power * albedo * f16vec3(0.5); 
		irradiance += dot(power, power) >= 0.01 ? irra : f16vec3(0.);
//		vec3 debug = vec3(0.);
//		debug[constant.bounce] = 1.;
//		irradiance += dot(power, power) >= 0.01 ? f16vec3(debug) : f16vec3(0.);

//		prev = v.xy;
	}

	b_vertex_array[gl_GlobalInvocationID.x].radiance[(1-(constant.bounce%2))] += irradiance;

}
