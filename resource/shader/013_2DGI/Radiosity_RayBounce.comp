#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#include "GI2D.glsl"
#include "Radiosity.glsl"

layout(push_constant) uniform Input
{
	int bounce;
} constant;

layout (local_size_x = 1024, local_size_y = 1) in;
void main()
{
	if(gl_GlobalInvocationID.x >= b_vertex_array_counter.instanceCount){ return; }

	if((b_vertex_array[gl_GlobalInvocationID.x].flag & RV_FLAG_IS_BOUNDARY)!= 0)
	{
		return;
	}

	u16vec2 pos = b_vertex_array[gl_GlobalInvocationID.x].pos;
	uint pos_index = pos.x+pos.y*u_gi2d_info.m_resolution.x;

	f16vec3 irradiance = f16vec3(0.);
	u16vec4 prev = u16vec4(-1);
	for(int i = 0; i < Dir_Num; i++)
	{
		VertexInfo v = b_vertex_array[gl_GlobalInvocationID.x].vertex[i];

		f16vec3 bounce1 = (all(equal(v.pos.xy, pos))||all(equal(v.pos.xy, prev.xy))) ? f16vec3(0.) : b_vertex_array[v.id.x].radiance[constant.bounce%2] * b_vertex_array[v.id.x].albedo;
		f16vec3 bounce2 = (all(equal(v.pos.zw, pos))||all(equal(v.pos.zw, prev.zw))) ? f16vec3(0.) : b_vertex_array[v.id.y].radiance[constant.bounce%2] * b_vertex_array[v.id.y].albedo;
		f16vec3 irra = (bounce1 + bounce2) / f16vec3(6.28); 
		irradiance += irra;

		prev = v.pos;
	}

	if(dot(irradiance, f16vec3(1.)) >= 0.02)
		b_vertex_array[gl_GlobalInvocationID.x].radiance[(1-(constant.bounce%2))] += irradiance;

}
