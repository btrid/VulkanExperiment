#version 460
#extension GL_GOOGLE_include_directive : require

#define USE_Rigidbody2D_World 0
#define USE_Rigidbody2D 1
#define USE_GI2D 2
#include "GI2D.glsl"
#include "Rigidbody2D.glsl"


layout (local_size_x = 1024) in;


vec2 calcTangent(in vec2 normal)
{
	vec3 vec = vec3(0.,0.,1.);
	return normalize(cross(vec3(normal, 0.),vec)).xy;
}

void main() 
{
	int p_id = int(gl_GlobalInvocationID.x);
	if(p_id >= b_rigidbody.pnum){ return; }
	if(b_rbParticle[p_id].contact_index == -1){ return; }

	uint ishit = 0;
	{
		vec2 next_pos = b_rbParticle[p_id].pos;
		ivec2 map_index = ivec2(next_pos);

		// hit確認
		uint index = map_index.x + map_index.y * u_gi2d_info.m_resolution.x;
		uint count = min(b_fluid_count[index], FLUID_NUM);
		for(uint ii = 0; ii < count; ii++)
		{
			uint target_id = b_fluid[index*FLUID_NUM + ii].id;
			if( target_id == b_rigidbody.id)
			{
				continue;
			}

			uint iid = target_id / 32;
			uint bit = target_id % 32;

			uint prev = atomicOr(b_contact_bit[iid], 1<<bit);
			if((prev & (1<<bit)) == 0)
			{
				uint contact_index = atomicAdd(b_rigidbody.contact_count, 1);
				if(contact_index < 16)
				{
					b_rigidbody.contact_list[contact_index] = target_id;
				}
			}
			ishit = 1;
		}
	}

	if(ishit != 0)
		atomicMin(b_rigidbody.dist, uint((65535.*255.)));
	b_rbParticle[p_id].is_contact = ishit;
}

