#version 460
#extension GL_GOOGLE_include_directive : require

#define USE_Rigidbody2D_World 0
#define USE_Rigidbody2D 1
#define USE_GI2D 2
#include "GI2D.glsl"
#include "Rigidbody2D.glsl"

layout (local_size_x = 1024) in;

vec2 rotate(in vec2 v, in float angle)
{
	float c = cos(angle);
	float s = sin(angle);

	vec2 Result;
	Result.x = v.x * c - v.y * s;
	Result.y = v.x * s + v.y * c;
	return Result;
}

vec2 calcTangent(in vec2 normal)
{
//	vec3 vec = vec3(0.,0.,1.);
//	return normalize(cross(vec3(normal, 0.),vec)).xy;
	return rotate(normal, radians(90.));
}

vec2 calcNormal(in vec2 pos, in vec2 dir/*, in uint64_t map*/)
{
	ivec4 map_index = ivec4(pos.xyxy) + ivec4(sign(dir.xyxy)) * -ivec4(0, 0, 1, 1);
	ivec4 fragment_index = ivec4(map_index/8);
	ivec4 fragment_index_sub = ivec4(map_index%8);

	u64vec4 map;
	map[0] = b_diffuse_map[getMemoryOrder(fragment_index.xy)];
	map[1] = b_diffuse_map[getMemoryOrder(fragment_index.zy)];
	map[2] = b_diffuse_map[getMemoryOrder(fragment_index.xw)];
	map[3] = 0;

	u64vec4 bit = u64vec4(1ul)<<(fragment_index_sub.xxzz+fragment_index_sub.yyww*8);
	ivec4 iswall = ivec4(notEqual((map & bit), u64vec4(0ul)));
	vec2 n = abs(vec2(iswall[2], iswall[1]))*vec2(sign(-dir.xy));
	n = dot(n , n) == 0. ? -dir : n;
	while(dot(n , n) == 0.);

	return normalize(n);
}

float atan2(in float y, in float x){
    return x == 0.0 ? sign(y)*3.1415/2 : atan(y, x);
}

void main() 
{
	int p_id = int(gl_GlobalInvocationID.x);
	if(p_id >= b_rigidbody.pnum){ return; }
	
	if(b_rbParticle[p_id].contact_index == -1){ return; }

	const ivec4 reso = ivec4(u_gi2d_info.m_resolution.xy, u_gi2d_info.m_resolution.xy/8);

	{ 
//		float step = float(b_rigidbody.dist) / (65535.*255.);

//		vec2 rela_pos = b_relative_pos[p_id];
//		vec2 local_pos = rotateRBParticle(rela_pos, b_rigidbody.angle+b_rigidbody.angle_vel*DT*step);
		vec2 pos = b_rbParticle[p_id].pos;

//		vec2 vel = b_rigidbody.vel*DT;
//		vec2 next_pos = pos + vel*step + local_pos;
		ivec2 map_index = ivec2(pos);

		// hit確認
		{

			uint index = map_index.x + map_index.y * u_gi2d_info.m_resolution.x;
			uint count = min(b_fluid_count[index], FLUID_NUM);
			for(uint ii = 0; ii < count; ii++)
			{
				if( b_fluid[index*FLUID_NUM + ii].id == b_rigidbody.id)
				{
					// 自分とは判定しない
					continue;
				}

				vec2 dir = b_rbParticle[p_id].vel;
				dir -= b_fluid[index*FLUID_NUM + ii].vel;

				float advance = length(dir);
				dir = normalize(dir);

				float spring = 1.15;
				float spring_t = 0.15;
				{
					vec2 restitution = -dir*advance*spring; // 反発力
					vec3 n = vec3(calcNormal(pos, dir), 0.);
					vec2 restitution_t = cross(cross(n, vec3(-dir, 0.)), n).xy * advance * spring_t;
					vec2 delta_linear_vel = restitution + restitution_t;
					float delta_angular_vel = cross(vec3(b_rbParticle[p_id].local_pos, 0.), vec3(delta_linear_vel, 0.)).z;

					int index = atomicAdd(b_rigidbody.solver_count, 1);
					atomicAdd(b_rigidbody.vel_work.x, int(round(delta_linear_vel.x * 65535.)));
					atomicAdd(b_rigidbody.vel_work.y, int(round(delta_linear_vel.y * 65535.)));
					atomicAdd(b_rigidbody.angle_vel_work, int(round(delta_angular_vel * 65535.*255.)));
				}
				b_rbParticle[p_id].is_contact = 2;
				break;
			}
		}
	}
}

