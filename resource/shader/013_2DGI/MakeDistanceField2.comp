#version 450

#extension GL_GOOGLE_cpp_style_line_directive : require
#extension GL_ARB_gpu_shader_int64 : require

#include <btrlib/ConvertDimension.glsl>
#include <btrlib/Common.glsl>
#include <btrlib/Math.glsl>

#define USE_PM 0
#include <PM.glsl>

layout (local_size_x = 32*32, local_size_y = 1) in;

layout(push_constant) uniform Input
{
	int count;
} constant;

void main()
{
	if(gl_GlobalInvocationID.x >= b_sdf_counter[constant.count].w)
	{
		 return;
	}

	const ivec4 reso = ivec4(u_pm_info.m_resolution.xy, u_pm_info.m_resolution.xy/8);
	uint work_index = atomicAdd(b_sdf_work_calced_num, 1);

//	SDFWork work;
	uint map_index_1d = b_sdf_work[work_index].map_index;
	uint hierarchy = b_sdf_work[work_index].hierarchy;
	uint fragment_idx_1d = b_sdf_work[work_index].fragment_idx;

	const ivec2 h_reso = ivec2(u_pm_info.m_resolution.xy >> hierarchy);

	uvec2 map_index = uvec2(map_index_1d % reso.x, map_index_1d / reso.x);
	uvec2 f_idx_2d = uvec2(fragment_idx_1d % h_reso.x, fragment_idx_1d / h_reso.x);

	uint64_t map[4];
	uvec4 fragment_index;
	{
		hierarchy -= 1;

		f_idx_2d <<= f_idx_2d<<1;
		ivec2 f_idx_offset = ivec2(1);

		int offset = getFragmentMapHierarchyOffset(hierarchy);
		ivec4 fragment_index = ivec4(f_idx_2d/8, f_idx_2d%8);
		ivec2 fragment_index_1d = fragment_index.xz + fragment_index.yw*ivec2(reso.z>>hierarchy, 8);
		map[0] = b_fragment_map[fragment_index_1d.x + offset];
		map[1] = b_fragment_map[fragment_index_1d.x+f_idx_offset.x + offset];
		map[2] = b_fragment_map[fragment_index_1d.x+f_idx_offset.y*(reso.z>>hierarchy) + offset];
		map[3] = b_fragment_map[fragment_index_1d.x+f_idx_offset.x+f_idx_offset.y*(reso.z>>hierarchy) + offset];
		fragment_index[0] = fragment_index_1d.x;
		fragment_index[1] = fragment_index_1d.x+f_idx_offset.x;
		fragment_index[2] = fragment_index_1d.x+f_idx_offset.y*(reso.z>>hierarchy);
		fragment_index[3] = fragment_index_1d.x+f_idx_offset.x+f_idx_offset.y*(reso.z>>hierarchy);
	}

	for(int i = 0; i < 4; i++)
	{
		if(map[i] == 0){ continue;}

		SDFWork work;
		work.map_index = map_index_1d;
		work.hierarchy = hierarchy;
		work.fragment_idx = fragment_index[i];

		if(hierarchy == 0)
		{
			int index = atomicAdd(b_sdf_counter[8].x, 1);
			b_sdf_work_top[index] = work;
		}
		else
		{
			int local_index = atomicAdd(b_sdf_counter[constant.count+1].w, 1);
			if(local_index%(32*32) == 0)
			{
				atomicAdd(b_sdf_counter[constant.count+1].x, 1);
			}
			uint index = atomicAdd(b_sdf_work_num, 1);
			b_sdf_work[index] = work;
		}
	}

}

