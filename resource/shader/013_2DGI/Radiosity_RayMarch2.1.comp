#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#include "GI2D.glsl"

#define HALF_PI radians(90.)
#define TWO_PI radians(360.)
#define PI radians(180.)
#define QUARTER_PI radians(45.)

layout (local_size_x=128) in;

bool intersection(in vec4 aabb, in vec2 pos, in vec2 inv_dir, out int n, out int f)
{
	vec4 t = ((aabb - pos.xyxy)*inv_dir.xyxy);
	vec2 tmin = min(t.xy, t.zw);
 	vec2 tmax = max(t.xy, t.zw);
 
	n = int(max(tmin.x, tmin.y));
	f = int(min(tmax.x, tmax.y));

 	return min(tmax.x, tmax.y) > max(max(tmin.x, tmin.y), 0.0);
}

D2Ray makeRay(in uint x, in uint y)
{
	const ivec4 reso = u_gi2d_info.m_resolution;

	float a = TWO_PI / (gl_NumWorkGroups.y);
	float c = (a / gl_NumWorkGroups.z) * (gl_WorkGroupID.z);
	float angle = fma(a, float(y), c);
	
	uint area = uint(angle / HALF_PI);

	vec2 pos;
	pos.x = (area==0) ? (reso.x+0.5) : -0.5;
	pos.y = (area==1) ? (reso.y+0.5) : -0.5;

	vec2 pdir;
	pdir.x = (area%2==1) ? 1 : 0;
	pdir.y = (area%2==0) ? 1 : 0;

	pos += pdir*x;

	angle += QUARTER_PI;
	vec2 dir = calcDir(angle);
	vec2 inv_dir = 1. / dir;
	inv_dir = vec2(isnan(inv_dir)) * 99999999. + inv_dir;

	pos.x += ((area%2)==1&&dir.x>=0.)?-reso.x:0;
	pos.y += ((area%2)==0&&dir.y>=0.)?-reso.y:0;

	int begin, end;
	if(!intersection(vec4(vec2(0., 0.), vec2(reso.xy)), pos, inv_dir, begin, end))
	{
		D2Ray ray;
		ray.origin = vec2(512.);
		angle = 999.;
		ray.march = -1;
		return ray;
	}
	D2Ray ray;
	ray.origin = fma(dir, vec2(begin+1), pos);
	ray.angle = angle;
	ray.march = end - begin+1;

	return ray;
}

void main()
{
	const ivec4 reso = u_gi2d_info.m_resolution;

	int ray_index = int(gl_GlobalInvocationID.x);
	D2Ray ray = makeRay(gl_GlobalInvocationID.x, gl_WorkGroupID.y);

	if(ray.march==-1){ return; }

	uint angle_index =  gl_WorkGroupID.y;
	uint angle_dir = angle_index/((Dir_Num/2)+1);
	if(angle_dir == 0)
	{
		angle_index = angle_index*2;
	}
	else
	{
		angle_index = (angle_index-((Dir_Num/2)+1))*2 + 1;
	}

	vec2 dir = calcDir(ray.angle);
	vec2 inv_dir = abs(1./dir);

	vec2 cell_origin = vec2(greaterThanEqual(dir, vec2(0.))) * vec2(8.);

	int begin = 0;
	int march = 0;


	for(; march < ray.march; )
	{
		vec2 pos = fma(dir, float(march).xx, ray.origin);
		ivec2 map_index = ivec2(pos);
		ivec2 cell = map_index>>3;
		vec2 pos_sub = vec2(pos - vec2(cell << 3));

		vec2 tp = fma(vec2(abs(cell_origin - pos_sub)), inv_dir, float(1.).xx);
		int skip = int(min(tp.x, tp.y));

		uint64_t map = b_edge[cell.x + cell.y * reso.z];
		if(map == 0ul)
		{
			march+=skip;
			continue;
		}

		for(uint i = 0; i < skip; i++)
		{
			ivec2 cell_sub = ivec2(pos_sub);
			bool attr = (map & (1ul<<(cell_sub.x+cell_sub.y*8))) != 0ul;
			if(attr)
			{
				u16vec4 end = u16vec4(fma(dir.xyxy, vec4(float(begin).xx, float(march).xx), ray.origin.xyxy));
				uvec2 index = end.xz + end.yw * reso.xx;
				if(all(notEqual(end.xyxy, uvec4(0, 0, reso.xy-1))))
				{
					b_vertex_array[b_vertex_array_index[index.x]].vertex[(angle_index + (1-angle_dir)*Dir_Num)%Vertex_Num] = end.zw;
				}
				if(all(notEqual(end.zwzw, uvec4(0, 0, reso.xy-1))))
				{
					b_vertex_array[b_vertex_array_index[index.y]].vertex[(angle_index + angle_dir*Dir_Num)%Vertex_Num] = end.xy;
				}
				begin = march;
			}
			march++;
			pos_sub = fma(dir, vec2(1.), pos_sub);
		}

	}
	u16vec4 end = u16vec4(fma(dir.xyxy, vec4(float(begin).xx, float(ray.march).xx), ray.origin.xyxy));
	uvec2 index = end.xz + end.yw * reso.xx;
	if(all(notEqual(end.xyxy, uvec4(0, 0, reso.xy-1))))
	{
		b_vertex_array[b_vertex_array_index[index.x]].vertex[(angle_index + (1-angle_dir)*Dir_Num)%Vertex_Num] = end.zw;
	}
}
