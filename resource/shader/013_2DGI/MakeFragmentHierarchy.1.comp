#version 450

#extension GL_GOOGLE_cpp_style_line_directive : require
#extension GL_ARB_gpu_shader_int64 : require

#include <btrlib/ConvertDimension.glsl>
#include <btrlib/Common.glsl>
#include <btrlib/Math.glsl>

#define USE_OIT 0
#include <OIT.glsl>

#define hierarchy_size (8)
layout (local_size_x = hierarchy_size, local_size_y = hierarchy_size) in;

//shared uint64_t s_bit;
shared uint s_bit[2];
void main()
{

	if(gl_LocalInvocationIndex <= 1)
	{
		s_bit[gl_LocalInvocationIndex] = 0;
	}
	barrier();
	memoryBarrierShared();

//	uint tile_id = gl_WorkGroupID.x + gl_WorkGroupID.y*gl_NumWorkGroups.x;
	uvec2 tile_index0_2d = uvec2(gl_WorkGroupID.x*hierarchy_size, gl_WorkGroupID.y*hierarchy_size);
	uvec2 tile_index1_2d = uvec2(gl_LocalInvocationID.x, gl_LocalInvocationID.y*hierarchy_size);
	uvec2 tile_index_2d = tile_index0_2d+tile_index1_2d;
	uint tiled_1D_index = tile_index_2d.x + tile_index_2d.y*u_OIT_info.m_resolution.x; 
	vec3 albedo = b_fragment[tiled_1D_index].albedo;
	if(dot(albedo, albedo) >= 0.001)
	{
		uint bit_offset = gl_LocalInvocationID.x + gl_LocalInvocationID.y*hierarchy_size;
		uint hilow = bit_offset/32;
		uint offset = bit_offset%32;
		atomicOr(s_bit[hilow], 1<<offset);
	}
	barrier();
	memoryBarrierShared();

	if(gl_LocalInvocationIndex == 0)
	{
		uint64_t bit =  uint64_t(s_bit[1]) << 32 | s_bit[0];
		uint l1_index_1d = gl_WorkGroupID.x + gl_WorkGroupID.y*(u_OIT_info.m_resolution.x/hierarchy_size);
		b_fragment_hierarchy[l1_index_1d] = bit;
	}
}

