#version 450

#extension GL_GOOGLE_cpp_style_line_directive : require
#extension GL_ARB_gpu_shader_int64 : require

#include <btrlib/ConvertDimension.glsl>
#include <btrlib/Common.glsl>
#include <btrlib/Math.glsl>

#define USE_OIT 0
#include <OIT.glsl>

layout (local_size_x = 32, local_size_y = 1) in;

shared uint s_counter;
shared vec4 s_area;
void main()
{

	uvec3 index = uvec3(gl_WorkGroupID.xy, 1);
	uint tiled_1D_index = gl_WorkGroupID.x+ gl_WorkGroupID.y*gl_NumWorkGroups.x; 

	TileInfo tile_info = u_tile_info;
	if(any(greaterThanEqual(index.xy, tile_info.m_tile_num))) { return; }

	if(gl_LocalInvocationID.x == 0)
	{
		s_counter = 0;

		vec2 left_top = vec2(0., 0.);
		vec2 right_bottom = vec2(640., 640.);
		vec2 tile_size = (right_bottom - left_top) /vec2(gl_NumWorkGroups.x);
		s_area.xy = left_top + tile_size*index.xy;
		s_area.zw = s_area.xy + tile_size;
	}
	barrier();
	memoryBarrierShared();

	uint data_num = b_emissive_counter.x;
	uint count_list_offset = tiled_1D_index*u_OIT_info.m_emissive_tile_map_max;
	uint loop_count = (data_num-1) / gl_NumWorkGroups.x + 1;
	uint loop_begin = gl_LocalInvocationID.x*loop_count;
	uint loop_end = loop_begin + loop_count;
	for(uint i = loop_begin; i < loop_end; i++)
	{
		if(i >= data_num){
			break;
		}
		if(!isInAABB2D(f, s_area)) 
		{
			continue;
		}
		uint tile_list_index = atomicAdd(s_counter, 1);
		if(tile_list_index < u_OIT_info.m_emissive_tile_map_max){
			b_emissive_tile_map[count_list_offset+tile_list_index] = i;
		}
	}

	barrier();
	memoryBarrierShared();
	if(gl_LocalInvocationID.x == 0)
	{
		b_emissive_tile_counter[tiled_1D_index] = min(s_counter, u_OIT_info.m_emissive_tile_map_max);
	}
}

