#version 450
#extension GL_GOOGLE_include_directive : require

#include "btrlib/ConvertDimension.glsl"
#include "btrlib/Common.glsl"
#include "btrlib/Math.glsl"

#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#include "GI2D.glsl"

layout (local_size_x = 32, local_size_y = 32) in;

layout(push_constant) uniform Input
{
	int distance;
} constant;

shared D2JFACell s_cell[(32+2)*(32+2)];

void nearest(inout D2JFACell new_cell, in ivec4 reso, in vec2 current, in ivec2 target)
{
	ivec2 target_index = ivec2(gl_LocalInvocationID.xy) + ivec2(1, 1) + target;
	D2JFACell target_cell = s_cell[target_index.x + target_index.y * 34];
	float d = distance(vec2(target_cell.nearest_index), vec2(current));
	if(target_cell.nearest_index.x >= 0 && d < new_cell.distance)
	{
		new_cell.distance = d;
		new_cell.nearest_index = target_cell.nearest_index;
	}

	d = distance(vec2(target_cell.e_nearest_index), vec2(current));
	if(target_cell.e_nearest_index.x >= 0 && d < new_cell.e_distance)
	{
		new_cell.e_distance = d;
		new_cell.e_nearest_index = target_cell.e_nearest_index;
	}

}
void main() 
{
	const ivec4 reso = ivec4(u_gi2d_info.m_resolution.xy, u_gi2d_info.m_resolution.xy/8);
	ivec2 current = ivec2(gl_GlobalInvocationID.xy) + ivec2(constant.distance) * ivec2(gl_WorkGroupID.xy);
	ivec2 sub = current / reso.xy;
	current = current % reso.xy + sub;

	D2JFACell current_cell = b_jfa[current.x + current.y*reso.x];
	D2JFACell new_cell = current_cell;
	D2JFACell invalid_cell;
	invalid_cell.nearest_index.x = -1;
	invalid_cell.e_nearest_index.x = -1;
	s_cell[(gl_LocalInvocationID.x+1)*(gl_LocalInvocationID.y+1)*34] = current_cell;

	// 辺
	if(gl_LocalInvocationID.x == 0)
	{
		ivec2 target = current + ivec2(-constant.distance, 0.);
		s_cell[(gl_LocalInvocationID.y+1)*34] = target.x >= 0 ? b_jfa[target.x + target.y*reso.x] : invalid_cell;
	}
	if(gl_LocalInvocationID.x == 31)
	{
		ivec2 target = current + ivec2(constant.distance, 0.);
		s_cell[33 + (gl_LocalInvocationID.y+1)*34] = target.x < reso.x ? b_jfa[target.x + target.y*reso.x] : invalid_cell;
	}
	if(gl_LocalInvocationID.y == 0)
	{
		ivec2 target = current + ivec2(0., -constant.distance);
		s_cell[gl_LocalInvocationID.x+1] = target.y >= 0 ? b_jfa[target.x + target.y*reso.x] : invalid_cell;
	}
	if(gl_LocalInvocationID.y == 31)
	{
		ivec2 target = current + ivec2(0., constant.distance);
		s_cell[gl_LocalInvocationID.x+1 + (gl_LocalInvocationID.y+1)*34] = target.y < reso.y ? b_jfa[target.x + target.y*reso.x] : invalid_cell;
	}

	// 角
	if(gl_LocalInvocationID.x == 0 && gl_LocalInvocationID.y == 0)
	{
		ivec2 target = current + ivec2(-constant.distance, -constant.distance);
		s_cell[0] = target.x >= 0 && target.y >= 0 ? b_jfa[target.x + target.y*reso.x] : invalid_cell;
	}
	if(gl_LocalInvocationID.x == 31 && gl_LocalInvocationID.y == 0)
	{
		ivec2 target = current + ivec2(constant.distance, -constant.distance);
		s_cell[33 + (gl_LocalInvocationID.y+1)*34] = target.x < reso.x && target.y >= 0 ? b_jfa[target.x + target.y*reso.x] : invalid_cell;
	}
	if(gl_LocalInvocationID.x == 0 && gl_LocalInvocationID.y == 31)
	{
		ivec2 target = current + ivec2(-constant.distance, constant.distance);
		s_cell[(gl_LocalInvocationID.y+2)*34] = target.x >= 0 && target.y < reso.y ? b_jfa[target.x + target.y*reso.x] : invalid_cell;
	}
	if(gl_LocalInvocationID.x == 31 && gl_LocalInvocationID.y == 31)
	{
		ivec2 target = current + ivec2(0., constant.distance);
		s_cell[(gl_LocalInvocationID.x+2) + (gl_LocalInvocationID.y+2)*34] = target.x < reso.x && target.y < reso.y ? b_jfa[target.x + target.y*reso.x] : invalid_cell;
	}

	barrier();
	memoryBarrierShared();

	nearest(new_cell, reso, current, ivec2(-1, -1));
	nearest(new_cell, reso, current, ivec2( 0, -1));
	nearest(new_cell, reso, current, ivec2( 1, -1));
	nearest(new_cell, reso, current, ivec2(-1,  0));
	//nearest(new_cell, reso, current, ivec2(0, 0));
	nearest(new_cell, reso, current, ivec2( 1, 0));
	nearest(new_cell, reso, current, ivec2(-1, 1));
	nearest(new_cell, reso, current, ivec2( 0, 1));
	nearest(new_cell, reso, current, ivec2( 1, 1));

	if(new_cell.distance < current_cell.distance || new_cell.e_distance < current_cell.e_distance)
	{
		b_jfa[current.x + current.y*reso.x] = new_cell;
	}
}
