#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Radiosity2 1
#include "GI2D.glsl"
#include "Radiosity2.glsl"

layout(push_constant) uniform Input
{
	int bounce;
} constant;

layout (local_size_x = 1024, local_size_y = 1) in;
void main()
{
	if(gl_GlobalInvocationID.x >= b_segment_counter.instanceCount){ return; }

	u16vec4 pos = b_segment[gl_GlobalInvocationID.x].pos;
	uvec2 index = pos.xz + pos.yw * u_gi2d_info.m_resolution.xx;

	uint64_t radiance = b_radiance[index.x *2 + constant.bounce];
	if(radiance != 0u)
	{
		dvec3 rad_d3 = dvec3(radiance&ColorMask, (radiance>>21)&ColorMask, (radiance>>42ul)&ColorMask);
		vec3 rad = vec3(rad_d3 / dvec3(1024.));
		rad = rad * vec3(getRGB(b_fragment[index.x])) * vec3(0.14);

		u64vec3 emissive_u3 = u64vec3(round(rad * vec3(1024.)));
		uint64_t packed = emissive_u3.x + (emissive_u3.y<<21ul) + (emissive_u3.z<<42ul);
		if(packed != 0)
			atomicAdd(b_radiance[index.y *2 + (1-constant.bounce)], packed);
	}

	radiance = b_radiance[index.y *2 + constant.bounce];
	if(radiance != 0u)
	{
		dvec3 rad_d3 = dvec3(radiance&ColorMask, (radiance>>21)&ColorMask, (radiance>>42ul)&ColorMask);
		vec3 rad = vec3(rad_d3 / dvec3(1024.));
		rad = rad * vec3(getRGB(b_fragment[index.y])) * vec3(0.14);

		u64vec3 emissive_u3 = u64vec3(round(rad * vec3(1024.)));
		uint64_t packed = emissive_u3.x + (emissive_u3.y<<21ul) + (emissive_u3.z<<42ul);
		if(packed != 0)
			atomicAdd(b_radiance[index.x *2 + (1-constant.bounce)], packed);
	}

}
