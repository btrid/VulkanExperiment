#version 450
#extension GL_GOOGLE_include_directive : require

#include "btrlib/ConvertDimension.glsl"
#include "btrlib/Common.glsl"
#include "btrlib/Math.glsl"

#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#include "GI2D.glsl"

vec2 intersectRayRay(in vec2 as, in vec2 ad, in vec2 bs, in vec2 bd)
{
	float u = (as.y*bd.x + bd.y*bs.x - bs.y*bd.x - bd.y*as.x) / (ad.x*bd.y - ad.y*bd.x);
	return as + u * ad;
}

bool marchToAABB(inout vec2 p, in vec2 d, in vec2 bmin, in vec2 bmax)
{

	if(all(lessThan(p, bmax)) 
	&& all(greaterThan(p, bmin)))
	{
		// AABBの中にいる
		return true;
	}

	float tmin = 0.;
	float tmax = 10e6;
	for (int i = 0; i < 2; i++)
	{
		if (abs(d[i]) < 10e-6)
		{
			// 光線はスラブに対して平行。原点がスラブの中になければ交点無し。
			if (p[i] < bmin[i] || p[i] > bmax[i])
			{
				return false;
			}
		}
		else
		{
			float ood = 1. / d[i];
			float t1 = (bmin[i] - p[i]) * ood;
			float t2 = (bmax[i] - p[i]) * ood;

			// t1が近い平面との交差、t2が遠い平面との交差になる
			float near = min(t1, t2);
			float far = max(t1, t2);

			// スラブの交差している感覚との交差を計算
			tmin = max(near, tmin);
			tmax = max(far, tmax);

			if (tmin > tmax) {
				return false;
			}
		}
	}
	float dist = tmin;
	p += d*dist;
	return true;

}

layout (local_size_x = 128, local_size_y = 1) in;
void main()
{
	const ivec4 reso = ivec4(u_gi2d_info.m_resolution.xy, u_gi2d_info.m_resolution.xy/8);

	vec2 dir = rotate(gl_GlobalInvocationID.y*6.28 / gl_NumWorkGroups.y + 3.14);
	dir.x = abs(dir.x) < 0.0001 ? 0.0001 : dir.x;
	dir.y = abs(dir.y) < 0.0001 ? 0.0001 : dir.y;
	vec2 inv_dir = abs(1./dir);

	vec2 floorp;
	floorp.x = dir.x >= 0 ? 0. : reso.x;
	floorp.y = dir.y >= 0 ? 0. : reso.y;
	vec2 floordir;
	floordir.x = abs(dir.x) > abs(dir.y) ? 0. : 1.;
	floordir.y = abs(dir.x) > abs(dir.y) ? 1. : 0.;

	vec2 p0 = intersectRayRay(vec2(0, 0), dir, floorp, floordir);
	vec2 p1 = intersectRayRay(vec2(reso.x, 0), dir, floorp, floordir);
	vec2 p2 = intersectRayRay(vec2(0, reso.y), dir, floorp, floordir);
	vec2 p3 = intersectRayRay(vec2(reso.x, reso.y), dir, floorp, floordir);

	vec2 minp = min(min(min(p0, p1), p2), p3);
	vec2 maxp = max(max(max(p0, p1), p2), p3);

	vec2 pos = minp + floordir * 8. * gl_LocalInvocationIndex;
	if(!marchToAABB(pos, dir, vec2(0.), reso.xy)){return;}
//	pos += dir * 0.5;

	vec2 side = rotateZ(dir, 3.14*0.5);
	{
		side.x = abs(side.x) < 0.0001 ? 0.0001 : side.x;
		side.y = abs(side.y) < 0.0001 ? 0.0001 : side.y;
		vec2 invside = abs(1. / side);
		side *= min(invside.x, invside.y);
	}
	u64vec4 hit_mask;
	{
		ivec2 origin;
		origin.x = side.x > 0. ? 0 : 7;
		origin.y = side.y > 0. ? 0 : 7;
		ivec4 mask_x = ivec4(side.xxxx * vec4(0.5, 2.5, 4.5, 6.5) + origin.xxxx);
		ivec4 mask_y = ivec4(side.yyyy * vec4(0.5, 2.5, 4.5, 6.5) + origin.yyyy);
		hit_mask = u64vec4(1ul) << (mask_x + mask_y*8);
	}

	ivec2 map_index = ivec2(pos);

	const ivec2 map_index_origin = ivec2(greaterThanEqual(dir, vec2(0.)));

	vec4 radiance = vec4(0.);
	for(int _i = 0; _i <50000; _i++)
	{
		// march
		{
			vec2 cell_p = abs(map_index_origin - fract(pos)) + 0.5;
			vec2 axis = abs(cell_p*inv_dir);
			pos += min(axis.x, axis.y)*dir;
			map_index = ivec2(pos);
			radiance *= 0.98;
		}

		// 範囲外?
		{
			ivec2 is_die = ivec2(greaterThanEqual(map_index, reso.xy)) + ivec2(lessThan(map_index, ivec2(0)));
			if(any(notEqual(is_die.xy, ivec2(0))))
			{
				break;
			}
		}

		// hit確認
		{
			ivec4 fragment_index = ivec4(map_index/8, map_index%8);
			ivec2 shift = fragment_index.zw;

			ivec4 offset_ = ivec4(0,0,1,1);
			ivec4 findex = fragment_index.xxxx + offset_.xxzz + (fragment_index.yyyy + offset_.ywyw)*(reso.zzzz);

			uint64_t fragment_map;
			uint64_t light_map;
			{
				uint64_t x_line_mask = 0xfful & ((1ul << (shift.x)) - 1ul);
				uint64_t x_mask = ~(x_line_mask | (x_line_mask << 8) | (x_line_mask << 16) | (x_line_mask << 24) | (x_line_mask << 32) | (x_line_mask << 40) | (x_line_mask << 48) | (x_line_mask << 56));
				uint64_t y_mask = ~(0xfffffffffffffffful & ((1ul << ((shift.y) * 8)) - 1));
				u64vec4 mask = u64vec4(x_mask & y_mask, x_mask & ~y_mask, ~x_mask & y_mask, ~x_mask & ~y_mask);
				ivec4 rs = shift.yyyy*ivec4(8,0,8,0) + shift.xxxx*ivec4(1,1,0,0);
				ivec4 ls = (8-shift.yyyy)*ivec4(0,8,0,8) + (8-shift.xxxx)*ivec4(0,0,1,1);

				u64vec4 b = u64vec4(b_fragment_map[findex.x], b_fragment_map[findex.y], b_fragment_map[findex.z], b_fragment_map[findex.w]);
				b &= mask;
				b >>= rs;
				b <<= ls;
				fragment_map = b.x|b.y|b.z|b.w;

				u64vec4 l = u64vec4(b_light_map[findex.x], b_light_map[findex.y], b_light_map[findex.z], b_light_map[findex.w]);
				l &= mask;
				l >>= rs;
				l <<= ls;
				light_map = l.x|l.y|l.z|l.w;

				vec4 rad = vec4(notEqual(u64vec4(light_map) & hit_mask, u64vec4(0)));
				radiance += rad;
				vec4 diffuse = vec4(equal(u64vec4(fragment_map) & hit_mask, u64vec4(0)));
				radiance *= diffuse;
			}

			uvec4 cell = (map_index.xxxx+uvec4(0,2,4,6)) + map_index.yyyy * reso.x;
//			atomicAdd(b_radiance_map[cell.x], 1.);
//			atomicAdd(b_radiance_map[cell.y], radiance.y);
//			atomicAdd(b_radiance_map[cell.z], radiance.z);
//			atomicAdd(b_radiance_map[cell.w], radiance.w);
			b_radiance_map[cell.x] += radiance.x;
			b_radiance_map[cell.y] += radiance.y;
			b_radiance_map[cell.z] += radiance.z;
			b_radiance_map[cell.w] += radiance.w;
		}

	}

}
