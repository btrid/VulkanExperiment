#version 450
#extension GL_GOOGLE_include_directive : require

#include "btrlib/ConvertDimension.glsl"
#include "btrlib/Common.glsl"
#include "btrlib/Math.glsl"

#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#include "GI2D.glsl"


vec2 intersectRayRay(in vec2 as, in vec2 ad, in vec2 bs, in vec2 bd)
{
	float u = (as.y*bd.x + bd.y*bs.x - bs.y*bd.x - bd.y*as.x) / (ad.x*bd.y - ad.y*bd.x);
	return as + u * ad;
}

bool marchToAABB(inout vec2 p, in vec2 d, in vec2 bmin, in vec2 bmax)
{

	if(all(lessThan(p, bmax)) 
	&& all(greaterThan(p, bmin)))
	{
		// AABBの中にいる
		return true;
	}

	float tmin = 0.;
	float tmax = 10e6;
	for (int i = 0; i < 2; i++)
	{
		if (abs(d[i]) < 10e-6)
		{
			// 光線はスラブに対して平行。原点がスラブの中になければ交点無し。
			if (p[i] < bmin[i] || p[i] > bmax[i])
			{
				return false;
			}
		}
		else
		{
			float ood = 1. / d[i];
			float t1 = (bmin[i] - p[i]) * ood;
			float t2 = (bmax[i] - p[i]) * ood;

			// t1が近い平面との交差、t2が遠い平面との交差になる
			float near = min(t1, t2);
			float far = max(t1, t2);

			// スラブの交差している感覚との交差を計算
			tmin = max(near, tmin);
			tmax = max(far, tmax);

			if (tmin > tmax) {
				return false;
			}
		}
	}
	float dist = tmin;
	p += d*dist;
	return true;

}


#define Density (1)
#define Advance (1.)
#define Use_Color
layout (local_size_x = 128*Density, local_size_y = 1) in;
void main()
{
	const ivec4 reso = ivec4(u_gi2d_info.m_resolution.xy, u_gi2d_info.m_resolution.xy/8);

	float angle = 6.28 / gl_NumWorkGroups.y;
	angle += angle * (gl_GlobalInvocationID.z / gl_NumWorkGroups.z);
	vec2 dir = rotate(angle * gl_GlobalInvocationID.y);
	dir.x = abs(dir.x) < 0.0001 ? 0.0001 : dir.x;
	dir.y = abs(dir.y) < 0.0001 ? 0.0001 : dir.y;
	vec2 inv_dir = abs(1./dir);
	dir *= min(inv_dir.x, inv_dir.y);

	vec2 floorp;
	floorp.x = dir.x >= 0 ? 0. : reso.x;
	floorp.y = dir.y >= 0 ? 0. : reso.y;
	vec2 floordir;
	floordir.x = abs(dir.x) > abs(dir.y) ? 0. : 1.;
	floordir.y = abs(dir.x) > abs(dir.y) ? 1. : 0.;

	vec2 p0 = intersectRayRay(vec2(0, 0), dir, floorp, floordir);
	vec2 p1 = intersectRayRay(vec2(reso.x, 0), dir, floorp, floordir);
	vec2 p2 = intersectRayRay(vec2(0, reso.y), dir, floorp, floordir);
	vec2 p3 = intersectRayRay(vec2(reso.x, reso.y), dir, floorp, floordir);

	vec2 minp = min(min(min(p0, p1), p2), p3);
	vec2 maxp = max(max(max(p0, p1), p2), p3);

	vec2 pos = minp + floordir * (8./Density) * gl_LocalInvocationIndex;
	pos += floordir * (8./Density) * (gl_GlobalInvocationID.z / gl_NumWorkGroups.z);
	if(!marchToAABB(pos, dir, vec2(0.), reso.xy)){return;}

	vec2 side = rotateZ(dir, 3.14*0.5);
	{
		side.x = abs(side.x) < 0.0001 ? 0.0001 : side.x;
		side.y = abs(side.y) < 0.0001 ? 0.0001 : side.y;
		vec2 invside = abs(1. / side);
		side *= min(invside.x, invside.y);
	}
//	pos += dir * (gl_GlobalInvocationID.y%3) + side *0.4* (gl_GlobalInvocationID.y%5);

	u64vec4 hit_mask;
	ivec4 offset_x;
	ivec4 offset_y;
	{
		uint offset = gl_GlobalInvocationID.y % 4;
//		uint offset_x_ = offset % 2;
//		uint offset_y_ = offset / 2;
		uint offset_x_ = 0;
		uint offset_y_ = 0;
		ivec2 origin;
		origin.x = side.x > 0. ? 0 : 7;
		origin.y = side.y > 0. ? 0 : 7;
		vec4 _offset = vec4(0., 2., 4., 6.) / Density + vec4(0.5);
		offset_x = ivec4(side.xxxx * (vec4(offset_x_)+_offset) + origin.xxxx);
		offset_y = ivec4(side.yyyy * (vec4(offset_y_)+_offset) + origin.yyyy);
		hit_mask = u64vec4(1ul) << (offset_x + offset_y*8);
	}

	ivec2 map_index = ivec2(pos);

	const ivec2 map_index_origin = ivec2(greaterThanEqual(dir, vec2(0.)));

	vec3 radiance[4] = {vec3(0.),vec3(0.),vec3(0.),vec3(0.)};
	for(int _i = 0; _i <50000; _i++)
	{
		// march
		{
#if 0
			vec2 cell_p = abs(map_index_origin - fract(pos)) + 0.5;
			vec2 axis = abs(cell_p*inv_dir);
			pos += min(axis.x, axis.y)*dir;
#else
			pos += dir*Advance;
			radiance[0] *= pow(0.98, Advance);
			radiance[1] *= pow(0.98, Advance);
			radiance[2] *= pow(0.98, Advance);
			radiance[3] *= pow(0.98, Advance);

#endif
			map_index = ivec2(pos);
		}

		// 範囲外?
		{
			ivec2 is_die = ivec2(greaterThanEqual(map_index, reso.xy)) + ivec2(lessThan(map_index, ivec2(0)));
			if(any(notEqual(is_die.xy, ivec2(0))))
			{
				break;
			}
		}

		// hit確認
		{
			ivec4 fragment_index = ivec4(map_index/8, map_index%8);
			ivec2 shift = fragment_index.zw;

			ivec4 offset_ = ivec4(0,0,1,1);
			ivec4 findex = fragment_index.xxxx + offset_.xxzz + (fragment_index.yyyy + offset_.ywyw)*(reso.zzzz);

			uint64_t fragment_map;
			uint64_t light_map;
			{
				uint64_t x_line_mask = 0xfful & ((1ul << (shift.x)) - 1ul);
				uint64_t x_mask = ~(x_line_mask | (x_line_mask << 8) | (x_line_mask << 16) | (x_line_mask << 24) | (x_line_mask << 32) | (x_line_mask << 40) | (x_line_mask << 48) | (x_line_mask << 56));
				uint64_t y_mask = ~(0xfffffffffffffffful & ((1ul << ((shift.y) * 8)) - 1));
				u64vec4 mask = u64vec4(x_mask & y_mask, x_mask & ~y_mask, ~x_mask & y_mask, ~x_mask & ~y_mask);
				ivec4 rs = shift.yyyy*ivec4(8,0,8,0) + shift.xxxx*ivec4(1,1,0,0);
				ivec4 ls = (8-shift.yyyy)*ivec4(0,8,0,8) + (8-shift.xxxx)*ivec4(0,0,1,1);

				u64vec4 b = u64vec4(b_fragment_map[findex.x], b_fragment_map[findex.y], b_fragment_map[findex.z], b_fragment_map[findex.w]);
				b &= mask;
				b >>= rs;
				b <<= ls;
				fragment_map = b.x|b.y|b.z|b.w;

				u64vec4 l = u64vec4(b_light_map[findex.x], b_light_map[findex.y], b_light_map[findex.z], b_light_map[findex.w]);
				l &= mask;
				l >>= rs;
				l <<= ls;
				light_map = l.x|l.y|l.z|l.w;

				vec4 rad = vec4(notEqual(u64vec4(light_map) & hit_mask, u64vec4(0)));
#if defined(Use_Color)
				ivec4 li = (map_index.xxxx + offset_x) + (map_index.yyyy + offset_y) * reso.x;
				radiance[0] += rad[0]*b_fragment[li.x].albedo.xyz;
				radiance[1] += rad[1]*b_fragment[li.y].albedo.xyz;
				radiance[2] += rad[2]*b_fragment[li.z].albedo.xyz;
				radiance[3] += rad[3]*b_fragment[li.w].albedo.xyz;
#else
				radiance[0] += rad[0];
				radiance[1] += rad[1];
				radiance[2] += rad[2];
				radiance[3] += rad[3];
#endif
				vec4 diffuse = vec4(equal(u64vec4(fragment_map) & hit_mask, u64vec4(0)));
				radiance[0] *= diffuse[0];
				radiance[1] *= diffuse[1];
				radiance[2] *= diffuse[2];
				radiance[3] *= diffuse[3];
			}

			uvec4 cell_x = (map_index.xxxx+offset_x);
			uvec4 cell_y = (map_index.yyyy+offset_y);
			uvec4 u_radiance;
			u_radiance.x = packEmissive(radiance[0]);
			u_radiance.y = packEmissive(radiance[1]);
			u_radiance.z = packEmissive(radiance[2]);
			u_radiance.w = packEmissive(radiance[3]);

			u_radiance.x != 0 ? atomicAdd(b_radiance_map[getMemoryOrder(ivec2(cell_x.x, cell_y.x))], u_radiance.x) : 0;
			u_radiance.y != 0 ? atomicAdd(b_radiance_map[getMemoryOrder(ivec2(cell_x.y, cell_y.y))], u_radiance.y) : 0;
			u_radiance.z != 0 ? atomicAdd(b_radiance_map[getMemoryOrder(ivec2(cell_x.z, cell_y.z))], u_radiance.z) : 0;
			u_radiance.w != 0 ? atomicAdd(b_radiance_map[getMemoryOrder(ivec2(cell_x.w, cell_y.w))], u_radiance.w) : 0;
		}

	}

}
