#version 460
#extension GL_GOOGLE_include_directive : require

#define USE_Rigidbody2D 0
#define USE_GI2D 1
#include "GI2D.glsl"
#include "Rigidbody2D.glsl"

layout (local_size_x = RB_PARTICLE_BLOCK_SIZE) in;

#define FLT_EPSIRON (1.19209290e-07)
//#define isZero(_v) (all(lessThan((_v), vec2(FLT_EPSIRON))))
#define isZero(_v) (dot((_v), (_v)) < FLT_EPSIRON)

vec2 calcTangent(in vec2 I, in vec2 N)
{
	return I - N * dot(N, I);
}

vec2 normalize_safe(in vec2 v)
{
	return isZero(v) ? vec2(0.) : normalize(v);
}
float length_safe(in vec2 v)
{
	return isZero(v) ? 0. : length(v);
}
void main() 
{
	uint pb_id = b_pb_update_list[b_world.cpu_index*b_manager.pb_list_size+gl_WorkGroupID.x];
	uint p_id = pb_id*RB_PARTICLE_BLOCK_SIZE + gl_LocalInvocationID.x;
	if(b_rbParticle[p_id].contact_index == -1){ return; }

	uint r_id = b_rbParticle_map[pb_id];
	vec2 pos = b_rbParticle[p_id].pos;
	vec2 pos_old = b_rbParticle[p_id].pos_old;
	vec2 sdf = b_rbParticle[p_id].local_sdf;

	vec2 vel = pos - pos_old;
	float mass = 1.;
//	ivec4 map_index = ivec4(pos.xyxy) + ivec4(ivec2(0), step(vec2(0.5), pos-floor(pos)) * 2. - 1.);
//	ivec4 findex = map_index.xzxz + map_index.yyww * u_gi2d_info.m_resolution.x;

	float lensq = dot(vel, vel);
	float len = lensq < FLT_EPSIRON ? 0. : sqrt(lensq);
//	vec2 dir = len < FLT_EPSIRON ? vec2(0.) : (vel / len);
//	vec2 inv_dir;
//	inv_dir.x = abs(dir.x) < FLT_EPSIRON ? 0. : abs(1./dir.x);
//	inv_dir.y = abs(dir.y) < FLT_EPSIRON ? 0. : abs(1./dir.y);
//	float progress = max(inv_dir.x, inv_dir.y);

	for(int iter = 0; iter < len+1.; iter+=1)
	{
		float rate = min(iter/len, 1.);
		pos = fma(vel, vec2(rate), pos_old);
//		ivec2 p = ivec2(pos);
//		int index = p.x+p.y*u_gi2d_info.m_resolution.x;
//		uint count = min(b_collidable_count[index], COLLIDABLE_NUM);

		ivec4 map_index = ivec4(pos.xyxy) + ivec4(ivec2(0), step(vec2(0.5), pos-floor(pos)) * 2. - 1.);
		ivec4 findex = map_index.xzxz + map_index.yyww * u_gi2d_info.m_resolution.x;
		uvec4 counts;
		counts.x = min(b_collidable_count[findex.x], COLLIDABLE_NUM);
		counts.y = min(b_collidable_count[findex.y], COLLIDABLE_NUM);
		counts.z = min(b_collidable_count[findex.z], COLLIDABLE_NUM);
		counts.w = min(b_collidable_count[findex.w], COLLIDABLE_NUM);
		
		if(all(equal(counts, uvec4(0)))){ continue; }

		for(uint _i = 0; _i < 4; _i++)
		{
			for(uint ii = 0; ii < counts[_i]; ii++)
			{
				uint fj_id = findex[_i]*COLLIDABLE_NUM + ii;
				if( b_collidable[fj_id].r_id == p_id)
				{
					// 自分とは判定しない
					continue;
				}

				vec2 pos_j = b_collidable[fj_id].pos;
				vec2 vel_j = b_collidable[fj_id].vel;
				pos_j = fma(-vel_j, vec2(1.-rate), pos_j);
				vec2 rela_pos = pos-pos_j;
				vec2 rela_vel = vel-vel_j;
//				float lw = dot(rela_pos, rela_pos) / k_delimiter*k_delimiter;
//				if(lw >= 1.)
				if(dot(rela_pos, rela_pos) >= k_delimiter*k_delimiter)
				{
					// 距離が離れている
					continue;
				}

				vec2 pos_unit = normalize_safe(rela_pos);
				vec2 vel_unit = normalize_safe(rela_vel);
//				float vel_f = length_safe(rela_vel);
				float pos_l = length_safe(rela_pos);
//				float lw = dot(rela_pos, rela_vel) * vel_f;
//				vec2 fs = lw * pos_unit;
//				vec2 fi = rela_vel - dot(rela_pos, rela_vel)*pos_l;
				vec2 sdf_j = b_collidable[fj_id].sdf;
				if(!isZero(sdf_j))
				{
					vec2 n_vec = pos_j + sdf_j - pos;
					pos += dot(n_vec, sdf_j) * sdf_j * ((mass /(mass + b_collidable[fj_id].mass_inv)));
				}
				else
				{
					pos += rela_pos * (mass /(mass + b_collidable[fj_id].mass_inv));
				}
				iter = 99999;
			}
		}
	}

	b_rbParticle[p_id].pos = pos;
	ivec2 pos_integer = ivec2(round((pos-b_rigidbody[r_id].cm) * 65535.));
	atomicAdd(b_rigidbody[r_id].cm_work.x, pos_integer.x);
	atomicAdd(b_rigidbody[r_id].cm_work.y, pos_integer.y);


}

