#version 460
#extension GL_GOOGLE_include_directive : require

#define USE_Rigidbody2D 0
#define USE_GI2D 1
#include "GI2D.glsl"
#include "Rigidbody2D.glsl"


layout (local_size_x = RB_PARTICLE_BLOCK_SIZE) in;

void main() 
{
	uint p_id = gl_WorkGroupID.x*RB_PARTICLE_BLOCK_SIZE + gl_LocalInvocationID.x;
	if(b_rbParticle[p_id].contact_index == -1){ return; }

	vec2 pos = b_rbParticle[p_id].pos;
	vec2 exclusion = pos - b_rbParticle[p_id].pos_predict;
	if(dot(exclusion, exclusion) <= 0.0){
		return;
	}


	uint r_id = b_rbParticle_map[gl_WorkGroupID.x];
//	atomicMax(b_rigidbody[r_id].exclusion.x, int(abs(round(exclusion.x * 32765.)))*2 + int(exclusion.x >= 0.));
//	atomicMax(b_rigidbody[r_id].exclusion.y, int(abs(round(exclusion.y * 32765.)))*2 + int(exclusion.y >= 0.));
	atomicAdd(b_rigidbody[r_id].exclusion.x, int(round(exclusion.x * 65535.)));
	atomicAdd(b_rigidbody[r_id].exclusion.y, int(round(exclusion.y * 65535.)));

	float exclusion_angle = cross(vec3(b_rbParticle[p_id].local_pos, 0.), vec3(exclusion, 0.)).z;
	atomicAdd(b_rigidbody[r_id].exclusion_angle, int(round(exclusion_angle * 65535.*255.)));
	atomicAdd(b_rigidbody[r_id].solver_count, 1);
}

