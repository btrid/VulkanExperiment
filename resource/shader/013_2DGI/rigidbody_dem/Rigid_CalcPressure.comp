#version 460
#extension GL_GOOGLE_include_directive : require

#define USE_Rigidbody2D 0
#define USE_GI2D 1
#include "GI2D.glsl"
#include "Rigidbody2D.glsl"

layout (local_size_x = RB_PARTICLE_BLOCK_SIZE) in;

#define FLT_EPSIRON (1.19209290e-07)
//#define isZero(_v) (all(lessThan((_v), vec2(FLT_EPSIRON))))
#define isZero(_v) (dot((_v), (_v)) < FLT_EPSIRON)

void main() 
{
	uint pb_id = b_pb_update_list[b_world.cpu_index*b_manager.pb_list_size+gl_WorkGroupID.x];
	uint p_id = pb_id*RB_PARTICLE_BLOCK_SIZE + gl_LocalInvocationID.x;
	if(b_rbParticle[p_id].contact_index == -1){ return; }

	uint r_id = b_rbParticle_map[pb_id];
	if(((b_rigidbody[r_id].flag & RB_FLAG_FLUID) == 0)){ return; }

	vec2 pos = b_rbParticle[p_id].pos;
	vec2 move = vec2(0.);
	for(int y = -1; y < 1; y++)
	for(int x = -1; x < 1; x++)
	{{
		ivec2 map_index = ivec2(pos) + ivec2(x, y);
		if(any(lessThan(map_index, ivec2(0))) || any(greaterThanEqual(map_index, ivec2(0))))
		{
			 continue;
		}
		int findex = map_index.x + map_index.y * u_gi2d_info.m_resolution.x;
		int count = int(min(b_fluid_counter[findex], COLLIDABLE_NUM));
		for(uint ii = 0; ii < count; ii++)
		{
			uint fj_id = findex*COLLIDABLE_NUM + ii;
			vec2 pos_j = b_fluid[fj_id].pos;
			vec2 rela_pos = pos-pos_j;
			if(dot(rela_pos, rela_pos) <= 0.0001 || dot(rela_pos, rela_pos) >= k_delimiter*k_delimiter)
			{
				// 距離が離れているか自分
				continue;
			}

			move += normalize(rela_pos) * calcWeight(length(rela_pos)) * b_fluid[fj_id].density;
		}
	}}

	b_rbParticle[p_id].pos += move;


}

