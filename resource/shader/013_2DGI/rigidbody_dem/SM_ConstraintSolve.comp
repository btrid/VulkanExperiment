#version 460
#extension GL_GOOGLE_include_directive : require

#define USE_Rigidbody2D 0
#define USE_GI2D 1
#include "GI2D.glsl"
#include "Rigidbody2D.glsl"

layout (local_size_x = RB_PARTICLE_BLOCK_SIZE) in;


void main() 
{
	uint p_id = gl_WorkGroupID.x*RB_PARTICLE_BLOCK_SIZE + gl_LocalInvocationID.x;
	if(b_rbParticle[p_id].contact_index == -1){ return; }

	uint r_id = b_rbParticle_map[gl_WorkGroupID.x];
	vec2 pos = b_rbParticle[p_id].pos;
	vec2 sdf = b_rbParticle[p_id].local_sdf;
	ivec4 map_index = ivec4(pos.xyxy) + ivec4(ivec2(0), step(vec2(0.5), pos-floor(pos)) * 2. - 1.);
	ivec4 findex = map_index.xzxz + map_index.yyww * u_gi2d_info.m_resolution.x;
	float mass = 1.;

	for(uint i = 0; i < 4; i++)
	{
		int hit = 0;
		vec2 move = vec2(0.);
		uint index = findex[i];
		uint count = min(b_fluid_count[index], FLUID_NUM);
		for(uint ii = 0; ii < count; ii++)
		{
			uint fj_id = index*FLUID_NUM + ii;
			if( b_fluid[fj_id].r_id == r_id)
			{
				// 自分とは判定しない
				continue;
			}

			vec2 pos_j = b_fluid[fj_id].pos;
			vec2 rela_pos = pos_j - pos;
			float distsq = dot(rela_pos, rela_pos);
			if(distsq >= k_delimiter*k_delimiter)
			{
				continue;
			}

			vec2 sdf_j = b_fluid[fj_id].sdf;
			float mass_j = b_fluid[fj_id].mass;
			float w = max(dot(-normalize(sdf), normalize(sdf_j)), 0.);
			float total_mass = mass + mass_j;
			{
				vec2 collect_vec = (abs(distsq) <= 0.1 ? vec2(0.) : normalize(rela_pos)) + sdf_j;
				move += dot(collect_vec, normalize(sdf_j)) * normalize(sdf_j) * ((mass /total_mass) * w);
				hit++;
//				move += sdf_j  * ((mass /total_mass) * w);
//				move += vec2(0., -1.);
//				break;
			}
		}

		if(hit != 0)
		{
			pos += move / hit;
		}
	}

//	pos += move;
	b_rbParticle[p_id].pos = pos;
	ivec2 pos_integer = ivec2(round(pos * 65535.  / b_rigidbody[r_id].pnum));
	atomicAdd(b_rigidbody[r_id].cm_work.x, pos_integer.x);
	atomicAdd(b_rigidbody[r_id].cm_work.y, pos_integer.y);


}

