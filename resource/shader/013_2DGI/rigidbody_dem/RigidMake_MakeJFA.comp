#version 460
#extension GL_GOOGLE_include_directive : require

#define USE_Rigidbody2D 0
#define USE_GI2D 1
#define USE_MakeRigidbody 2
#include "GI2D.glsl"
#include "Rigidbody2D.glsl"
layout (local_size_x = 16, local_size_y = 16) in;

layout(push_constant) uniform Input
{
	uint distance;
} constant;


void nearest(inout i16vec2 new_cell, inout vec4 current_d, in uvec2 reso, in vec2 current, in uvec2 target)
{
	if(any(greaterThanEqual(target, reso.xy))){ return; }
	i16vec2 target_cell = b_jfa_cell[target.x + target.y*reso.x];

	{
		float d = distance(vec2(target_cell), current);
		if(d < current_d.x)
		{
			current_d.x = d;
			new_cell = target_cell;
		}
	}

}
void main() 
{
	const uvec2 reso = uvec2(u_gi2d_info.m_resolution.xy);
	const uvec2 current = uvec2(gl_GlobalInvocationID.xy);
	const ivec3 cd = ivec3(constant.distance) * ivec3(-1, 0, 1);
	const i16vec2 current_cell = b_jfa_cell[current.x + current.y*reso.x];
	vec4 d;
	d.x = current_cell.x >= 0 ? distance(vec2(current), vec2(current_cell)) : 99999999.;
	i16vec2 new_cell = current_cell;
	const vec4 old_d = d;
	nearest(new_cell, d, reso, current, current + cd.xx);
	nearest(new_cell, d, reso, current, current + cd.xy);
	nearest(new_cell, d, reso, current, current + cd.xz);
	nearest(new_cell, d, reso, current, current + cd.yx);
	//nearest(new_cell, d, reso, current, current + cd.yy);
	nearest(new_cell, d, reso, current, current + cd.yz);
	nearest(new_cell, d, reso, current, current + cd.zx);
	nearest(new_cell, d, reso, current, current + cd.zy);
	nearest(new_cell, d, reso, current, current + cd.zz);

	if(any(notEqual(d, old_d)))
	{
		b_jfa_cell
		[current.x + current.y*reso.x] = new_cell;
	}
}
