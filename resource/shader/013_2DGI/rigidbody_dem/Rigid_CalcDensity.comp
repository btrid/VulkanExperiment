#version 460
#extension GL_GOOGLE_include_directive : require

#define USE_Rigidbody2D 0
#define USE_GI2D 1
#include "GI2D.glsl"
#include "Rigidbody2D.glsl"

layout (local_size_x = 8, local_size_y = COLLIDABLE_NUM) in;

void main() 
{
	uint f_num = b_fluid_counter[gl_GlobalInvocationID.x];
	if(f_num > gl_LocalInvocationID.y)
	{
		return;
	}
	uint f_id = gl_GlobalInvocationID.x*RB_PARTICLE_BLOCK_SIZE + gl_LocalInvocationID.y;
	rbFluid fluid = b_fluid[f_id];
	
	float density = 0.;
	for(int y = -1; y <= 1; y++)
	for(int x = -1; x <= 1; x++)
	{{
		ivec2 map_index = ivec2(fluid.pos) + ivec2(x, y);
		if(any(lessThan(map_index, ivec2(0))) || any(greaterThanEqual(map_index, ivec2(0))))
		{
			 continue;
		}
		int findex = map_index.x + map_index.y * u_gi2d_info.m_resolution.x;
		int count = int(min(b_fluid_counter[findex], COLLIDABLE_NUM));
		for(uint ii = 0; ii < count; ii++)
		{
			uint fj_id = findex*COLLIDABLE_NUM + ii;
			vec2 pos_j = b_fluid[fj_id].pos;
			vec2 rela_pos = fluid.pos-pos_j;
			if(dot(rela_pos, rela_pos) >= k_delimiter*k_delimiter || dot(rela_pos, rela_pos) <= 0.0001)
			{
				// 距離が離れているか自分
				continue;
			}
			density += calcWeight(length(rela_pos));

		}
	}}

	b_fluid[f_id].density = density;
	if(fluid.p_id != -1)
	{
		b_rbParticle[fluid.p_id].density = density;
	}


}

