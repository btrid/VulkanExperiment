#version 460
#extension GL_GOOGLE_include_directive : require

#define USE_Rigidbody2D 0
#define USE_GI2D 1
#include "GI2D.glsl"
#include "Rigidbody2D.glsl"

layout (local_size_x = RB_PARTICLE_BLOCK_SIZE) in;

vec2 calcTangent(in vec2 I, in vec2 N)
{
	return I - N * dot(N, I);
}

const float k_radius = 0.5;
const float k_delimiter = 1.;

void main() 
{
	uint p_id = gl_WorkGroupID.x*RB_PARTICLE_BLOCK_SIZE + gl_LocalInvocationID.x;
	if(b_rbParticle[p_id].contact_index == -1){ return; }

	uint f_id = b_rbParticle[p_id].f_id;
	uint r_id = b_rbParticle[p_id].r_id;
	uint is_active = b_rbParticle[p_id].is_active;
	vec2 pos = b_rbParticle[p_id].pos;
	ivec4 map_index = ivec4(pos.xyxy) + ivec4(ivec2(0), step(vec2(0.5), pos-floor(pos)) * 2. - 1.);
	ivec4 findex = map_index.xzxz + map_index.yyww * u_gi2d_info.m_resolution.x;

	int hit = 0;
	vec2 ex = vec2(0.);
	for(uint i = 0; i < 4; i++)
	{
		uint index = findex[i];
		uint count = min(b_fluid_count[index], FLUID_NUM);
		for(uint ii = 0; ii < count; ii++)
		{
			uint fj_id = index*FLUID_NUM + ii;
			if( b_fluid[fj_id].r_id == r_id)
			{
				// 自分とは判定しない
				continue;
			}

			vec2 rela_pos = pos - b_fluid[fj_id].pos;
			if(dot(rela_pos, rela_pos) >= k_delimiter*k_delimiter)
			{
				continue;
			}

			if(is_active != 0 && b_fluid[fj_id].is_active != 0)
			{
				if( fj_id >= f_id)
				{
					continue;
				}
			}

			uint c_index = atomicAdd(b_constraint_counter.w, 1);
			if(c_index % 64 == 0){ atomicAdd(b_constraint_counter.x, 1);}
			rbConstraint c;
			c.f_id1 = f_id;
			c.f_id2 = fj_id;
			b_constraint[c_index] = c;
		}
	}
}

