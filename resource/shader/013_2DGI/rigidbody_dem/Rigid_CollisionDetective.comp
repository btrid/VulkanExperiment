#version 460
#extension GL_GOOGLE_include_directive : require

#define USE_Rigidbody2D_World 0
#define USE_Rigidbody2D 1
#define USE_GI2D 2
#include "GI2D.glsl"
#include "Rigidbody2D.glsl"


layout (local_size_x = 1024) in;


void main() 
{
	int p_id = int(gl_GlobalInvocationID.x);
	if(p_id >= b_rigidbody.pnum){ return; }
	if(b_rbParticle[p_id].contact_index == -1){ return; }

	vec2 vel_dt = b_rigidbody.vel*DT;
	float angular_vel_dt = b_rigidbody.angle_vel*DT;

	float step = 1.;
	uint ishit = 0;
//	if(dot(vel_dt, vel_dt) != 0. || angular_vel_dt != 0.)
	{
		float angle = b_rigidbody.angle;
		vec2 pos = b_rigidbody.pos;
		vec2 rela_pos = b_relative_pos[p_id];

		vec2 angle_vel = cross(vec3(rela_pos, 0.), vec3(0., 0., angular_vel_dt)).xy;

//		float progress = length(vel_dt+angle_vel);
		float progress = 30.;
		float inv_progress = 1. / progress;
		for(int i = 1; i <= int(progress+1.); i++)
		{
			step = min(float(i), progress) * inv_progress;
			vec2 local_pos = rotateRBParticle(rela_pos, angle+angular_vel_dt*step);
			vec2 next_pos = pos + vel_dt*step + local_pos;
			ivec2 map_index = ivec2(next_pos);

			// hit確認
			uint index = map_index.x + map_index.y * u_gi2d_info.m_resolution.x;
			uint count = b_fluid_count[index];
			for(uint ii = 0; ii < count; ii++)
			{
				uint target_id = b_fluid[index*FLUID_NUM + ii].id;
				if( target_id == b_rigidbody.id)
				{
					continue;
				}

				ishit = 1;
				break;
			}
		}
	}

	if(ishit != 0)
		atomicMin(b_rigidbody.dist, uint(step * (65535.*255.)));
	b_rbParticle[p_id].is_contact = ishit;
}

