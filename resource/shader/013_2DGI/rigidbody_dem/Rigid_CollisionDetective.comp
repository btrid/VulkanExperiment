#version 460
#extension GL_GOOGLE_include_directive : require

#define USE_Rigidbody2D 0
#define USE_GI2D 1
#include "GI2D.glsl"
#include "Rigidbody2D.glsl"

layout (local_size_x = 1024) in;


vec2 calcTangent(in vec2 normal)
{
	vec3 vec = vec3(0.,0.,1.);
	return normalize(cross(vec3(normal, 0.),vec)).xy;
}

void main() 
{
	int p_id = int(gl_GlobalInvocationID.x);
	if(p_id >= b_rigidbody.pnum){ return; }
	
	if(b_rbParticle[p_id].contact_index == -1){ return; }

	const ivec4 reso = ivec4(u_gi2d_info.m_resolution.xy, u_gi2d_info.m_resolution.xy/8);

	vec2 vel = b_rigidbody.vel*DT;
	float angular_vel = b_rigidbody.angle_vel*DT;

	uint ishit = 0;
	if(dot(vel, vel) != 0. || angular_vel != 0.)
	{
		float angle = b_rigidbody.angle;
		vec2 pos = b_rigidbody.pos;
		vec2 rela_pos = b_relative_pos[p_id];

		vec2 angle_vel = cross(vec3(rela_pos, 0.), vec3(0., 0., angular_vel)).xy;

//		float progress = length(vel+angle_vel);
		float progress = 100.;
		float inv_progress = 1. / progress;
		for(int i = 0; i <= int(progress+1.); i++)
		{
			float step = min(float(i), progress) * inv_progress;
			vec2 local_pos = rotateRBParticle(rela_pos, angle+angular_vel*step);
			vec2 next_pos = pos + vel*step + local_pos;
			ivec2 map_index = ivec2(next_pos);

			// hit確認
			{
				ivec4 fragment_index = ivec4(map_index/8, map_index%8);
				uint64_t fragment_map = b_diffuse_map[getMemoryOrder(fragment_index.xy)];
				uint64_t bit = 1ul<<(fragment_index.z+fragment_index.w*8);
				if((fragment_map & bit) != 0)
				{
					ishit = 1;
//					step = max(float(i-2), 0.) * inv_progress;
					atomicMin(b_rigidbody.dist, uint(step * (65535.*255.)));
					break;
				}
			}
		}
	}

	b_rbParticle[p_id].is_contact = ishit;
}

