#version 460
#extension GL_GOOGLE_include_directive : require

#define USE_Rigidbody2D 0
#define USE_GI2D 1
#define USE_MakeRigidbody 2
#include "GI2D.glsl"
#include "Rigidbody2D.glsl"
layout (local_size_x = 256) in;

layout(push_constant) uniform Input
{
	uint pb_num;
	int p;
} constant;


shared uint s_rb_id;
shared uint s_pb_id;
shared uint s_rb_update_index;
shared uint s_pb_update_index;
shared bool s_ok;
void main() 
{
	if(gl_LocalInvocationIndex >= constant.pb_num) { return; }

	if(gl_LocalInvocationIndex == 0)
	{
		// 追加できるかチェック
		s_rb_update_index = b_update_counter[b_world.gpu_index*2+0].x;
		s_pb_update_index = b_update_counter[b_world.gpu_index*2+1].x;

		if(s_rb_update_index >= b_manager.rb_list_size || s_pb_update_index + constant.pb_num >= b_manager.pb_list_size)
		{
			// 追加できない
			s_ok =false;
			b_make_dispatch_param = uvec4(0);
		}
		else
		{
			s_ok =true;
			b_make_dispatch_param = uvec4(constant.pb_num, 1, 1, 0);
		}
	}
	memoryBarrierShared();
	barrier();

	if(!s_ok)
	{
		// 追加できないので終わり
		return;
	}

	if(gl_LocalInvocationIndex == 0)
	{
		// bufferからメモリを取得
		s_rb_id = b_manager.rb_active_index;
		b_manager.rb_active_index = (b_manager.rb_active_index+1)%b_world.rigidbody_max;

		s_pb_id = b_manager.pb_active_index;
		b_manager.pb_active_index = (b_manager.pb_active_index+constant.pb_num)%b_world.particle_block_max;


		b_rigidbody[s_rb_id] = b_make_rigidbody;

		// rigidbody更新フラグを立てる
		b_update_counter[b_world.gpu_index*2+0].x += 1;
		b_rb_update_list[b_world.gpu_index*b_manager.rb_list_size + s_rb_update_index] = s_rb_id;

		b_update_counter[b_world.gpu_index*2+1].x += constant.pb_num;

	}

	memoryBarrierShared();
	barrier();

		// bufferからメモリを取得
	uint freelist_index  = (s_pb_id + gl_LocalInvocationIndex) % b_manager.pb_list_size;
	uint pb_id = b_pb_memory_list[freelist_index];
	b_rbParticle_map[pb_id] = s_rb_id;

	// particle更新フラグを立てる
	uint update_index = s_pb_update_index + gl_LocalInvocationIndex;
	b_pb_update_list[b_world.gpu_index*b_manager.pb_list_size + update_index] = pb_id;

}
 