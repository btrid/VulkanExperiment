#version 460
#extension GL_GOOGLE_include_directive : require

#define USE_Rigidbody2D 0
#define USE_GI2D 1
#define USE_MakeRigidbody 2
#include "GI2D.glsl"
#include "Rigidbody2D.glsl"
layout (local_size_x = 256) in;

layout(push_constant) uniform Input
{
	uint pb_num;
	int p;
	uvec2 reso;
} constant;


shared uint s_rb_id;
shared uint s_pb_id;
shared uint s_pb_update_index;
void main() 
{
	if(gl_LocalInvocationIndex >= constant.pb_num) { return; }

	if(gl_LocalInvocationIndex == 0)
	{
		// bufferからメモリを取得
		s_rb_id = b_manager.rb_active_index;
		b_manager.rb_active_index = (b_manager.rb_active_index+1)%b_world.rigidbody_max;

		s_pb_id = b_manager.pb_active_index;
		b_manager.pb_active_index = (b_manager.pb_active_index+constant.pb_num)%b_world.particle_block_max;


		b_rigidbody[s_rb_id] = b_make_rigidbody;

		// rigidbody更新フラグを立てる
		uint update_index = b_update_counter[b_world.gpu_index*2+0].x;
		b_update_counter[b_world.gpu_index*2+0].x += 1;
		b_rb_update_list[b_world.gpu_index*b_manager.rb_list_size + update_index] = s_rb_id;

		s_pb_update_index = b_update_counter[b_world.gpu_index*2+1].x;
		b_update_counter[b_world.gpu_index*2+1].x += constant.pb_num;

	}

	barrier();
	memoryBarrierShared();

		// bufferからメモリを取得
	uint freelist_index  = (s_pb_id + gl_LocalInvocationIndex) % b_manager.pb_list_size;
	uint pb_id = b_pb_memory_list[freelist_index];
	b_rbParticle_map[pb_id] = s_rb_id;

	// particle更新フラグを立てる
	uint update_index = s_pb_update_index + gl_LocalInvocationIndex;
	b_pb_update_list[b_world.gpu_index*b_manager.pb_list_size + update_index] = pb_id;

}
 