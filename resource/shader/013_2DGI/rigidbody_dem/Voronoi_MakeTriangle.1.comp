#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_shader_explicit_arithmetic_types : require
#extension GL_EXT_shader_atomic_int64 : require
#define USE_Rigidbody2D 0
#include "Rigidbody2D.glsl"

#extension GL_NV_conservative_raster : require

layout (local_size_x = 8, local_size_y = 8) in;

layout(push_constant) uniform Input
{
	int distance;
	int p;
	uvec2 reso;
} constant;

shared i16vec2 s_cell[8+1][8+1];
void main() 
{
	uvec2 current = gl_GlobalInvocationID.xy;
	s_cell[current.x][current.y] = b_voronoi[current.x + current.y*constant.reso.x];

	if( gl_LocalInvocationIndex < 9)
	{
		// 下辺を埋める
		uint xx = min((gl_WorkGroupID.x)*8 + gl_LocalInvocationIndex, constant.reso.x-1);
		uint yy = min((gl_WorkGroupID.y+1)*8 + gl_LocalInvocationIndex, constant.reso.y-1);
		s_cell[gl_LocalInvocationIndex][8] = b_voronoi[xx + yy*constant.reso.x];
	}
	if( gl_LocalInvocationIndex < 8)
	{
		// 右辺を埋める
		uint xx = min((gl_WorkGroupID.x+1)*8, constant.reso.x-1);
		uint yy = min((gl_WorkGroupID.y)*8 + gl_LocalInvocationIndex, constant.reso.y-1);
		s_cell[8][gl_LocalInvocationIndex] = b_voronoi[xx + yy*constant.reso.x];
	}

	barrier();
	memoryBarrierShared();

	uvec4 index_x = gl_LocalInvocationID.xxxx + uvec4(0,1,0,1);
	uvec4 index_y = gl_LocalInvocationID.yyyy + uvec4(0,0,1,1);
	i16vec2 v[4];
	v[0] = s_cell[index_x.x][index_y.x];
	v[1] = s_cell[index_x.y][index_y.y];
	v[2] = s_cell[index_x.z][index_y.z];
	v[3] = s_cell[index_x.w][index_y.w];
	uint a =  v[0].x+v[0].y*constant.reso.x;
	uint b =  v[1].x+v[1].y*constant.reso.x;
	uint c =  v[2].x+v[2].y*constant.reso.x;
	uint d =  v[3].x+v[3].y*constant.reso.x;

//	int count = 1;
//	a != b && a!=c && a!=d;
//	count += b!=a ? 1 : 0;
//	count += int(all(notEqual(c.xx, ivec2(a,b))));
//	count += int(all(notEqual(d.xxx, ivec3(a,b,c))));
	int count = 1;
	int diff[4] = {0,0,0,0};
	if(b!=a){ diff[count++] = 1; }
	if(c!=a && c!=b){ diff[count++] = 2; }
	if(d!=a && d!=b && d!=b){ diff[count++] = 3; }
	count -= 2;

	if(count <= 0){ return; }

	uint vindex = atomicAdd(b_delaunay_vertex_couter.x, count) * 3;
	if(count >= 1)
	{
		b_delaunay_vertex[vindex] = v[diff[0]];
		b_delaunay_vertex[vindex+1] = v[diff[1]];
		b_delaunay_vertex[vindex+2] = v[diff[2]];
	}
	if(count >= 2)
	{
		vindex += 3;
		b_delaunay_vertex[vindex] = v[diff[1]];
		b_delaunay_vertex[vindex+1] = v[diff[2]];
		b_delaunay_vertex[vindex+2] = v[diff[3]];		
	}


}
