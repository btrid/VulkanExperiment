#version 460
#extension GL_GOOGLE_include_directive : require

#define USE_Rigidbody2D_World 0
#define USE_Rigidbody2D 1
#define USE_GI2D 2
#include "GI2D.glsl"
#include "Rigidbody2D.glsl"

layout (local_size_x = 1024) in;

vec2 rotate(in vec2 v, in float angle)
{
	float c = cos(angle);
	float s = sin(angle);

	vec2 Result;
	Result.x = v.x * c - v.y * s;
	Result.y = v.x * s + v.y * c;
	return Result;
}

vec2 calcTangent(in vec2 I, in vec2 N)
{
	return I - N * dot(N, I);
}

vec2 calcNormal(in vec2 pos, in vec2 dir/*, in uint64_t map*/)
{
//	ivec4 map_index = ivec4(pos.xyxy) + ivec4(ivec2(0), round(pos.xy));
	ivec4 map_index = ivec4(pos.xyxy) + ivec4(ivec2(0), sign(dir.xy));
	ivec4 findex = map_index.xzxz + map_index.yyww * u_gi2d_info.m_resolution.x;
//	ivec4 fragment_index_sub = ivec4(map_index%8);

	ivec4 iswall = ivec4(0);
	for(int i = 0; i <4; i++)
	{
		uint count = min(b_fluid_count[map_index[i]], FLUID_NUM);
		for(uint ii = 0; ii < count; ii++)
		{
			if( b_fluid[findex[i]*FLUID_NUM + ii].id == b_rigidbody.id)
			{
				// 自分とは判定しない
				continue;
			}
			iswall[i] = 1;
			break;
		}
	}

	vec2 n = abs(vec2(iswall[3]-iswall[1], iswall[2]-iswall[0]));
	n = dot(n , n) == 0. ? -dir : n;
	while(dot(n , n) == 0.);

	return normalize(n);
}

void main() 
{
	int p_id = int(gl_GlobalInvocationID.x);
	if(p_id >= b_rigidbody.pnum){ return; }
	if(b_rbParticle[p_id].contact_index == -1){ return; }

	vec2 pos = b_rbParticle[p_id].pos;
	ivec4 map_index = ivec4(pos.xyxy);
//	ivec4 map_index = ivec4(pos.xyxy) + ivec4(ivec2(0), step(vec2(0.5), pos-floor(pos)));
	ivec4 findex = map_index.xzxz + map_index.yyww * u_gi2d_info.m_resolution.x;
	vec2 vel = b_rbParticle[p_id].vel;

	vec2 delta_linear_vel = vec2(0.0);
	float delta_angular_vel = 0.0;
	bool ishit = false;
	for(uint i = 0; i < 4; i++)
	{
		uint count = min(b_fluid_count[findex[i]], FLUID_NUM);
		for(uint ii = 0; ii < count; ii++)
		{
			if( b_fluid[findex[i]*FLUID_NUM + ii].id == b_rigidbody.id)
			{
				// 自分とは判定しない
				continue;
			}
			vec2 Pj = b_fluid[findex[i]*FLUID_NUM + ii].pos;
			float k_radius = 1.;

//			float d = distance(Pj, pos);
			vec2 rela_pos = Pj - pos;
			if(dot(rela_pos, rela_pos) >= k_radius*2.*k_radius*2.)
			{
				// 
				continue;
			}
			rela_pos = normalize(rela_pos);
			vec2 rela_vel = b_fluid[findex[i]*FLUID_NUM + ii].vel - vel;
			vec2 rela_dir = normalize(rela_vel);

			float k_spring = 0.15;
			float k_spring_t = 0.15;
			{
				vec2 restitution = rela_vel*k_spring; // 反発力
				vec2 restitution_t = calcTangent(rela_vel, rela_pos) *k_spring_t;
				delta_linear_vel += restitution + restitution_t;
				delta_angular_vel += cross(vec3(b_rbParticle[p_id].local_pos, 0.), vec3(restitution + restitution_t, 0.)).z;

			}
			ishit = true;
		}
	}

	if(ishit)
	{
		int index = atomicAdd(b_rigidbody.solver_count, 1);
		atomicAdd(b_rigidbody.vel_work.x, int(round(delta_linear_vel.x * 65535.)));
		atomicAdd(b_rigidbody.vel_work.y, int(round(delta_linear_vel.y * 65535.)));
		atomicAdd(b_rigidbody.angle_vel_work, int(round(delta_angular_vel * 65535.*255.)));
	}
}

