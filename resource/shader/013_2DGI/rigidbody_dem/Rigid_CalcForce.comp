#version 460
#extension GL_GOOGLE_include_directive : require

#define USE_Rigidbody2D 0
#define USE_GI2D 1
#include "GI2D.glsl"
#include "Rigidbody2D.glsl"

layout (local_size_x = 1024) in;

vec2 rotate(in vec2 v, in float angle)
{
	float c = cos(angle);
	float s = sin(angle);

	vec2 Result;
	Result.x = v.x * c - v.y * s;
	Result.y = v.x * s + v.y * c;
	return Result;
}

vec2 calcTangent(in vec2 normal)
{
//	vec3 vec = vec3(0.,0.,1.);
//	return normalize(cross(vec3(normal, 0.),vec)).xy;
	return rotate(normal, radians(90.));
}

vec2 calcNormal(in vec2 pos, in vec2 dir/*, in uint64_t map*/)
{
//	ivec4 map_index = ivec4(pos.xyxy) + ivec4(0, 0, 1, 1) * ivec4(round(fract(pos.xyxy)) * 2. - 1.);
//	ivec4 map_index = ivec4(pos.xyxy) + ivec4(-1, -1, 1, 1);
	ivec4 map_index = ivec4(pos.xyxy) + ivec4(sign(-dir.xyxy));
	ivec4 fragment_index = ivec4(map_index/8);
	ivec4 fragment_index_sub = ivec4(map_index%8);
	u64vec4 map;
	map[0] = b_diffuse_map[getMemoryOrder(fragment_index.xy)];
	map[1] = b_diffuse_map[getMemoryOrder(fragment_index.zy)];
	map[2] = b_diffuse_map[getMemoryOrder(fragment_index.xw)];
	map[3] = 0;
	u64vec4 bit = u64vec4(1ul)<<(fragment_index_sub.xxzz+fragment_index_sub.yyww*8);
	ivec4 iswall = ivec4(notEqual((map & bit), u64vec4(0ul)));
	vec2 n = abs(vec2(iswall[2]-iswall[0], iswall[1]-iswall[0]))*vec2(sign(-dir.xy));
	n = dot(n , n) == 0. ? -dir : n;
	while(dot(n , n) == 0.);

	return normalize(n);
}

float atan2(in float y, in float x){
    return x == 0.0 ? sign(y)*3.1415/2 : atan(y, x);
}

void main() 
{
	int p_id = int(gl_GlobalInvocationID.x);
	if(p_id >= b_rigidbody.pnum){ return; }
	
	if(b_rbParticle[p_id].contact_index == -1){ return; }

	const ivec4 reso = ivec4(u_gi2d_info.m_resolution.xy, u_gi2d_info.m_resolution.xy/8);

	if(b_rigidbody.dist != -1)
	{ 
		float step = float(b_rigidbody.dist) / (65535.*255);

		vec2 rela_pos = b_relative_pos[p_id];
		vec2 local_pos = rotateRBParticle(rela_pos, b_rigidbody.angle+b_rigidbody.angle_vel*DT*step);
		vec2 pos = b_rigidbody.pos;

		vec2 vel = b_rigidbody.vel*DT;
		vec2 angular_vel = rotateRBParticle(rela_pos, b_rigidbody.angle+b_rigidbody.angle_vel*DT) - rotateRBParticle(rela_pos, b_rigidbody.angle);

		vec2 dir = vel + angular_vel;

		float advance = length(dir);
		dir = normalize(dir);

		vec2 next_pos = pos + vel*step + local_pos;
		ivec2 map_index = ivec2(next_pos);

		// hit確認
		{
			ivec4 fragment_index = ivec4(map_index/8, map_index%8);
			uint64_t fragment_map = b_diffuse_map[getMemoryOrder(fragment_index.xy)];
			uint64_t bit = 1ul<<(fragment_index.z+fragment_index.w*8);
			if((fragment_map & bit) != 0)
			{
				float spring = 1.5;
				float spring_t = 0.;
				float decay = 0.5;
				{
					vec2 restitution = -dir*(spring*advance); // 反発力 めり込んだ量を戻す
					vec3 n = vec3(calcNormal(next_pos, dir), 0.);
					vec2 restitution_t = cross(cross(n, vec3(-dir, 0.)), n).xy * advance * spring_t;
					vec2 damping = decay * -dir; //減衰力
					vec2 delta_linear_vel = restitution + damping + restitution_t;
					float delta_angular_vel = cross(vec3(local_pos, 0.), vec3(delta_linear_vel, 0.)).z;

					int index = atomicAdd(b_rigidbody.solver_count, 1);
					atomicAdd(b_rigidbody.vel_work.x, int(round(delta_linear_vel.x * 65535.)));
					atomicAdd(b_rigidbody.vel_work.y, int(round(delta_linear_vel.y * 65535.)));
					atomicAdd(b_rigidbody.angle_vel_work, int(round(delta_angular_vel * 65535.*255.)));
				}

			}
		}
	}
}

