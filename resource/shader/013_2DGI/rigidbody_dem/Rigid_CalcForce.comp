#version 460
#extension GL_GOOGLE_include_directive : require

#define USE_Rigidbody2D 0
#define USE_GI2D 1
#include "GI2D.glsl"
#include "Rigidbody2D.glsl"

layout (local_size_x = 1024) in;

vec2 calcTangent(in vec2 normal)
{
	vec3 vec = vec3(0.,0.,1.);
	return normalize(cross(vec3(normal, 0.),vec)).xy;
}

float atan2(in float y, in float x){
    return x == 0.0 ? sign(y)*3.1415/2 : atan(y, x);
}
void main() 
{
	int p_id = int(gl_GlobalInvocationID.x);
	if(p_id >= b_rigidbody.pnum){ return; }
	
	if(b_rbParticle[p_id].contact_index == -1){ return; }

	const ivec4 reso = ivec4(u_gi2d_info.m_resolution.xy, u_gi2d_info.m_resolution.xy/8);

	if(b_rigidbody.dist != -1)
	{ 
		float step = float(b_rigidbody.dist) / (65535.*255);

		vec2 rela_pos = b_relative_pos[p_id];
		vec2 local_pos = rotateRBParticle(rela_pos, b_rigidbody.angle+b_rigidbody.angle_vel*DT*step);
		vec2 pos = b_rigidbody.pos;

		vec2 vel = b_rigidbody.vel*DT;
		vec2 angular_vel = local_pos - rotateRBParticle(rela_pos, b_rigidbody.angle);

		vec2 dir = vel + angular_vel;

		float advance = length(dir);
		dir = normalize(dir);

		vec2 next_pos = pos + vel*step + local_pos;
		ivec2 map_index = ivec2(next_pos);

		// hit確認
		{
			ivec4 fragment_index = ivec4(map_index/8, map_index%8);
			uint64_t fragment_map = b_diffuse_map[getMemoryOrder(fragment_index.xy)];
			uint64_t bit = 1ul<<(fragment_index.z+fragment_index.w*8);
			if((fragment_map & bit) != 0)
			{
				float spring = 1.2;
				float decay = 0.2;
				{
					vec2 restitution = -dir*(spring*advance); // 反発力 めり込んだ量を戻す
					vec2 damping = decay * -dir; //減衰力
					vec2 tangent_dir = calcTangent(dir);
					vec2 delta_linear_vel = restitution + damping;
					float delta_angular_vel = cross(vec3(local_pos, 0.), vec3(restitution, 0.)).z;

					int index = atomicAdd(b_rigidbody.solver_count, 1);
					atomicAdd(b_rigidbody.vel_work.x, int(round(delta_linear_vel.x * 65535.)));
					atomicAdd(b_rigidbody.vel_work.y, int(round(delta_linear_vel.y * 65535.)));
					atomicAdd(b_rigidbody.angle_vel_work, int(round(delta_angular_vel * 65535.*255.)));
				}

			}
		}
	}
}

