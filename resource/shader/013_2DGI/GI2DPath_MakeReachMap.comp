#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Path 1
#include "GI2D.glsl"
#include "GI2DPath.glsl"

layout (local_size_x = 1024) in;

layout(push_constant) uniform InputVertex
{
	ivec2 reso;
	i16vec2 target[2];
} constant;


shared i16vec2 s_active[1024][4];
shared ivec4 s_active_counter;
shared int s_frame;

void path(in i16vec2 current)
{
	const i16vec2 g_offset[4] = { i16vec2(1, 0), i16vec2(-1, 0), i16vec2(0, 1), i16vec2(0, -1) };
	for(int i = 0; i < 4; i++)
	{
		ivec2 access = ivec2(current + g_offset[i]);
		if (any(lessThan(access, ivec2(0))) || any(greaterThanEqual(access, constant.reso)))
		{
			continue;
		}

		int access_1d = access.x + access.y * constant.reso.x;
		int bit = 1<<(access_1d % 32);
		if((atomicOr(b_close[access_1d / 32], bit) & bit) != 0)
		{
			continue;
		}

		s_active[s_frame][atomicAdd(s_active_counter[s_frame], 1)] = i16vec2(access);
	}
}
void main() 
{
	for(uint i = gl_LocalInvocationIndex; i < constant.reso.x*constant.reso.y/32; i+=gl_NumWorkGroups.x)
	{
		b_close[i] = 0;
	}
	if(gl_LocalInvocationIndex == 0)
	{
		s_active_counter = ivec4(0);
		s_frame = 0;
	}

	barrier();
	memoryBarrierShared();
	memoryBarrierBuffer();

	if(gl_LocalInvocationIndex < 2)
	{
		path(constant.target[gl_LocalInvocationIndex]);
	}

	for(int i = 0; i < 1000; i++)
	{
		barrier();
		memoryBarrierShared();
		int count = s_active_counter[s_frame];
		if(count == 0){ break; }

		bool is_active = gl_LocalInvocationIndex < count;

		i16vec2 open = s_active[s_frame][gl_LocalInvocationIndex];

		barrier();
//		memoryBarrierShared();

		if(gl_LocalInvocationIndex == 0)
		{
			s_frame = (s_frame + 1) % 4;
			s_active_counter[s_frame] = 0;
		}

		barrier();
		memoryBarrierShared();

		if(is_active)
		{
			path(open);
		}
	}

}
