#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Path 1
#include "GI2D.glsl"
#include "GI2DPath.glsl"

layout (local_size_x = 1024) in;

layout(push_constant) uniform InputVertex
{
	ivec2 reso;
	i16vec2 num;
	i16vec2 _p;
	i16vec2 target[4];
	i16vec2 random_serch[3];
} constant;


shared i16vec2 s_active[1024*4];
shared uvec2 s_active_counter;

void path(in i16vec2 current)
{
	uint8_t state = b_state[current.x + current.y * constant.reso.x];

#if 0
	const i16vec2 g_offset[4] = { i16vec2(1, 0), i16vec2(-1, 0), i16vec2(0, 1), i16vec2(0, -1) };
	for(int i = 0; i < 4; i++)
	{
		if((state & uint8_t(1<<i)) != uint8_t(0))
		{
			continue;
		}

		ivec2 access = ivec2(current + g_offset[i]);
		int access_1d = access.x + access.y * constant.reso.x;


		int bit = 1<<(access_1d % 32);
		if((atomicOr(b_close[access_1d / 32], bit) & bit) != 0)
		{
			continue;
		}

		s_active[atomicAdd(s_active_counter[0], 1) % s_active.length()] = i16vec2(access);
	}
#else
	// ほんのちょっと高速化 
	ivec4 ok = ivec4(equal(u8vec4(state)&(u8vec4(1)<<u8vec4(0,1,2,3)), u8vec4(0)));

	ivec4 access_x = ivec4(current.xxxx) + ivec4(1, -1, 0, 0);
	ivec4 access_y = ivec4(current.yyyy) + ivec4(0, 0, 1, -1);
	ivec4 access_1d = access_x + access_y * constant.reso.xxxx;

	ivec4 map_index = access_1d / 32;
	ivec4 bit = ivec4(1)<<(access_1d % 32);
	for(int i = 0; i < 4; i ++)
	{
		if(ok[i]==0){continue;}
		ok[i] = int((atomicOr(b_close[map_index[i]], bit[i]) & bit[i]) == 0);
	}

	int num = ok.x+ok.y+ok.z+ok.w;
	if(num == 0) { return; }
	uint index = atomicAdd(s_active_counter[0], num);

	uint count = 0;
	for(int i = 0; i < 4; i++)
	{
		if(ok[i]==0){continue;}
		s_active[(index+count) % s_active.length()] = i16vec2(access_x[i], access_y[i]);
		count++;
	}
#endif
}
void main() 
{
	for(uint i = gl_LocalInvocationIndex; i < constant.reso.x*constant.reso.y/32; i+=gl_WorkGroupSize.x)
	{
		b_close[i] = 0;
	}
	if(gl_LocalInvocationIndex == 0)
	{
		s_active_counter = uvec2(0);
	}

	barrier();
	memoryBarrierShared();
	memoryBarrierBuffer();

	if(gl_LocalInvocationIndex < constant.num.x)
	{
		path(constant.target[gl_LocalInvocationIndex]);
	}
	if(gl_LocalInvocationIndex < constant.num.y)
	{
		path(constant.random_serch[gl_LocalInvocationIndex]);
	}

	for(int i = 0; i < 10000; i++)
	{
		barrier();
		memoryBarrierShared();

		uint accum = s_active_counter[0];
		uint consume = s_active_counter[1];
		uint count = min(accum-consume, gl_WorkGroupSize.x);
		if(count == 0){ break; }

		bool is_active = gl_LocalInvocationIndex < count;
		i16vec2 open = is_active ? s_active[(consume+gl_LocalInvocationIndex) % s_active.length()] : i16vec2(0);

		barrier();

		if(gl_LocalInvocationIndex == 0)
		{
			s_active_counter[1] += count;
		}

		if(is_active)
		{
			path(open);
		}
	}

}
