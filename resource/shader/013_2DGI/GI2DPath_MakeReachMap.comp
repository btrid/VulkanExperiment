#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Path 1
#include "GI2D.glsl"
#include "GI2DPath.glsl"

layout (local_size_x = 1024) in;

layout(push_constant) uniform InputVertex
{
	ivec2 reso;
	i16vec2 target[2];
} constant;

i16vec2 g_offset[4] = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };

shared i16vec2 s_active[4000];
shared int s_active_counter[2];

void path(in i16vec2 current)
{
	for(int i = 0; i < 4; i++)
	{
		i16vec2 access = current + g_offset[i];
		if (any(lessThan(access, ivec2(0))) || any(greaterThanEqual(access, constant.reso)))
		{
			continue;
		}

		int access_1d = access.x + access.y * constant.reso.x;
		int bit = 1<<(access_1d % 32);
		if((atomicOr(b_close[access_1d / 32], bit) & bit) != 0)
		{
			continue;
		}

		s_active[atomicAdd(s_active_counter[0], 1) % s_active.length()] = access;
	}
}
void main() 
{
	for(uint i = gl_LocalInvocationIndex; i < constant.reso.x*constant.reso.y/32; i+=gl_NumWorkGroups.x)
	{
		b_close[i] = 0;
	}
	if(gl_LocalInvocationIndex < 2)
	{
		s_active_counter[gl_LocalInvocationIndex] = 0;
	}

	barrier();
	memoryBarrierShared();
	memoryBarrierBuffer();

	if(gl_LocalInvocationIndex < 1)
	{
		path(constant.target[gl_LocalInvocationIndex]);
	}

	for(int i = 0; i < 10000; i++)
	{
		barrier();
		memoryBarrierShared();
		int accum = s_active_counter[0];
		int consume = s_active_counter[1];
		if(accum==consume){ break; }
		bool is_active = gl_LocalInvocationIndex < (accum - consume);
		i16vec2 open = s_active[(consume + gl_LocalInvocationIndex) % s_active.length()];

		barrier();

		if(gl_LocalInvocationIndex == 0)
		{
			s_active_counter[1] += min(accum - consume, int(gl_NumWorkGroups.x));
		}

//		barrier();
//		memoryBarrierShared();

		if(is_active)
		{
			path(open);
		}
	}

}

//b_diffuse_map[store]

