#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Path 1
#include "GI2D.glsl"
#include "GI2DPath.glsl"

layout (local_size_x = 1024) in;

layout(push_constant, std430) uniform InputVertex
{
	ivec2 reso;
	i16vec2 num;
	i16vec2 _p;
	i16vec2 target[4];
	i16vec2 random_search[3];
} constant;


shared i16vec2 s_active[1024*11];
shared uvec2 s_active_counter;

void path(in i16vec2 current)
{
	uint8_t state = b_state[current.x + current.y * constant.reso.x];

#if 0
	const ivec2 g_offset[4] = { ivec2(1, 0), ivec2(-1, 0), ivec2(0, 1), ivec2(0, -1) };
	for(int i = 0; i < 4; i++)
	{
		if((state & uint8_t(1<<i)) != uint8_t(0))
		{
			continue;
		}

		ivec2 access = ivec2(current + g_offset[i]);
		int access_1d = access.x + access.y * constant.reso.x;


		int bit = 1<<(access_1d % 32);
		if((atomicOr(b_close[access_1d / 32], bit) & bit) != 0)
		{
			continue;
		}

		s_active[atomicAdd(s_active_counter[0], 1) % s_active.length()] = i16vec2(access);
	}
#else
	// ほんのちょっと高速化 

	ivec4 access_x1 = ivec4(current.xxxx) + ivec4(0, 1, 0, -1);
	ivec4 access_y1 = ivec4(current.yyyy) + ivec4(-1, 0, 1, 0);
//	ivec4 access_x2 = ivec4(current.xxxx) + ivec4(1, 1, -1, -1);
//	ivec4 access_y2 = ivec4(current.yyyy) + ivec4(-1, 1, 1, -1);

//	ivec4 ok1 = ivec4(equal(u8vec4(state)&(u8vec4(1)<<u8vec4(0,1,2,3)), u8vec4(0)));
	ivec4 ok1 = ivec4(equal(u8vec4(state)&(u8vec4(1)<<u8vec4(1,3,5,7)), u8vec4(0)));
//	ivec4 ok2 = ivec4(equal(u8vec4(state)&(u8vec4(1)<<u8vec4(4,5,6,7)), u8vec4(0)));
	ivec4 ok2 = ivec4(0);
	{
		ivec4 access_1d = access_x1 + access_y1 * constant.reso.xxxx;
		ivec4 map_index = access_1d / 32;
		ivec4 bit = ivec4(1)<<(access_1d % 32);
		for(int i = 0; i < 4; i ++)
		{
			if(ok1[i]==0){continue;}
			ok1[i] = int((atomicOr(b_close[map_index[i]], bit[i]) & bit[i]) == 0);
		}
		
	}
/*	{
		ivec4 access_1d = access_x2 + access_y2 * constant.reso.xxxx;
		ivec4 map_index = access_1d / 32;
		ivec4 bit = ivec4(1)<<(access_1d % 32);
		for(int i = 0; i < 4; i ++)
		{
			if(ok2[i]==0){continue;}
			ok2[i] = int((atomicOr(b_close[map_index[i]], bit[i]) & bit[i]) == 0);
		}
		
	}
*/
	int num = ok1.x+ok1.y+ok1.z+ok1.w;
	num += ok2.x+ok2.y+ok2.z+ok2.w;
	if(num == 0) { return; }
	uint index = atomicAdd(s_active_counter[0], num);

	for(int i = 0; i < 4; i++)
	{
		if(ok1[i]==0){continue;}
		s_active[index++ % s_active.length()] = i16vec2(access_x1[i], access_y1[i]);
	}
/*	for(int i = 0; i < 4; i++)
	{
		if(ok2[i]==0){continue;}
		s_active[index++ % s_active.length()] = i16vec2(access_x2[i], access_y2[i]);
	}
*/
#endif
}
void main() 
{
	for(uint i = gl_LocalInvocationIndex; i < constant.reso.x*constant.reso.y/32; i+=gl_WorkGroupSize.x)
	{
		b_close[i] = 0;
	}
	if(gl_LocalInvocationIndex == 0)
	{
		s_active_counter = uvec2(0);
	}

	barrier();
	memoryBarrierShared();
	memoryBarrierBuffer();

	if(gl_LocalInvocationIndex < constant.num.x)
	{
		path(constant.target[gl_LocalInvocationIndex]);
	}
	if(gl_LocalInvocationIndex < constant.num.y)
	{
		path(constant.random_search[gl_LocalInvocationIndex]);
	}

	for(int i = 0; i < 10000; i++)
	{
		barrier();
		memoryBarrierShared();

		uint accum = s_active_counter[0];
		uint consume = s_active_counter[1];
		uint count = min(accum-consume, gl_WorkGroupSize.x);
		if(count == 0){ break; }

		bool is_active = gl_LocalInvocationIndex < count;
		i16vec2 open = is_active ? s_active[(consume+gl_LocalInvocationIndex) % s_active.length()] : i16vec2(0);

		barrier();

		if(gl_LocalInvocationIndex == 0)
		{
			s_active_counter[1] += count;
		}

		if(is_active)
		{
			path(open);
		}
	}

}
