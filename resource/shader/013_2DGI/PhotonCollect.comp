#version 450

#extension GL_GOOGLE_cpp_style_line_directive : require

#include <btrlib/ConvertDimension.glsl>
#include <btrlib/Common.glsl>
#include <btrlib/Math.glsl>

#define USE_PM 0
#define USE_PM_RENDER 1
#include <PM.glsl>

/*
layout(push_constant) uniform BounceInfo
{
	int bounce_count;
	int store_photon_index;
} constant;
*/
#define u16_max (0xffff)
#define fragment_state_non (0)
#define fragment_state_wall (1)
#define fragment_state_light (2)
#define fragment_state_bounce (3)
#define fragment_state_bounce_hit (4)

layout (local_size_x = 8, local_size_y = 8) in;

shared uint64_t ishit[1];
void main()
{
	if(gl_LocalInvocationIndex < 1){
		ishit[gl_LocalInvocationIndex] = b_emission_reached[gl_WorkGroupID.x + gl_WorkGroupID.y*gl_NumWorkGroups.x];
	}

	barrier();
	memoryBarrierShared();
	vec3 illuminance = vec3(0.);

	vec2 end = vec2(gl_GlobalInvocationID.xy);

	const ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
	const ivec2 tile_index_2d = pixel / ivec2(u_pm_info.m_emission_tile_size.xy);
	const int tile_index = int(tile_index_2d.x + tile_index_2d.y*u_pm_info.m_emission_tile_num.x);
	for(int i = b_emission_tile_linkhead[tile_index]; i != -1; i= b_emission_tile_linklist[i].next)
	{
		Emission light;
		vec2 start;
		{
			int emission_index = b_emission_tile_linklist[i].target;
//			int eoffset = u_pm_info.m_emission_buffer_offset[constant.bounce_count];
			light = b_emission[emission_index];
//			ivec2 e_index_2d = ivec2(emission_index%bounce_reso.x, emission_index/bounce_reso.x);
			ivec2 e_index_2d = ivec2(emission_index%u_pm_info.m_resolution.x, emission_index/u_pm_info.m_resolution.x);
			start = vec2(e_index_2d/*<<constant.bounce_count*/);
		}
	
		const vec2 diff = (end - start);
		const float ray_dist = length(diff.xy);
		vec3 radiance = (light.emission.xyz / (1.+ray_dist*ray_dist));
		uint64_t bit_mask = uint64_t(1) << gl_LocalInvocationIndex;
		illuminance += ((ishit[0]&bit_mask) != 0) ? radiance : vec3(0.) ;
	}

	imageStore(t_color[0], pixel, illuminance.xyzz);
}
