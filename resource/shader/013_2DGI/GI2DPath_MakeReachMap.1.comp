#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Path 1
#include "GI2D.glsl"
#include "GI2DPath.glsl"

layout (local_size_x = 1024) in;

layout(push_constant) uniform InputVertex
{
	ivec2 reso;
	i16vec2 target[2];
} constant;


shared i16vec2 s_active[1024][2];
shared ivec2 s_active_counter;
shared int s_frame;

void path(in i16vec2 current)
{
	uint8_t state = b_state[current.x + current.y * constant.reso.x];
	const i16vec2 g_offset[4] = { i16vec2(1, 0), i16vec2(-1, 0), i16vec2(0, 1), i16vec2(0, -1) };
	for(int i = 0; i < 4; i++)
	{
		if((state & uint8_t(1<<i)) != uint8_t(0))
		{
			continue;
		}

		ivec2 access = ivec2(current + g_offset[i]);
		int access_1d = access.x + access.y * constant.reso.x;


		int bit = 1<<(access_1d % 32);
		if((atomicOr(b_close[access_1d / 32], bit) & bit) != 0)
		{
			continue;
		}

		s_active[s_frame][atomicAdd(s_active_counter[s_frame], 1)] = i16vec2(access);
	}
/*

	ivec4 ok = ivec4(notEqual(u8vec4(state)&(u8vec4(1)<<u8vec4(0,1,2,3)), u8vec4(0)));

	ivec4 access_x = ivec4(current.xxxx) + ivec4(1, -1, 0, 0);
	ivec4 access_y = ivec4(current.yyyy) + ivec4(0, 0, 1, -1);
	ivec4 access_1d = access_x + access_y * constant.reso.xxxx;

	ivec4 map_index = access_1d / 32;
	ivec4 bit = ivec4(1)<<(access_1d % 32);
	for(int i = 0; i < 4; i ++)
	{
		if(ok[i]==0){continue;}
		ok[i] = int((atomicOr(b_close[map_index[i]], bit[i]) & bit[i]) != 0);
	}

	int num = ok.x+ok.y+ok.z+ok.w;
	if(num == 0) { return; }
	int index = atomicAdd(s_active_counter[s_frame], num);

	int count = 0;
	for(int i = 0; i < 4; i++)
	{
		if(ok[i]==0){continue;}
		s_active[s_frame][index+count] = i16vec2(access_x[i], access_y[i]);
		count++;
	}
*/
}
void main() 
{
	for(uint i = gl_LocalInvocationIndex; i < constant.reso.x*constant.reso.y/32; i+=gl_NumWorkGroups.x)
	{
		b_close[i] = 0;
	}
	if(gl_LocalInvocationIndex == 0)
	{
		s_active_counter = ivec2(0);
		s_frame = 0;
	}

	barrier();
	memoryBarrierShared();
	memoryBarrierBuffer();

	if(gl_LocalInvocationIndex < 2)
	{
		path(constant.target[gl_LocalInvocationIndex]);
	}

	for(int i = 0; i < 10000; i++)
	{
		barrier();
		memoryBarrierShared();

		int count = s_active_counter[s_frame];
		if(count == 0){ break; }

		bool is_active = gl_LocalInvocationIndex < count;
		i16vec2 open = s_active[s_frame][gl_LocalInvocationIndex];

		barrier();
//		memoryBarrierShared();

		if(gl_LocalInvocationIndex == 0)
		{
			s_frame = (s_frame + 1) % 2;
			s_active_counter[s_frame] = 0;
		}

		barrier();
		memoryBarrierShared();

		if(is_active)
		{
			path(open);
		}
	}

}
