#version 450

#extension GL_GOOGLE_cpp_style_line_directive : require
#extension GL_ARB_gpu_shader_int64 : require

#include <btrlib/ConvertDimension.glsl>
#include <btrlib/Common.glsl>
#include <btrlib/Math.glsl>

#define USE_PM 0
#include <PM.glsl>

layout(push_constant) uniform InputVertex
{
	int level;
} constant;

layout (local_size_x = 32, local_size_y = 32) in;

shared uint s_bit[16][2];
void main()
{
	if(any(greaterThan(gl_GlobalInvocationID.xy, u_pm_info.m_resolution.xy>>(constant.level-1)))){
		return;
	}

	// fragment hierarchy
	int level = constant.level;
	int prev_level = constant.level-1;
	{
		{
			uvec2 local = gl_LocalInvocationID.xy / 8;
			uint index = local.x+local.y*4;
			uvec2 localsub = gl_LocalInvocationID.xy % 8;
			if(all(equal(localsub, uvec2(0))))
			{
				s_bit[index][0] = 0;
				s_bit[index][1] = 0;
			}
			barrier();
			memoryBarrierShared();
	
			{
				uvec2 idx2d = gl_GlobalInvocationID.xy;
				uint prev_store = idx2d.x+idx2d.y*(u_pm_info.m_resolution.x/(8<<prev_level));
				int prev_offset = getFragmentMapHierarchyOffset(prev_level);
				uint64_t fragment = b_fragment_map[prev_offset + prev_store];

				uvec2 localsub = gl_LocalInvocationID.xy / 2;
				uvec2 localsubsub = gl_LocalInvocationID.xy % 2;
				uvec2 local_ = localsub+localsubsub;
				uint bit = local_.x + local_.y*8;
				if((fragment & bit) != 0)
				{
					uint hilow = bit/32;
					uint offset = bit%32;
					atomicOr(s_bit[index][hilow], 1<<offset);
				}
				barrier();
				memoryBarrierShared();
			}
	
			if(all(equal(localsub, uvec2(0))))
			{
				uint64_t bit =  uint64_t(s_bit[index][1]) << 32 | s_bit[index][0];
				uvec2 global = gl_GlobalInvocationID.xy/2;
				uint store = global.x + global.y*u_pm_info.m_resolution.x/(8<<constant.level);

				int offset = getFragmentMapHierarchyOffset(level);
				b_fragment_map[store+offset] = bit;

			}
		}
	}
}

