#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Path 1
#include "GI2D.glsl"
#include "GI2DPath.glsl"

layout (local_size_x = 1024) in;

#define isOn(_bit, _test) (((_bit) & (_test)) != 0)

layout(push_constant, std430) uniform InputVertex
{
	ivec2 reso;
	i16vec2 num;
	i16vec2 _p;
	i16vec2 target[4];
	i16vec2 random_search[3];
} constant;


ivec2 neighor_list[] =
{
	ivec2(-1, -1),
	ivec2( 0, -1),
	ivec2( 1, -1),
	ivec2( 1,  0),
	ivec2( 1,  1),
	ivec2( 0,  1),
	ivec2(-1,  1),
	ivec2(-1,  0),
};
u8vec4 neighor_check_list[] =
{
	u8vec4(2,3,6,5), // diagonal
	u8vec4(1,2,7,6), // straight
};

//shared uint s_diagonal[128];
//shared uint s_straight[1024*4];
//shared uvec4 s_active_counter;
shared uint s_active[1024*11+1000];
shared uvec2 s_active_counter;

void exploreImpl(in ivec2 pos, in uint8_t dir_type)
{
	ivec2 dir = neighor_list[int(dir_type)];
	uint8_t n = uint8_t(0);
//	do
	while ((n & (1 << dir_type)) == 0)
	{
		pos += dir;

		int index = pos.x + pos.y * constant.reso.x;
		n = b_neighbor[index];
		u8vec2 neighbor = u8vec2(~n, n);

		uint8_t close_bit = uint8_t(1) << (dir_type % 4);
		if ((atomicOr(b_closed_state[index], close_bit) & close_bit) != 0)
		{
			continue;
		}


		if((dir_type % 2) == 0)
		{
			// 縦横方向にもチェック
			u8vec2 straight_type = u8vec2((ivec2(dir_type) + ivec2(7,9)) % 8);
			u8vec2 straight_bit = u8vec2(1)<<straight_type;

			uvec2 is_open = uvec2(notEqual(neighbor.xx & straight_bit, u8vec2(0)));
			uint num = is_open.x+is_open.y;
			if(num != 0)
			{
				uint active_index = atomicAdd(s_active_counter[0], num);
				for(int i = 0; i < 2; i++)
				{
					if(is_open[i]==0){ continue; }
					s_active[active_index++ % s_active.length()] = pos.x | (pos.y<<14) | (straight_type[i] << 28);
				}
			}

		}

		{
			u8vec4 diagonal_type = ((u8vec4(dir_type) + neighor_check_list[dir_type%2]) % u8vec4(8));
			bvec4 is_biton = notEqual(neighbor.xyxy & (u8vec4(1) << diagonal_type), u8vec4(0));
			uvec2 is_forcedneighbor = uvec2(all(is_biton.xy), all(is_biton.zw));
			uint num = is_forcedneighbor.x + is_forcedneighbor.y;
			if (num != 0)
			{
				uint active_index = atomicAdd(s_active_counter[0], num);
				for(int i = 0; i < 2; i++)
				{
					if(is_forcedneighbor[i]==0){ continue; }
					s_active[active_index++ % s_active.length()] = pos.x | (pos.y<<14) | (diagonal_type[i*2] << 28);
				}

			}

		}

//	} while (!isOn(n, 1 << dir_type));
//	} while ((n & (1 << dir_type)) != 0);
	}
}

void explore(in ivec2 pos)
{
	for (uint8_t neighbor = ~b_neighbor[pos.x + pos.y * constant.reso.x]; neighbor != 0;)
	{
		uint8_t dir_type = uint8_t(findLSB(neighbor));
		neighbor &= ~(uint8_t(1)<<dir_type);

		exploreImpl(pos, dir_type);
	}
}

void main() 
{
	for(uint i = gl_LocalInvocationIndex; i < constant.reso.x*constant.reso.y/32; i+=gl_WorkGroupSize.x)
	{
		b_closed[i] = 0;
	}
	for(uint i = gl_LocalInvocationIndex; i < constant.reso.x*constant.reso.y; i+=gl_WorkGroupSize.x)
	{
		b_closed_state[i] = 0;
	}
	
	if(gl_LocalInvocationIndex == 0)
	{
		s_active_counter = uvec2(0);
	}

	barrier();
	memoryBarrierShared();
	memoryBarrierBuffer();

	if(gl_LocalInvocationIndex < constant.num.x)
	{
		explore(ivec2(constant.target[gl_LocalInvocationIndex]));
	}
	if(gl_LocalInvocationIndex < constant.num.y)
	{
//		explore(constant.random_search[gl_LocalInvocationIndex]);
	}

	for(int i = 0; i < 1; i++)
	{
		barrier();
		memoryBarrierShared();

		uint accum = s_active_counter[0];
		uint consume = s_active_counter[1];
		uint count = min(accum-consume, gl_WorkGroupSize.x);
		if(count == 0){ break; }

		bool is_active = gl_LocalInvocationIndex < count;
		uint open = is_active ? s_active[(consume+gl_LocalInvocationIndex) % s_active.length()] : 0;

		barrier();

		if(gl_LocalInvocationIndex == 0)
		{
			s_active_counter[1] += count;
		}

		if(is_active)
		{
			ivec2 pos = ivec2(open, open>>14) & ((1<<14)-1);
			uint8_t dir_type = uint8_t((open>>28)& 7);
			exploreImpl(pos, dir_type);
		}
	}

}
