#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Path 1
#include "GI2D.glsl"
#include "GI2DPath.glsl"

layout (local_size_x = 1024) in;

layout(push_constant, std430) uniform InputVertex
{
	ivec2 reso;
	i16vec2 num;
	i16vec2 _p;
	i16vec2 target[4];
	i16vec2 random_search[3];
} constant;


ivec2 neighor_list[] =
{
	ivec2(-1, -1),
	ivec2( 0, -1),
	ivec2( 1, -1),
	ivec2( 1,  0),
	ivec2( 1,  1),
	ivec2( 0,  1),
	ivec2(-1,  1),
	ivec2(-1,  0),
};
struct OpenNode2
{
	i16vec2 index;
	uint8_t dir_bit;
};

shared uint s_diagonal[128];
shared uint s_straight[1024*4];
shared uvec4 s_active_counter;

void exploreStraight(in ivec2 pos, in ivec2 dir)
{
	auto current = node.index;
	for (int i = 0; true; i++)
	{
		current += dir_;
		uint n = close[current.x + current.y * path.m_desc.m_size.x].neighbor_state;
		u8vec2 neighbor(~n, n);
		close[current.x + current.y * path.m_desc.m_size.x].is_closed = 1;

		u8vec4 bit_mask = u8vec4(1) << ((u8vec4(dir_type) + u8vec4(1,2,7,6)) % u8vec4(8));
		bvec4 is_biton = notEqual(neighbor.xyxy() & bit_mask, u8vec4(0));
		bvec2 is_forcedneighbor = bvec2(all(is_biton.xy()), all(is_biton.zw()));
		if (any(is_forcedneighbor) && !close[current.x + current.y * path.m_desc.m_size.x].is_open)
		{
			// forced neighbor
			// 遮蔽物があるのでここから再捜査
			OpenNode2 open_node;
			open_node.index = current;
			open_node.dir_bit = (1<<dir_type);
			open_node.dir_bit |= is_forcedneighbor.x ? bit_mask.x : 0;
			open_node.dir_bit |= is_forcedneighbor.y ? bit_mask.z : 0;
			open.push_back(open_node);
			close[current.x + current.y * path.m_desc.m_size.x].is_open = 1;
		}
		if (btr::isOn(neighbor.y, 1 << dir_type))
		{
			// 直線は進行方向に進めなければ終了
			break;
		}

	}

}

void main() 
{
	for(uint i = gl_LocalInvocationIndex; i < constant.reso.x*constant.reso.y/32; i+=gl_WorkGroupSize.x)
	{
		b_closed[i] = 0;
	}
	if(gl_LocalInvocationIndex == 0)
	{
		s_active_counter = uvec4(0);
	}

	barrier();
	memoryBarrierShared();
	memoryBarrierBuffer();

	if(gl_LocalInvocationIndex < constant.num.x)
	{
		path(constant.target[gl_LocalInvocationIndex]);
	}
	if(gl_LocalInvocationIndex < constant.num.y)
	{
		path(constant.random_search[gl_LocalInvocationIndex]);
	}

	for(int i = 0; i < 10000; i++)
	{
		barrier();
		memoryBarrierShared();

		uint accum = s_active_counter[0];
		uint consume = s_active_counter[1];
		uint count = min(accum-consume, gl_WorkGroupSize.x);
		if(count == 0){ break; }

		bool is_active = gl_LocalInvocationIndex < count;
		i16vec2 open = is_active ? s_active[(consume+gl_LocalInvocationIndex) % s_active.length()] : i16vec2(0);

		barrier();

		if(gl_LocalInvocationIndex == 0)
		{
			s_active_counter[1] += count;
		}

		if(is_active)
		{
			path(open);
		}
	}

}
