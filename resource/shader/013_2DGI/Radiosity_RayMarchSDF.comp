#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#define USE_GI2D_SDF 2
#include "GI2D.glsl"
#include "GI2DSDF.glsl"

layout (local_size_x=1024) in;
void main()
{
	if(gl_GlobalInvocationID.x >= b_ray_counter[u_gi2d_scene.m_frame].w){ return; }

	const ivec4 reso = u_gi2d_info.m_resolution;

	uint ray_index = gl_GlobalInvocationID.x + u_radiosity_info.ray_frame_max*u_gi2d_scene.m_frame;
	D2Ray ray = b_ray[ray_index];
	vec2 dir = calcDir(ray.angle);

	ivec2 map_index = ivec2(ray.origin);
	float old_sdf = b_sdf[map_index.x + map_index.y*reso.x];

	D2Segment seg;
	seg.ray_index = ray_index;
	seg.begin = 0.;
	seg.march = 0.;
	seg.radiance = 0;
	float march_count = abs(old_sdf);
	map_index = ivec2(fma(dir, vec2(march_count), ray.origin));

	for(; march_count < ray.march-1; )
	{
		ivec2 is_die = ivec2(greaterThanEqual(map_index, reso.xy)) + ivec2(lessThan(map_index, ivec2(0)));
		if(any(notEqual(is_die.xy, ivec2(0))))
		{
			break;
		}

		float sdf = b_sdf[map_index.x + map_index.y*reso.x];

		if(sign(old_sdf) != sign(sdf))
		{
			if(sign(sdf) < 0.)
			{
				// 中へ入った
				int index = atomicAdd(b_segment_counter.w, 1);
				if(index%1024==0){
					atomicAdd(b_segment_counter.x, 1);
				}
				b_segment[index] = seg;
			}
			else
			{
				// 外へ出た
				seg.begin = march_count - 1.;
				seg.march = 1.;

			}
		}
		else if(sign(sdf) > 0.)
		{
			seg.march += abs(sdf);
		}

		// march
		{
			old_sdf = sdf;
			march_count += abs(sdf);
			map_index = ivec2(fma(dir, vec2(march_count), ray.origin));
		}

	}

	// 行きすぎたら戻す
//	seg.march -= march_count-ray.march;
//	if(seg.march > 1)
	{
//		int index = atomicAdd(b_segment_counter.w, 1);
//		if(index%1024==0){
//			atomicAdd(b_segment_counter.x, 1);
//		}
//		b_segment[index] = seg;
	}


}
