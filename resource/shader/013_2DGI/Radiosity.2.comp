// セルをスキップしないレイトレ
#version 450
#extension GL_GOOGLE_include_directive : require

#include "btrlib/ConvertDimension.glsl"
#include "btrlib/Common.glsl"
#include "btrlib/Math.glsl"

#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#include "GI2D.glsl"

layout (local_size_x = 1024, local_size_y = 1) in;
void main()
{
	if(gl_GlobalInvocationID.x >= b_ray_counter.w){ return; }

	const int hierarchy = u_gi2d_scene.m_hierarchy;
	const ivec4 reso = ivec4(u_gi2d_info.m_resolution.xy, u_gi2d_info.m_resolution.xy/8);

	D2Ray ray = b_ray[gl_GlobalInvocationID.x];
	vec2 pos = ray.origin;
	vec2 dir = rotate(ray.angle);
	vec2 inv_dir;
	inv_dir.x = dir.x == 0. ? 99999999. : abs(1./dir.x);
	inv_dir.y = dir.y == 0. ? 99999999. : abs(1./dir.y);

	ivec2 map_index = ivec2(pos);

	uint u_radiance = uint(0);
	uint64_t d;
	uint old_diffuse_index = -1;
	uint skip = u_gi2d_scene.m_skip;
	uint radiance_offset = u_gi2d_scene.m_radiance_offset*u_gi2d_scene.m_frame;
	dir *= min(inv_dir.x, inv_dir.y) * (1<<hierarchy);

	for(int _i = 0; _i < 5000; _i++)
	{
		// hit確認
		{
			// 拡散
			ivec2 cell = map_index/8;
			uint dindex = cell.x + cell.y*reso.z;
			// 更新
			if(old_diffuse_index != dindex) { d = b_diffuse_map[dindex]; }
			old_diffuse_index = dindex;

			ivec2 cell_sub = map_index - cell*8;
			if((d & (1ul<<(cell_sub.x+cell_sub.y*8))) != 0){ u_radiance = 0; }
		}

		// lighting
		{
			uint radiance_cell = getMemoryOrder(map_index);
			u_radiance != 0 ? atomicAdd(b_radiance[radiance_offset + radiance_cell], u_radiance) : 0;

			uint light_cell = getMemoryOrder(map_index);
			u_radiance += b_light[light_cell];

		}
		// march
		{
			// DDA
			pos += dir;
			map_index = ivec2(pos);
		}
		// 範囲外?
		{
			ivec2 is_die = ivec2(greaterThanEqual(map_index, reso.xy)) + ivec2(lessThan(map_index, ivec2(0)));
			if(any(notEqual(is_die.xy, ivec2(0))))
			{
				break;
			}
		}
	}
}
