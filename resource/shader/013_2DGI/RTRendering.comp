#version 450
#extension GL_GOOGLE_include_directive : require

#include "btrlib/ConvertDimension.glsl"
#include "btrlib/Common.glsl"
#include "btrlib/Math.glsl"

#define USE_PM 0
#define USE_RT 1
#include "PM.glsl"

layout (local_size_x = 32, local_size_y = 32) in;

shared uint64_t s_light_map[512];
void main()
{
	const ivec4 reso = ivec4(u_pm_info.m_resolution.xy, u_pm_info.m_resolution.xy/8);
	const ivec2 rt_reso = reso.zw / 2;
	uint rt_map_size = rt_reso.x*rt_reso.y;
//	uint rt_tile_index = gl_GlobalInvocationID.x/8+gl_GlobalInvocationID.y/8*reso.z;
	uint rt_tile_index = gl_GlobalInvocationID.x/16 + (gl_GlobalInvocationID.y/16)*rt_reso.x;

	ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
	ivec4 fragment_index = ivec4(pixel/8, pixel%8);
	int tindex = fragment_index.x + fragment_index.y *reso.z;
	int rela_light_index_1d = int(gl_LocalInvocationID.x/8 + (gl_LocalInvocationID.y/8)*4);
#if 0
	ivec4 offset = ivec4(-1,0,-1,0) + ivec4(greaterThanEqual(gl_LocalInvocationID.xxyy%8, uvec4(4)));
	ivec2 shift = (ivec2(4) + ivec2(gl_LocalInvocationID.xy)) % ivec2(8);
	uint64_t bit_mask = 1ul << (8*4+4);
#else
	ivec4 offset = ivec4(0);
	ivec2 shift = ivec2(0);
	uint64_t bit_mask = 1ul << (gl_LocalInvocationIndex%64);
#endif
	ivec4 findex = fragment_index.xxxx + offset.xxyy + (fragment_index.yyyy + offset.zwzw)*(reso.zzzz);

	uint64_t x_line_mask = 0xfful & ((1ul << (shift.x)) - 1ul);
	uint64_t x_mask = ~(x_line_mask | (x_line_mask << 8) | (x_line_mask << 16) | (x_line_mask << 24) | (x_line_mask << 32) | (x_line_mask << 40) | (x_line_mask << 48) | (x_line_mask << 56));
	uint64_t y_mask = ~(0xfffffffffffffffful & ((1ul << ((shift.y) * 8)) - 1));
	u64vec4 map_mask = u64vec4(x_mask & y_mask, x_mask & ~y_mask, ~x_mask & y_mask, ~x_mask & ~y_mask);
	ivec4 right_shift = shift.yyyy*ivec4(8,0,8,0) + shift.xxxx*ivec4(1,1,0,0);
	ivec4 left_shift = (8-shift.yyyy)*ivec4(0,8,0,8) + (8-shift.xxxx)*ivec4(0,0,1,1);

	u64vec4 bit_mask4 = u64vec4(bit_mask);

	const ivec2 tile_index_2d = pixel / ivec2(u_pm_info.m_emission_tile_size.xy);
	const int tile_index = int(tile_index_2d.x + tile_index_2d.y*u_pm_info.m_emission_tile_num.x);
	int local_index = int(gl_LocalInvocationIndex);

	vec4 illuminance = vec4(0.);

	// 2x2マスずつ
	for(int y = 0; y < rt_reso.y; y++)
	{
		// 2列とる
		if(local_index < reso.z*4)
		{
			s_light_map[local_index] = b_light_map[local_index + (y*2)*reso.z];
		}
		barrier();
		memoryBarrierShared();

		for(int x = 0; x < rt_reso.x; x++)
		{
			u64vec4 light_map;
			light_map.x = s_light_map[x*2];
			light_map.y = s_light_map[x*2+1];
			light_map.z = s_light_map[x*2   + reso.z];
			light_map.w = s_light_map[x*2+1 + reso.z];
			u64vec4 light_power = popcnt44(light_map);

			uint rt = b_rt_data[rt_map_size*(x+y*rt_reso.x) + rt_tile_index];
			uvec4 rt_power = (uvec4(rt) >> uvec4(0, 8, 16, 24)) & uvec4(0xff);

			vec2 pos = vec2(x, y) * 16. + 8.;
			float dist = distance(pos, pixel);
			illuminance += vec4(rt_power) /(64.*64*2);

//			illuminance += vec4(light_power * rt_power) /(32.*4.) / (dist+1);
		}
		barrier();
	}

	uint64_t light_map = b_light_map[findex.x];
	bool is_light = (light_map & bit_mask) != 0;
	vec3 illumi = vec3(length(illuminance+0.01));
	illumi = is_light ? vec3(1., 0., 0.) : illumi;
	imageStore(t_color, pixel, vec4(illumi, 1.));

}
