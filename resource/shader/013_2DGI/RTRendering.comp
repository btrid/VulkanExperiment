#version 450
#extension GL_GOOGLE_include_directive : require

#include "btrlib/ConvertDimension.glsl"
#include "btrlib/Common.glsl"
#include "btrlib/Math.glsl"

#define USE_GI2D 0
#define USE_RT 1
#include "GI2D.glsl"

layout(push_constant) uniform BounceInfo
{
	int start_id;
	int frame;
} constant;

layout (local_size_x = 32, local_size_y = 32) in;

shared uint64_t s_light_map[512];
shared uint s_rt_map[32*32];
void main()
{
	const ivec4 reso = ivec4(u_gi2d_info.m_resolution.xy, u_gi2d_info.m_resolution.xy/8);
	const ivec2 rt_reso = reso.zw / 2;
	uint rt_map_size = rt_reso.x*rt_reso.y;

	ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
	ivec4 fragment_index = ivec4(pixel/8, pixel%8);

	vec4 illuminance = vec4(0.);
	uvec2 area = uvec2((4+2)*2);

	// 2x2マスずつ
	for(int y = 0; y < reso.w; y++)
	{
		barrier();
		memoryBarrierShared();
		// 2列とる
		if(gl_LocalInvocationIndex < reso.z)
		{
			s_light_map[gl_LocalInvocationIndex] = b_light_map[gl_LocalInvocationIndex + (y)*reso.z];
		}

		for(int x = 0; x < reso.z; x++)
		{
			uint light_offset = rt_map_size*(x+y*reso.z);
			if(all(lessThan(gl_LocalInvocationID.xy, area)))
			{
				ivec2 index_offset_2d = (ivec2(gl_WorkGroupID*gl_WorkGroupSize).xy/16) -1 + ivec2(gl_LocalInvocationID.xy/2);
				index_offset_2d = clamp(index_offset_2d, ivec2(0), rt_reso);
				uint index_offset = index_offset_2d.x+ index_offset_2d.y*rt_reso.x;
				uint rt = b_rt_data[light_offset + index_offset];
				uvec4 rt_power = (uvec4(rt) >> uvec4(0, 8, 16, 24)) & uvec4(0xff);

				uint i = gl_LocalInvocationID.x + gl_LocalInvocationID.y*area.x;
				uvec2 sub = gl_LocalInvocationID.xy%2;
				s_rt_map[i] = rt_power[sub.x + sub.y*2];
			}

			barrier();
			memoryBarrierShared();

			u64vec4 light_map;
			light_map.x = s_light_map[x];
//			light_map.y = s_light_map[x+1];
//			light_map.z = s_light_map[x   + reso.z];
//			light_map.w = s_light_map[x+1 + reso.z];
			uvec4 light_power = uvec4(popcnt(light_map.x));

			ivec2 rt_index = ivec2(gl_LocalInvocationID.xy+4)/8+1;
			uint x0 = s_rt_map[rt_index.x   + rt_index.y*area.x];
			uint x1 = s_rt_map[rt_index.x+1 + rt_index.y*area.x];
			uint y0 = s_rt_map[rt_index.x   + (rt_index.y+1)*area.x];
			uint y1 = s_rt_map[rt_index.x+1 + (rt_index.y+1)*area.x];
			uvec4 rt_power = uvec4(x0, x1, y0, y1);
			vec4 lp = vec4(light_power) * rt_power;
			vec2 rate = ((gl_LocalInvocationID.xy+4)%8) / 8.;
			vec2 px = mix(lp.xz, lp.yw, rate.xx);
			float p = mix(px.x, px.y, rate.y);

			vec2 pos = vec2(x, y) * 16. + 8.;
			float dist = distance(pos, pixel);
			illuminance += vec4(p) /(64.*2.);
//			illuminance += vec4(light_power);
		}
		barrier();
	}

//	uvec2 li = gl_GlobalInvocationID.xy / 8;
//	uint64_t light_p =  b_light_map[li.x + li.y*reso.z];
//	illuminance = vec4(light_p) /(64.);



//	ivec4 findex = fragment_index.xxxx + offset.xxyy + (fragment_index.yyyy + offset.zwzw)*(reso.zzzz);
//	uint64_t light_map = b_light_map[findex.x];
//	bool is_light = (light_map & bit_mask) != 0;
	vec3 illumi = vec3(length(illuminance+0.01));
//	illumi = is_light ? vec3(1., 0., 0.) : illumi;
//	illumi = all(equal(pixel/16, ivec2(x, y)*8/16)) ? vec3(0., 0., 1.) : illumi;
	imageStore(t_color, pixel, vec4(illumi, 1.));

}
