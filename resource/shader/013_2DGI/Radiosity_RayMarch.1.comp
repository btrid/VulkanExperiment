#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#include "GI2D.glsl"

#define HALF_PI radians(90.)
#define TWO_PI radians(360.)
#define PI radians(180.)
#define QUARTER_PI radians(45.)

layout (local_size_x=128) in;

bool intersection(in vec4 aabb, in vec2 pos, in vec2 inv_dir, out int n, out int f)
{
	vec4 t = ((aabb - pos.xyxy)*inv_dir.xyxy);
	vec2 tmin = min(t.xy, t.zw);
 	vec2 tmax = max(t.xy, t.zw);
 
	n = int(max(tmin.x, tmin.y));
	f = int(min(tmax.x, tmax.y));

 	return min(tmax.x, tmax.y) > max(max(tmin.x, tmin.y), 0.0);
}

struct Ray
{
	vec2 origin;
	vec2 dir;
	vec2 inv_dir;
	int march;
};

vec2 rotateEx(in float angle)
{
	float c = cos(angle);
	float s = sin(angle);
	return vec2(c, s);
}

void calcDirEx(in float angle, out vec2 dir, out vec2 inv_dir)
{
	dir = rotateEx(angle);
	dir.x = abs(dir.x)<GI2D_FLT_EPSILON ? 0.0001 : dir.x;
	dir.y = abs(dir.y)<GI2D_FLT_EPSILON ? 0.0001 : dir.y;
	inv_dir = 1./dir;
	dir = dir * min(abs(inv_dir.x), abs(inv_dir.y));
	inv_dir = 1./dir;
}
Ray makeRay(in uint x, in uint y)
{
	const ivec4 reso = u_gi2d_info.m_resolution;
	Ray ray;

	float a = PI / Dir_Num;
	float b = 0.;
	float angle = fma(a, float(y), a*0.5);
	uint area = uint(angle / HALF_PI);

	calcDirEx(angle, ray.dir, ray.inv_dir);

	ray.origin.x = 0.;
	ray.origin.y = 0.;
	int axis = abs(ray.inv_dir.x)<abs(ray.inv_dir.y)?1:0;
	if(x<1024)
	{
		ray.origin.y += min(int(ray.inv_dir.x), 1);
	}
	else
	{
		ray.origin.x += min(int(ray.inv_dir.y), 1);
	}

	ray.march = -1;
/*	int begin, end;
	vec4 aabb = vec4(vec2(0., 0.), vec2(reso.xy));
	if(intersection(aabb, ray.origin, ray.inv_dir, begin, end))
	{
		ray.origin = fma(ray.dir, vec2(begin+1), ray.origin);
		ray.march = end - begin -1;

		while(!any(equal(uvec4(ray.origin.xyxy), uvec4(0,0,reso.xy-1)))){}
		while(!any(equal(uvec4(fma(ray.dir.xyxy, float(ray.march).xxxx, ray.origin.xyxy)), uvec4(0,0,reso.xy-1)))){}

	}
*/	return ray;
}

void main()
{
	const ivec4 reso = u_gi2d_info.m_resolution;
	uint angle_index = gl_WorkGroupID.y;

	Ray ray = makeRay(gl_GlobalInvocationID.x, gl_WorkGroupID.y);

	vec2 cell_origin = vec2(greaterThanEqual(ray.dir, vec2(0.))) * vec2(8.);

	uint begin = 0;
	uint march = 0;

	for(;;)
	{
		vec2 pos = fma(ray.dir, float(march).xx, ray.origin);
		ivec2 map_index = ivec2(pos);
		if(any(lessThanEqual(map_index, ivec2(0))) || any(greaterThanEqual(map_index, reso.xy)))
		{
			break;
		}

		ivec2 cell = map_index>>3;
		vec2 pos_sub = vec2(pos - vec2(cell << 3));

		vec2 tp = fma(vec2(abs(cell_origin - pos_sub)), abs(ray.inv_dir), float(1.).xx);
		uint skip = uint(min(tp.x, tp.y));

		uint64_t map = b_edge[cell.x + cell.y * reso.z];
		if(map == 0ul)
		{
			march+=skip;
			continue;
		}

		for(uint i = 0; i < skip; i++)
		{
			ivec2 cell_sub = ivec2(pos_sub);
			bool attr = (map & (1ul<<(cell_sub.x+cell_sub.y*8))) != 0ul;
			if(attr)
			{
				u16vec4 end = u16vec4(fma(ray.dir.xyxy, vec4(float(begin).xx, float(march).xx), ray.origin.xyxy));

				uvec2 vi = end.xz + end.yw * reso.xx;
				uvec2 array_index = uvec2(b_vertex_array_index[vi.x], b_vertex_array_index[vi.y]);

				if(array_index.x != 0xffff)
					b_vertex_array[array_index.x].vertex[angle_index] = u16vec3(end.zw, array_index.y);
				if(array_index.y != 0xffff)
					b_vertex_array[array_index.y].vertex[angle_index+Dir_Num] = u16vec3(end.xy, array_index.x);

				begin = march;
			}
			march++;
			pos_sub = fma(ray.dir, vec2(1.), pos_sub);
		}

	}
/*
	u16vec4 end = u16vec4(fma(ray.dir.xyxy, vec4(float(begin).xx, float(ray.march).xx), ray.origin.xyxy));

	uvec2 vi = end.xz + end.yw * reso.xx;
	uvec2 array_index = uvec2(b_vertex_array_index[vi.x], b_vertex_array_index[vi.y]);
	if(array_index.x != 0xffff)
		b_vertex_array[array_index.x].vertex[angle_index] = u16vec3(end.zw, array_index.y);
	if(array_index.y != 0xffff)
		b_vertex_array[array_index.y].vertex[angle_index+Dir_Num] = u16vec3(end.xy, array_index.x);
*/

}
