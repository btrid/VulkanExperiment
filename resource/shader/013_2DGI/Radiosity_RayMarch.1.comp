#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#include "GI2D.glsl"

#define HALF_PI radians(90.)
#define TWO_PI radians(360.)
#define PI radians(180.)
#define QUARTER_PI radians(45.)

layout (local_size_x=128) in;


struct Ray
{
	vec2 origin;
	vec2 dir;
	vec2 inv_dir;
	int march;
	uint area;
};


bool intersection(in vec4 aabb, in vec2 pos, in vec2 inv_dir, out int n, out int f)
{
	vec4 t = ((aabb - pos.xyxy)*inv_dir.xyxy);
	vec2 tmin = min(t.xy, t.zw);
 	vec2 tmax = max(t.xy, t.zw);
 
	n = int(ceil(max(tmin.x, tmin.y)));
	f = int(min(tmax.x, tmax.y));

 	return min(tmax.x, tmax.y) > max(max(tmin.x, tmin.y), 0.0);
}

vec2 rotateEx(in float angle)
{
	float c = cos(angle);
	float s = sin(angle);
	return vec2(c, s);
}

void calcDirEx(in float angle, out vec2 dir, out vec2 inv_dir)
{
	dir = rotateEx(angle);
	dir.x = abs(dir.x)<GI2D_FLT_EPSILON ? (dir.x>=0.?0.0001:-0.0001) : dir.x;
	dir.y = abs(dir.y)<GI2D_FLT_EPSILON ? (dir.y>=0.?0.0001:-0.0001) : dir.y;
	inv_dir = 1./dir;
	dir = dir * min(abs(inv_dir.x), abs(inv_dir.y));
	inv_dir = 1./dir;
}
Ray makeRay(in uint x, in uint y)
{
	const ivec4 reso = u_gi2d_info.m_resolution;
	Ray ray;

	uint area = y/(gl_NumWorkGroups.y/2);
	y = y%(gl_NumWorkGroups.y/2);
	float a = HALF_PI /(gl_NumWorkGroups.y/2);
	float angle = fma(a, float(y), a*0.5);

	calcDirEx(angle, ray.dir, ray.inv_dir);

	ray.origin.x = 0.;
	ray.origin.y = 0.;
	if(x<1024)
	{
		ray.origin.y += int((abs(ray.inv_dir.x))) * x;
	}
	else
	{
		ray.origin.x += int((abs(ray.inv_dir.y))) * (x-1023);
	}
	ray.dir.x=abs(ray.dir.x);
	ray.inv_dir.x=abs(ray.inv_dir.x);

	ray.march = -1;
	int begin, end;
	vec4 aabb = vec4(vec2(0., 0.), vec2(reso.xy));
	if(intersection(aabb, ray.origin, ray.inv_dir, begin, end))
	{
		ray.origin = fma(ray.dir, vec2(begin), ray.origin);
		ray.march = end - begin;

		while(!any(equal(uvec4(ray.origin.xyxy), uvec4(0,0,reso.xy-1)))){}
		while(!any(equal(uvec4(fma(ray.dir.xyxy, float(ray.march-0.5).xxxx, ray.origin.xyxy)), uvec4(0,0,reso.xy-1)))){}

	}

	ray.area = area;
	return ray;
}

void main()
{
	if(gl_WorkGroupID.y >= (gl_NumWorkGroups.y/2)){ return; }
	const ivec4 reso = u_gi2d_info.m_resolution;
	uint angle_index = gl_WorkGroupID.y;

	Ray ray = makeRay(gl_GlobalInvocationID.x, gl_WorkGroupID.y);


	int begin = 0;
	int march = 0;

	for(; march < ray.march; )
	{
		vec2 pos = fma(ray.dir, float(march).xx, ray.origin);
		ivec2 map_index = ivec2(pos);

		ivec2 cell = map_index>>3;
		vec2 pos_sub = vec2(pos - vec2(cell << 3));

		vec2 tp = fma(vec2(8.) - pos_sub, abs(ray.inv_dir), float(1.).xx);
		int skip = int(min(tp.x, tp.y));

//		if(ray.area==1){cell.x = (reso.z)-cell.x;}
		if(ray.area==1){cell.x = (reso.z-1)-cell.x;}
		uint64_t map = b_edge[cell.x + cell.y * reso.z];
		if(map == 0ul)
		{
			march+=skip;
			continue;
		}

		for(int i = 0; i < skip; i++)
		{
			ivec2 cell_sub = ivec2(pos_sub);
//			if(ray.area==1){cell_sub.x = 8-cell_sub.x;}
			if(ray.area==1){cell_sub.x = 7-cell_sub.x;}

			bool attr = (map & (1ul<<(cell_sub.x+cell_sub.y*8))) != 0ul;
			if(attr)
			{
				u16vec4 end = u16vec4(fma(ray.dir.xyxy, vec4(float(begin).xx, float(march).xx), ray.origin.xyxy));
//				while(any(lessThan(ivec4(end), ivec4(0)))){}
//				while(any(greaterThanEqual(uvec4(end), uvec4(reso.xyxy)))){}

//				if(ray.area==1){ end.xz = u16vec2(reso.xx)-end.xz;}
				if(ray.area==1){ end.xz = u16vec2(reso.xx-1)-end.xz;}

				uvec2 vi = end.xz + end.yw * reso.xx;
				uvec2 array_index = uvec2(b_vertex_array_index[vi.x], b_vertex_array_index[vi.y]);

				if(array_index.x != 0xffff)
					b_vertex_array[array_index.x].vertex[angle_index] = VertexInfo(end.zw, array_index.y);
				if(array_index.y != 0xffff)
					b_vertex_array[array_index.y].vertex[angle_index+Dir_Num] = VertexInfo(end.xy, array_index.x);

				begin = march;
			}
			march++;
			pos_sub = fma(ray.dir, vec2(1.), pos_sub);
		}

	}

	u16vec4 end = u16vec4(fma(ray.dir.xyxy, vec4(float(begin).xx, float(ray.march-0.5).xx), ray.origin.xyxy));
//	while(!any(equal(uvec4(end.xyxy), uvec4(0,0,reso.xy-1)))){}
	while(!any(equal(uvec4(end.zwzw), uvec4(0,0,reso.xy-1)))){}

//	if(ray.area==1){ end.xz = u16vec2(reso.xx)-end.xz;}
	if(ray.area==1){ end.xz = u16vec2(reso.xx-1)-end.xz;}

	uvec2 vi = end.xz + end.yw * reso.xx;
	uvec2 array_index = uvec2(b_vertex_array_index[vi.x], b_vertex_array_index[vi.y]);
	if(array_index.x != 0xffff)
		b_vertex_array[array_index.x].vertex[angle_index] = VertexInfo(end.zw, array_index.y);
	if(array_index.y != 0xffff)
		b_vertex_array[array_index.y].vertex[angle_index+Dir_Num] = VertexInfo(end.xy, array_index.x);


}
