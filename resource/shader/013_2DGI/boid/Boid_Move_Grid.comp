#version 460
#extension GL_GOOGLE_include_directive : require

#define USE_Boid2D 0
#define USE_GI2D 1
#include "GI2D.glsl"
#include "Boid2D.glsl"

layout (local_size_x = 1024) in;

struct MarchResult
{
	vec2 next_pos;
	ivec2 next_map_index;
	float progress;
	bool is_end;
};

#if 0
#define FLT_EPSIRON (0.01)
MarchResult marchEx(in vec2 pos, in ivec2 map_index, in float progress, in vec2 dir)
{
	float particle_size = 0.;
	vec2 cell_origin = vec2(map_index);
	vec2 cell_p = pos - cell_origin;
	float x = dir.x < 0. ? cell_p.x : (1. - cell_p.x);
	float y = dir.y < 0. ? cell_p.y : (1. - cell_p.y);
	x = (x <= particle_size ? 1. + x : x) - particle_size;
	y = (y <= particle_size ? 1. + y : y) - particle_size;

	vec2 dist = vec2(9999.);
	dist.x = abs(dir.x) < FLT_EPSIRON ? 9999.9 : abs(x / dir.x);
	dist.y = abs(dir.y) < FLT_EPSIRON ? 9999.9 : abs(y / dir.y);
	float rate = min(dist.x, dist.y);
	rate = abs(dir.x) < FLT_EPSIRON ? dist.y : rate;
	rate = abs(dir.y) < FLT_EPSIRON ? dist.x : rate;

	vec2 prog = dir * rate;
	float progLength = length(prog);
	if(progress < progLength)
	{
		// 移動完了
		pos += dir * progress;
		MarchResult result;
		result.next_pos = pos;
		result.next_map_index = map_index;
		result.progress = 0.;
		result.is_end = true;
		return result;
	}

	ivec2 next = ivec2(0);
	if(dist.x < dist.y){
		next.x = dir.x < 0. ? -1 : 1;
	}
	else
	{
		next.y = dir.y < 0. ? -1 : 1;
	}

	pos += prog;
	progress -= progLength;

	MarchResult result;
	result.next_pos = pos;
	result.next_map_index = map_index + next;
	result.progress = progress;
	result.is_end = false;
	return result;
}
#else

// 軽量版
MarchResult marchEx(in vec2 pos, in ivec2 map_index, in float progress, in vec2 dir)
{
	pos += dir * clamp(progress, 0., 1.);
	progress = max(progress-1., 0.);

	MarchResult result;
	result.next_pos = pos;
	result.next_map_index = ivec2(pos);
	result.progress = progress;
	result.is_end = progress <= 1.;
	return result;
}

#endif

void main() 
{

	int p_id = int(gl_GlobalInvocationID.x);

	vec2 acc = b_acc[p_id];
	vec2 vel = b_vel[p_id] + (acc + vec2(0., 9.8))*DT;

	vec2 dir = vel;
	vec2 pos = b_pos[p_id];

	const ivec4 reso = ivec4(u_gi2d_info.m_resolution.xy, u_gi2d_info.m_resolution.xy/8);

	{ 

		float advance = length(dir);
		dir = normalize(dir);
		ivec2 map_index = ivec2(pos);
		float progress = advance;
		for(int _i = 0; _i < 500; _i++)
		{
			MarchResult result = marchEx(pos, map_index, progress, dir);
			progress = result.progress;

			// hit確認
			{
				ivec4 fragment_index = ivec4(result.next_map_index/8, result.next_map_index%8);
				ivec2 shift = fragment_index.zw;

				int findex = fragment_index.x + fragment_index.y*reso.z;
				uint64_t fragment_map = b_diffuse_map[findex];

				uint64_t bit = 1ul<<(shift.x+shift.y*8);
				if((fragment_map & bit) != 0)
				{
					// 壁にぶつかったので反射
					vec2 next = vec2(result.next_map_index - map_index);
					vec2 wall = vec2(next.x, next.y);
					dir = normalize(reflect(dir, wall));
					advance *= 0.5;
					progress *= 0.5;

					// 更新はしない?
//					pos = result.next_pos;

				}
				else
				{
					// 何もないのでそのまま進む
					map_index = result.next_map_index;
					pos = result.next_pos;

				}
			}

			if(result.is_end)
			{
				b_pos[p_id] = pos;
				b_vel[p_id] = dir * advance;
				break;
			}

		}
	}


	ivec2 reso_grid = ivec2(reso.xy/Grid_Size);
	vec2 index_grid_f = pos / Grid_Size;
	ivec2 index_grid = ivec2(index_grid_f);
	if(any(lessThan(index_grid, ivec2(0))) || any(greaterThanEqual(index_grid, reso_grid.xy))){ return; }
	int i = index_grid.x + index_grid.y*reso_grid.x;

	int next = atomicExchange(b_grid_head[i], p_id);
	b_grid_node[p_id] = next;

	atomicAdd(b_grid_counter[i], 1);

}

