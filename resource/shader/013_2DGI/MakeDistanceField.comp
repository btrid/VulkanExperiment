#version 450

#extension GL_GOOGLE_cpp_style_line_directive : require
#extension GL_ARB_gpu_shader_int64 : require

#include <btrlib/ConvertDimension.glsl>
#include <btrlib/Common.glsl>
#include <btrlib/Math.glsl>

#define USE_PM 0
#include <PM.glsl>

layout (local_size_x = 32, local_size_y = 32) in;

#define HierarchyCheckDepth (1)
void main()
{
	const ivec4 reso = ivec4(u_pm_info.m_resolution.xy, u_pm_info.m_resolution.xy/8);
	uint map_index = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y*reso.x;

	int hierarchy = 0;
	u64vec4 map = u64vec4(0);
	uint64_t _map[4] = {0, 0, 0, 0};
	uvec4 fragment_index;
	for(; hierarchy<HierarchyCheckDepth; hierarchy++)
	{
		uvec2 map_idx_2d = gl_GlobalInvocationID.xy>>hierarchy;
		uvec2 map_idx_2d_sub = map_idx_2d % 8;
		ivec2 map_idx_offset = ivec2(greaterThanEqual(map_idx_2d_sub, uvec2(4))) * 2 - 1;

		int offset = getFragmentMapHierarchyOffset(hierarchy);
		ivec4 fragment_idx = ivec4(map_idx_2d/8, map_idx_2d%8);
		for(int i = 0; i < 4; i++)
		{
			ivec2 f_idx = fragment_idx.xy + map_idx_offset*ivec2(i%2, i/2);
			if(any(lessThan(f_idx, ivec2(0))) || any(greaterThanEqual(f_idx, ivec2(reso.zw))))
			{
				// エリア外はノーチェック
//				map[i] = uint64_t(0);
				continue;
			}
			int f_idx_1d = f_idx.x + f_idx.y*(reso.z>>hierarchy);
			_map[i] = b_fragment_map[f_idx_1d + offset];
			fragment_index[i] = f_idx_1d + offset;

		}
		map.x = _map[0];
		map.y = _map[1];
		map.z = _map[2];
		map.w = _map[3];
		if(any(notEqual(map, u64vec4(0))))
		{
			break;
		}
	}

	if(hierarchy == HierarchyCheckDepth)
	{
		b_signed_distance_field[map_index] = 999999999;
		return;
	}

	for(int i = 0; i < 4; i++)
	{
		if(_map[i] == 0){ continue;}

		SDFWork work;
		work.map_index = map_index;
		work.hierarchy = hierarchy;
		work.fragment_idx = fragment_index[i];

		if(hierarchy == 0)
		{
			int index = atomicAdd(b_sdf_counter[8].x, 1);
			b_sdf_work_top[index] = work;
		}
		else
		{
			int local_index = atomicAdd(b_sdf_counter[1].w, 1);
			if(local_index%(32*32) == 0)
			{
				atomicAdd(b_sdf_counter[1].x, 1);
			}
			uint index = atomicAdd(b_sdf_work_num, 1);
			b_sdf_work[index] = work;
		}
	}

}

