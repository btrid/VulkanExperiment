#version 450
#extension GL_GOOGLE_include_directive : require

#include "btrlib/ConvertDimension.glsl"
#include "btrlib/Common.glsl"
#include "btrlib/Math.glsl"

#define USE_PM 0
#define USE_PM_RENDER 1
#include "PM.glsl"


layout(push_constant) uniform BounceInfo
{
	int bounce_count;
	int store_photon_index;
} constant;
#define u16_max (0xffff)
#define fragment_state_non (0)
#define fragment_state_wall (1)
#define fragment_state_light (2)
#define fragment_state_bounce (3)
#define fragment_state_bounce_hit (4)

layout (local_size_x = 32, local_size_y = 32) in;
void main()
{
	const vec2 pixel_size = vec2(1., 1.);
	const vec2 subpixel = pixel_size.xy*(1<<constant.bounce_count);

	const ivec4 reso = ivec4(u_pm_info.m_resolution.xy, u_pm_info.m_resolution.xy/8);
	const ivec2 bounce_reso = ivec2(u_pm_info.m_resolution.xy)>>constant.bounce_count;
	int fragment_state = fragment_state_non;
	vec3 albedo = vec3(0.);
	vec3 illuminance = vec3(0.);

//	const ivec2 tile_index_2d = pixel / ivec2(u_pm_info.m_emission_tile_size.xy);
//	const int tile_index = int(tile_index_2d.x + tile_index_2d.y*u_pm_info.m_emission_tile_num.x);
//	for(int i = b_emission_tile_linkhead[tile_index]; i != -1; i= b_emission_tile_linklist[i].next)
	{
		uint64_t is_alive = uint64_t(-1);
		uint64_t is_arrive = 0;

		vec2 start;
		vec4 radiance;
		Emission light;
		{
//			int emission_index = b_emission_tile_linklist[i].target;
//			int eoffset = u_pm_info.m_emission_buffer_offset[constant.bounce_count];
			light = b_emission[0];
			radiance = light.emission;
			start = light.pos;
//			ivec2 e_index_2d = ivec2(emission_index%bounce_reso.x, emission_index/bounce_reso.x);
//			start = vec2(e_index_2d<<constant.bounce_count);
		}
		ivec2 istart = ivec2(start+0.5);

/*		vec4 l_dir = rotate2(light.dir.xx + vec2(-light.angle, light.angle));
		vec3 a = cross(vec3(l_dir.xy, 0.), vec3(diff, 0.));
		vec3 b = cross(vec3(l_dir.zw, 0.), vec3(diff, 0.));
		if(light.angle>=0. && (a.z > 0. || b.z < 0.))
		{
			// spotlight影響範囲外
			continue;
		}
*/

//		int goal_index = abs(dir.x) >= abs(dir.y) ? 0: 1;
//		int goal_index2 = abs(dir.x) >= abs(dir.y) ? 0: 1;

		vec4 dir;
		{
			float ray_num = gl_NumWorkGroups.y*gl_WorkGroupSize.x*2.;
			float ray_NO = (gl_LocalInvocationID.x + gl_WorkGroupID.y*gl_WorkGroupSize.x)*2.;

			float angle_offset = 1./ray_num/**offset.x*/;
			vec2 angle = ((ray_NO+vec2(0., 1.)) / ray_num) * (2.*PI) + angle_offset;
			
			dir = rotate2(angle);
		}

		dir.xy *= abs(dir.x) >= abs(dir.y) ? abs(1./dir.x) : abs(1./dir.y);
		dir.zw *= abs(dir.z) >= abs(dir.w) ? abs(1./dir.z) : abs(1./dir.w);
		vec4 inv_dir = abs(1./dir);

		vec4 pos = start.xyxy;
		ivec4 map_index = ivec4(pos);

		const ivec4 map_index_origin = ivec4(greaterThanEqual(dir, vec4(0.)));

		ivec2 is_died = ivec2(0);
		ivec2 is_hit = ivec2(0);
		ivec4 hit_point = ivec4(-1);
		for(int i = 0; i <50000; i++)
		{
			// march
			{
				int hierarchy=0;
				ivec4 cell_origin = map_index_origin<<hierarchy;
				ivec4 map_index_sub = map_index - ((map_index>>hierarchy)<<hierarchy);
				vec4 cell_p = abs(cell_origin - (map_index_sub+fract(pos))) + 0.5;
				vec4 axis = abs(cell_p*inv_dir);
				pos.xy += min(axis.x, axis.y)*dir.xy;
				pos.zw += min(axis.z, axis.w)*dir.zw;
				map_index = ivec4(pos);
			}

			// 範囲外
			{
				ivec4 is_die = ivec4(greaterThanEqual(map_index, reso.xyxy)) + ivec4(lessThan(map_index, ivec4(0)));
				is_died |= ivec2(any(notEqual(is_die.xy, ivec2(0))), any(notEqual(is_die.zw, ivec2(0))));
			}

			// hit確認
			{
				ivec2 map_index_hie = map_index.xy>>constant.bounce_count;
				ivec4 fragment_index = ivec4(map_index_hie/8, map_index_hie%8);
				ivec2 shift = fragment_index.zw;

				ivec4 offset_ = ivec4(0,0,1,1);
				ivec4 findex = fragment_index.xxxx + offset_.xxzz + (fragment_index.yyyy + offset_.ywyw)*(reso.zzzz>>constant.bounce_count);

				uint64_t fragment_map;
				{
					uint64_t x_line_mask2 = 0xfful & ((1ul << (shift.x)) - 1ul);
					uint64_t x_mask_inv2 = x_line_mask2 | (x_line_mask2 << 8) | (x_line_mask2 << 16) | (x_line_mask2 << 24) | (x_line_mask2 << 32) | (x_line_mask2 << 40) | (x_line_mask2 << 48) | (x_line_mask2 << 56);
					uint64_t y_mask_inv2 = 0xfffffffffffffffful & ((1ul << ((shift.y) * 8)) - 1);
					uint64_t x_mask2 = ~x_mask_inv2;
					uint64_t y_mask2 = ~y_mask_inv2;

					u64vec4 b = u64vec4(b_fragment_map[findex.x],b_fragment_map[findex.y],b_fragment_map[findex.z],b_fragment_map[findex.w]);
					b &= u64vec4(x_mask2 & y_mask2, x_mask2 & ~y_mask2, ~x_mask2 & y_mask2, ~x_mask2 & ~y_mask2);

					ivec4 rs = shift.yyyy*ivec4(8,0,8,0) + shift.xxxx*ivec4(1,1,0,0);
					ivec4 ls = (8-shift.yyyy)*ivec4(0,8,0,8) + (8-shift.xxxx)*ivec4(0,0,1,1);

					b >>= rs;
					b <<= ls;

					fragment_map = b.x|b.y|b.z|b.w;

					u64vec4 dead = u64vec4(is_alive) & b;
					dead <<= rs;
					dead >>= ls;
//					dead.x != 0 ? atomicOr(b_emission_occlusion[findex.x], dead.x) : 0;
//					dead.y != 0 ? atomicOr(b_emission_occlusion[findex.y], dead.y) : 0;
//					dead.z != 0 ? atomicOr(b_emission_occlusion[findex.z], dead.z) : 0;
//					dead.w != 0 ? atomicOr(b_emission_occlusion[findex.w], dead.w) : 0;
					(dead.x != 0) ? (b_emission_occlusion[findex.x] |= dead.x) : 0;
					(dead.y != 0) ? (b_emission_occlusion[findex.y] |= dead.y) : 0;
					(dead.z != 0) ? (b_emission_occlusion[findex.z] |= dead.z) : 0;
					(dead.w != 0) ? (b_emission_occlusion[findex.w] |= dead.w) : 0;
					
//					(dead.x != 0) ? (b_emission_occlusion[findex.x] |= dead.x) : 0;
//					(dead.y != 0) ? (b_emission_occlusion[findex.y] |= dead.y) : 0;
//					(dead.z != 0) ? (b_emission_occlusion[findex.z] |= dead.z) : 0;
//					(dead.w != 0) ? (b_emission_occlusion[findex.w] |= dead.w) : 0;

				}
				is_alive &= ~fragment_map;


				if(is_alive == uint64_t(0))
				{ 
					break;
				}
			}
		}

	}

}
