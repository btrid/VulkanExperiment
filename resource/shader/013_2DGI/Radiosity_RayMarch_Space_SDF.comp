#version 450
#extension GL_GOOGLE_include_directive : require

#include "btrlib/ConvertDimension.glsl"
#include "btrlib/Common.glsl"
#include "btrlib/Math.glsl"

#define RAY_TYPE_FLOAT
#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#include "GI2D.glsl"

layout (local_size_x=1024) in;
void main()
{
	if(gl_GlobalInvocationID.x >= b_ray_counter[u_gi2d_scene.m_frame].w){ return; }

	const int hierarchy = u_gi2d_scene.m_hierarchy;
	const ivec4 reso = ivec4(u_gi2d_info.m_resolution.xy, u_gi2d_info.m_resolution.xy/8);

	uint ray_index = gl_GlobalInvocationID.x + GetRayOffset(u_gi2d_scene.m_frame);
	D2Ray ray = b_ray[ray_index];
	vec2 pos = ray.origin;
	vec2 dir = rotate(ray.angle);
	vec2 inv_dir;
	inv_dir.x = dir.x == 0. ? 99999999. : abs(1./dir.x);
	inv_dir.y = dir.y == 0. ? 99999999. : abs(1./dir.y);
//	dir *= min(inv_dir.x, inv_dir.y);
	ivec2 map_index = ivec2(pos);

	D2Segment seg;
	seg.ray_index = ray_index;
	seg.begin = 0.;
	seg.march = 0.;
	seg.radiance = 0;
	float progress = 0.;

	for(;progress < ray.march;)
	{
		float d = b_sdf[map_index.x + map_index.y*reso.x].x;
		{
			if(d <= 0.1)
			{
				if(seg.march > 0)
				{
					int index = atomicAdd(b_segment_counter.w, 1);
					if(index%1024==0){
						atomicAdd(b_segment_counter.x, 1);
					}
					b_segment[index] = seg;
				}
				seg.begin = -1.;
				seg.march = 0.;

				d = min(inv_dir.x, inv_dir.y);
			}
			else
			{
				if(seg.begin <= 0.)
				{
					seg.begin = progress;
				}
				seg.march += d;
			}

		}
		// march
		{
			// DDA
			progress += d;
			pos = ray.origin + dir*progress;
			map_index = ivec2(pos);
		}
	}

	if(seg.march > 0)
	{
		int index = atomicAdd(b_segment_counter.w, 1);
		if(index%1024==0){
			atomicAdd(b_segment_counter.x, 1);
		}
		b_segment[index] = seg;
	}


}
