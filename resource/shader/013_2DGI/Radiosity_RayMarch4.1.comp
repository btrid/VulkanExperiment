#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#include "GI2D.glsl"

#define HALF_PI (1.5707963)
#define TWO_PI (6.28318530)
#define QUARTER_PI (0.7853981633)

layout (local_size_x=128) in;

shared u64vec2 s_fragment[20];
shared ivec2 s_base_cell;
shared ivec4 s_is_end;
shared int s_index;
void main()
{
	const ivec4 reso = u_gi2d_info.m_resolution;

	uint ray_index = gl_GlobalInvocationID.x + u_radiosity_info.ray_frame_max*u_gi2d_scene.m_frame;
	D2Ray ray = b_ray[ray_index];
	vec2 dir = calcDir(ray.angle);
	vec2 inv_dir = abs(1./dir);
	int y = int((ray.angle-QUARTER_PI) / HALF_PI);
	int axis = y%2;
	vec2 cell_origin = vec2(greaterThanEqual(dir, vec2(0.))) * vec2(8.);
	int fragment_offset = reso.z*reso.w; // 縦ほうこうに進む場合
	int local_map_offset = ivec2(sign(dir))[1-axis];
	bool is_end = false;

//	if(y != 2){ return; }

	if(gl_LocalInvocationIndex < 4)
		s_is_end[gl_LocalInvocationIndex] = 0;
	memoryBarrierShared();
	barrier();
		
	D2Segment seg;
	seg.ray_index = ray_index;
	seg.begin = 0;
	seg.march = 0;
	seg.radiance = 0;
	int march_count = 0;
	for(int _i = 0; _i < 10000; _i++)
	{
		if(!is_end && march_count >= ray.march)
		{
			atomicOr(s_is_end[gl_LocalInvocationIndex / 32], 1 << (gl_LocalInvocationIndex % 32));
			is_end = true;
		}
		memoryBarrierShared();
		barrier();

		if(all(equal(s_is_end, ivec4(-1)))){ break; }


		vec2 pos = fma(dir, float(march_count).xx, ray.origin);
		ivec2 map_index = ivec2(pos);
		ivec2 cell = map_index>>3;
		if(gl_LocalInvocationIndex == 0)
		{
			int i = (axis==1) ? (cell.x + cell.y*reso.z) : (cell.y + cell.x*reso.w + fragment_offset);
			s_index = i - 2;
			s_base_cell = cell;
		}
		memoryBarrierShared();
		barrier();

		if(gl_LocalInvocationIndex < 20)
		{
			s_fragment[gl_LocalInvocationIndex] = b_fragment_map[s_index + gl_LocalInvocationIndex];
		}
		memoryBarrierShared();
		barrier();
		
		if(is_end){ continue; }

		int ii = (cell-s_base_cell)[1-axis] + 2;
		u64vec2 map[2];
		map[0] = s_fragment[ii];
		map[1] = s_fragment[ii + local_map_offset];

		if(all(equal(u64vec4(map[0], map[1]), u64vec4(0))))
		{
			seg.march+=8;
			march_count+=8;
		}
		else
		{
			for(uint i = 0; i < 8; i++)
			{
				vec2 pos = fma(dir, float(march_count).xx, ray.origin);
				ivec2 map_index = ivec2(pos);
				int m_index = abs((map_index>>3)-cell)[1-axis];
				ivec2 cell_sub = map_index % 8;
				bvec2 attr = notEqual((map[m_index] & (1ul<<(cell_sub.x+cell_sub.y*8))), u64vec2(0));
				if(attr.y)
				{
					seg.radiance += b_light[getMemoryOrder(map_index)];
				}
				if(attr.x)
				{
					if(seg.march > 1)
					{
						int index = atomicAdd(b_segment_counter.w, 1);
						if(index%1024==0){
							atomicAdd(b_segment_counter.x, 1);
						}
						b_segment[index] = seg;
					}
					seg.begin = march_count;
					seg.march = 0;
					seg.radiance = 0;
				}
				seg.march++;
				march_count++;
			}
		}
	}

	// 行きすぎたら戻す
	seg.march -= march_count-ray.march;
	if(seg.march > 1)
	{
		int index = atomicAdd(b_segment_counter.w, 1);
		if(index%1024==0){
			atomicAdd(b_segment_counter.x, 1);
		}
		b_segment[index] = seg;
	}


}
