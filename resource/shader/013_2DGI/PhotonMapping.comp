#version 450

#extension GL_GOOGLE_cpp_style_line_directive : require

#include <btrlib/ConvertDimension.glsl>
#include <btrlib/Common.glsl>
#include <btrlib/Math.glsl>

#define USE_OIT 0
#include <OIT.glsl>

layout (local_size_x = 32, local_size_y = 32) in;

void main()
{
	ivec2 pixel_offset = ivec2(gl_GlobalInvocationID.xy);
	int tile_index = int(gl_WorkGroupID.x + gl_WorkGroupID.y*32);
	ivec2 reso = ivec2(u_OIT_info.m_resolution.xy);

	vec2 cell_size = vec2(1.);

	for(int i = 0; i < b_emissive_tile_counter[tile_index]; i++)
	{
		int emissive_pixel_index = b_emissive_tile_map[tile_index*u_OIT_info.m_emissive_tile_map_max + i];
		ivec2 emissive_pixel_index_2d = ivec2(emissive_pixel_index % u_OIT_info.m_resolution.x, emissive_pixel_index / u_OIT_info.m_resolution.y);

		ivec2 map_index = pixel_offset;
		vec2 pos = vec2(map_index)*cell_size;
		vec2 dir = normalize(emissive_pixel_index_2d*cell_size+cell_size*0.01 - pos);
		float progress = 0.;

		for(;;)
		{
			vec2 cell_origin = vec2(map_index)*cell_size;
			vec2 cell_p = pos - cell_origin;
			float x = dir.x < 0. ? cell_p.x : (cell_size.x- cell_p.x);
			float y = dir.y < 0. ? cell_p.y : (cell_size.y- cell_p.y);

			vec2 dist = vec2(9999.);
			dist.x = abs(dir.x) < FLT_EPSIRON ? 9999.9 : abs(x / dir.x);
			dist.y = abs(dir.y) < FLT_EPSIRON ? 9999.9 : abs(y / dir.y);
			float rate = min(dist.x, dist.y);
			rate = abs(dir.x) < FLT_EPSIRON ? dist.y : rate;
			rate = abs(dir.y) < FLT_EPSIRON ? dist.x : rate;

			vec2 prog = dir * rate;
			ivec2 next = ivec2(0);
			if(dist.x < dist.y){
				next.x = dir.x < 0. ? -1 : 1;
			}
			else
			{
				next.y = dir.y < 0. ? -1 : 1;
			}
			pos += prog;
			progress += length(prog);
			map_index = map_index + next;

			if(any(greaterThanEqual(map_index, reso)) || any(lessThan(map_index, ivec2(0, 0)))) {
				// 範囲外
				b_color[1] = vec4(1., 0., 0., 1.);
				break;
			}

			int map_index_1d = map_index.x + map_index.y*reso.x;
			if(b_fragment_map[map_index_1d] != 0){
				// hit
				b_color[2] = vec4(0., 0., 1., 1.);
				break;
			}
			b_color[map_index_1d] = vec4(1.);
		}
	}

}