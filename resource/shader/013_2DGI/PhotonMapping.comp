#version 450

#extension GL_GOOGLE_cpp_style_line_directive : require

#include <btrlib/ConvertDimension.glsl>
#include <btrlib/Common.glsl>
#include <btrlib/Math.glsl>

#define USE_PM 0
#include <PM.glsl>

layout(push_constant) uniform BounceInfo
{
	bool is_store_photon;
	int bounce_count;
} constant;

layout (local_size_x = 32, local_size_y = 32) in;
void main()
{
	const vec4 default_cell_size = vec4(1., 1., vec2(ivec2(1)<<constant.bounce_count));
	const ivec4 reso = ivec4(u_pm_info.m_resolution.xy, u_pm_info.m_resolution.xy/8);
	const ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);

	const vec2 end = vec2(pixel) + 0.5;
	const ivec2 iend = ivec2(end);
	bool is_wall = false;
	{
		ivec2 fragment_index = iend/8;
		int fragment_index_1d = fragment_index.x + fragment_index.y*reso.z;
		uint64_t fragment_map = b_fragment_map[fragment_index_1d];

		ivec2 fragment_index_sub = iend%8;
		int fragment_index_sub_1d = fragment_index_sub.x + fragment_index_sub.y*8;
		uint64_t bit = 1ul<<fragment_index_sub_1d;

		is_wall = (fragment_map & bit) != 0;
	}

	vec3 illuminance = vec3(0.);

	const ivec2 tile_index_2d = pixel / ivec2(u_pm_info.m_emission_tile_size.xy);
	const int tile_index = int(tile_index_2d.x + tile_index_2d.y*u_pm_info.m_emission_tile_num.x);
	for(int i = b_emission_tile_linkhead[tile_index]; i != -1; i= b_emission_tile_linklist[i].next)
	{
		vec2 start;
		vec4 emission;
		{
			int emission_index = b_emission_tile_linklist[i].target;
			int eoffset = u_pm_info.m_emission_buffer_offset[constant.bounce_count];
			emission = b_emission[emission_index+eoffset].value;
			start = vec2(emission_index%reso.x, emission_index.x/reso.x) + default_cell_size.zw*0.5;
		}
		float emissive_power = length(emission.xyz);

		const vec2 diff = (end - start);
		if(dot(diff, diff) <= 10.1)
		{
			// ライト
			const int pixel_1d = pixel.x + pixel.y*reso.x;
			b_color[pixel_1d] = vec4(0., 65555., 0., 1.);
			return;
		}
		const float ray_dist = length(diff.xy);

		vec2 dir = normalize(diff);
		dir.x = abs(dir.x) <= FLT_EPSIRON ? FLT_EPSIRON*2. : dir.x;
		dir.y = abs(dir.y) <= FLT_EPSIRON ? FLT_EPSIRON*2. : dir.y;

		const ivec3 next_step = ivec3((dir.x < 0. ? -1 : 1), (dir.y < 0. ? -1 : 1), 0);

		vec2 pos = start;
		ivec2 map_index = ivec2(pos / default_cell_size.xy);
		const ivec2 istart = ivec2(start.xy);
		const ivec2 target_dist = abs(istart-iend);


		for(;;)
		{
			int hierarchy=7;
			{
				for(; hierarchy>constant.bounce_count; hierarchy--)
				{
					ivec2 findex2d = map_index>>hierarchy;
					int findex = findex2d.x + findex2d.y*(reso.x>>hierarchy);
					int offset = getFragmentHierarchyOffset(hierarchy);
					if(b_fragment_hierarchy[findex + offset] == 0)
					{
						break;
					}
				}
			}
			// march
			{
				vec2 cell_size = default_cell_size.xy*(1<<hierarchy);
				vec2 cell_origin = vec2(map_index>>hierarchy)*cell_size;
				vec2 cell_p = pos - cell_origin;

				float x = dir.x < 0. ? cell_p.x : (cell_size.x- cell_p.x);
				float y = dir.y < 0. ? cell_p.y : (cell_size.y- cell_p.y);

				x = x <= FLT_EPSIRON ? (x+cell_size.x) : x;
				y = y <= FLT_EPSIRON ? (y+cell_size.y) : y;

				vec2 dist = abs(vec2(x, y) / dir);
				int next_ = dist.x < dist.y ? 0 : 1;
				pos += dir * dist[next_];

				ivec2 next = next_ == 0 ? next_step.xz : next_step.zy;
				map_index = ivec2(pos+ next*0.5);

			}

			// 終了判定
			if(all(greaterThanEqual(abs(ivec2(map_index)-istart), target_dist)))
			{
				// 距離を超えたら光がフラグメントにヒット
				illuminance += vec3(0., 0., 1.) * emissive_power / (1+ray_dist.x*ray_dist.x);
				break;
			}

			// hit確認
			{
				ivec2 fragment_index = map_index/8;
				int fragment_index_1d = fragment_index.x + fragment_index.y*reso.z;
				uint64_t fragment_map = b_fragment_map[fragment_index_1d];

				ivec2 fragment_index_sub = map_index%8;
				int fragment_index_sub_1d = fragment_index_sub.x + fragment_index_sub.y*8;
				uint64_t bit = 1ul<<fragment_index_sub_1d;

				if((fragment_map & bit) != 0)
				{ 
					break;
				}
			}
		}
	}

	// store
	{
		vec3 store_illuminance = is_wall ? vec3(65355., 0., 0.) : (min(illuminance*1000000., vec3(65355.)));
		uvec2 u_rg = uvec2(store_illuminance.rg) << uvec2(0, 16);
		uint rg = u_rg.r | u_rg.g;
		uvec2 u_ba = uvec2(store_illuminance.b, 0) << uvec2(0, 16);
		uint ba = u_ba.x | u_ba.y;
		ivec2 store_index_2d = pixel>>constant.bounce_count;
		imageAtomicAdd(t_color[constant.bounce_count], ivec3(store_index_2d.xy, 0), rg);
		imageAtomicAdd(t_color[constant.bounce_count], ivec3(store_index_2d.xy, 1), ba);
	}

	// バウンス
	if(constant.is_store_photon && dot(illuminance, illuminance) >= 10.1)
	{
		int store_shift = constant.bounce_count+1;
		int e_offset = u_pm_info.m_emission_buffer_offset[store_shift];

		ivec2 store_index_2d = pixel>>store_shift;
		int store_index = store_index_2d.x + store_index_2d.y*(reso.x>>store_shift);
		if(atomicCompSwap(b_emission_map[e_offset + store_index], -1, 0) == -1)
		{
			b_emission[e_offset+store_index].value = vec4(0.);// 危ないかも？
			int list_index = atomicAdd(b_emission_counter[store_shift].x, 1);
			b_emission_list[e_offset+list_index] = store_index;
		}
		b_emission[e_offset+store_index].value = vec4(illuminance.zyx, 1.);//debugで赤くする
	}
}
