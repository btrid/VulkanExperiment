#version 450

#extension GL_GOOGLE_cpp_style_line_directive : require

#include <btrlib/ConvertDimension.glsl>
#include <btrlib/Common.glsl>
#include <btrlib/Math.glsl>

#define USE_OIT 0
#include <OIT.glsl>

layout (local_size_x = 32, local_size_y = 32) in;
void main()
{
	ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
	int pixel_1d = int(pixel.x + pixel.y*u_OIT_info.m_resolution.x);
	int tile_index = int(gl_WorkGroupID.x + gl_WorkGroupID.y*32);
	ivec2 reso = ivec2(u_OIT_info.m_resolution.xy);

	int hierarchy_level = 0;
	int hierarchy_rate = 8;
	vec2 c_cell_size[2];
	c_cell_size[0] = vec2(1.);
	c_cell_size[1] = c_cell_size[0]*hierarchy_rate;

	for(int i = 0; i < b_emissive_counter.x; i++)
	{
//		int emissive_pixel_index = b_emissive_tile_map[tile_index*u_OIT_info.m_emissive_tile_map_max + i];
//		ivec2 emissive_pixel_index_2d = ivec2(emissive_pixel_index % u_OIT_info.m_resolution.x, emissive_pixel_index / u_OIT_info.m_resolution.y);
		int emissive_pixel_index = 0;
		ivec2 emissive_pixel_index_2d = ivec2(0, 0);

		ivec2 map_index = pixel;
		vec2 pos = vec2(map_index)*c_cell_size[0] + c_cell_size[0]*0.5;

		vec2 dir = normalize(emissive_pixel_index_2d*c_cell_size[0] - pos);
		ivec3 next_step = ivec3((dir.x < 0. ? -1 : 1), (dir.y < 0. ? -1 : 1), 0);
		ivec2 next = ivec2(0);

		ivec2 map_index_1 = map_index/8;
		ivec2 map_index_1_sub = map_index%8;
		int map_index_1_1d = map_index_1.x + map_index_1.y * (640/8);
		uint64_t fragment_map = b_fragment_hierarchy[map_index_1_1d];

		for(;;)
		{

			int hierarchy = fragment_map == 0 ? 1 : 0;
			vec2 cell_size = c_cell_size[hierarchy];

			vec2 cell_origin = vec2(map_index)*c_cell_size[hierarchy];
			vec2 cell_p = (pos+(next*0.001)) - cell_origin;

			float x = dir.x < 0. ? cell_p.x : (cell_size.x- cell_p.x);
			float y = dir.y < 0. ? cell_p.y : (cell_size.y- cell_p.y);

			vec2 dist = vec2(99999.);
			dist.x = abs(dir.x) < FLT_EPSIRON ? 99999. : abs(x / dir.x);
			dist.y = abs(dir.y) < FLT_EPSIRON ? 99999. : abs(y / dir.y);
			float rate = min(dist.x, dist.y);
			rate = rate < FLT_EPSIRON ? max(dist.x, dist.y) : rate;

			vec2 prog = dir * rate;
			pos += prog;
			next = dist.x < dist.y ? next_step.xz : next_step.zy;

			map_index = ivec2((pos+next*c_cell_size[0]*0.5) / c_cell_size[0]);

			if(distance(pixel, map_index) >= distance(pixel, emissive_pixel_index_2d))
			{
				// 距離を超えたら当たってない
				b_color[pixel_1d] = vec4(0., 0., 1., 1.);
				break;
			}

			if(any(greaterThanEqual(map_index, reso)) || any(lessThan(map_index, ivec2(0, 0)))) 
			{
				// 範囲外にはならないようになるのが理想
				b_color[0] = vec4(1., 0., 0., 1.);
				break;
			}
			map_index_1 = map_index/8;
			map_index_1_sub = map_index%8;
			map_index_1_1d = map_index_1.x + map_index_1.y * (640/8);
			fragment_map = b_fragment_hierarchy[map_index_1_1d];

			uint bit_offset = map_index_1_sub.x + map_index_1_sub.y*8;
			uint64_t bit = uint64_t(1)<<bit_offset;
			if((fragment_map & (bit)) != 0)
			{
				// 遮蔽物
				b_color[pixel_1d] = vec4(0., 0., 0., 1.);
				break;
			}
		}
	}

}