#version 450
#extension GL_GOOGLE_include_directive : require

#include "btrlib/ConvertDimension.glsl"
#include "btrlib/Common.glsl"
#include "btrlib/Math.glsl"

#define USE_GI2D 0
#include "GI2D.glsl"
#define USE_GI2D_SDF 1
#define USE_GI2D_SDFEX
#include "GI2DSDF.glsl"

layout (local_size_x = 64, local_size_y = 1) in;

layout(push_constant) uniform Input
{
	uint distance;
	uint offset;
} constant;

vec4 isInvalid(in ivec4 a)
{
	return vec4(notEqual(a & ivec4(0x00008000), ivec4(0)));
}
vec4 isInner(in ivec4 a)
{
	return vec4(notEqual(a & ivec4(0x80000000), ivec4(0)));
}

// state.x = invalid cell
// state.y = inner or outer
void nearest(inout vec4 cell_x, inout vec4 cell_y, inout vec4 current_d, in vec4 state_inner, in vec4 cell_pos_x, in vec4 cell_pos_y, in uvec2 reso, in ivec2 target_index, in vec4 d)
{
	if(any(greaterThanEqual(target_index, reso.xy))){ return; }

	ivec4 target_cell = b_jfa_ex[target_index.x + target_index.y*reso.x];
	vec4 target_state_invalid = isInvalid(target_cell);
	vec4 target_state_inner = isInner(target_cell);
	vec4 target_cell_x = target_cell & 0x00007fff;
	vec4 target_cell_y = (target_cell>>16) & 0x00007fff;

	vec4 same = vec4(equal(target_state_inner, state_inner));

	target_cell_x = same*target_cell_x + (1.-same)*(vec4(target_index.xxxx)*4.+vec4(0.,1.,2.,3.));
	target_cell_y = same*target_cell_y + (1.-same)*vec4(target_index.yyyy);

	vec4 x = cell_pos_x-target_cell_x;
	vec4 y = cell_pos_y-target_cell_y;

	vec4 ignore = same*isInvalid(target_cell);
	vec4 use_cell = same*(1.-isInvalid(target_cell));
	d = (1.-ignore)*d + ignore*99999999.;
	d = (1.-use_cell)*d + use_cell*sqrt(x*x+y*y);

	{
		vec4 is_update = vec4(lessThan(d, current_d));
		cell_x = is_update*target_cell_x + (1.-is_update)*cell_x;
		cell_y = is_update*target_cell_y + (1.-is_update)*cell_y;
		current_d = min(current_d,d);
	}
}
void main() 
{
	const uvec2 reso = uvec2(u_gi2d_info.m_resolution.xy)>>uvec2(2,0);
	const ivec2 current = ivec2(gl_GlobalInvocationID.xy);

	ivec4 cell = b_jfa_ex[int(current.x + current.y*reso.x)];
	vec4 state_invalid = isInvalid(cell);
	vec4 state_inner = isInner(cell);

	vec4 cell_pos_x = current.xxxx*4.+ivec4(0.,1.,2.,3.);
	vec4 cell_pos_y = current.yyyy;

	vec4 cell_x = cell&0x00007fff;
	vec4 cell_y = (cell>>16)&0x00007fff;

	vec4 x = vec4(cell_x-cell_pos_x);
	vec4 y = vec4(cell_y-cell_pos_y);
	vec4 d = (1.-state_invalid)*sqrt(x*x+y*y) + state_invalid*9999999.;
	const vec4 old_d = d;

	const ivec3 cd = ivec3(constant.distance) * ivec3(-1, 0, 1);
	vec2 offset = vec2(length(vec2(cd.xx)), length(vec2(cd.xy)));
	nearest(cell_x, cell_y, d, state_inner, cell_pos_x, cell_pos_y, reso, current + (cd.xx>>uvec2(2,0)), offset.xxxx);
	nearest(cell_x, cell_y, d, state_inner, cell_pos_x, cell_pos_y, reso, current + (cd.yx>>uvec2(2,0)), offset.yyyy);
	nearest(cell_x, cell_y, d, state_inner, cell_pos_x, cell_pos_y, reso, current + (cd.zx>>uvec2(2,0)), offset.xxxx);
	nearest(cell_x, cell_y, d, state_inner, cell_pos_x, cell_pos_y, reso, current + (cd.xz>>uvec2(2,0)), offset.xxxx);
	nearest(cell_x, cell_y, d, state_inner, cell_pos_x, cell_pos_y, reso, current + (cd.yz>>uvec2(2,0)), offset.yyyy);
	nearest(cell_x, cell_y, d, state_inner, cell_pos_x, cell_pos_y, reso, current + (cd.zz>>uvec2(2,0)), offset.xxxx);
	nearest(cell_x, cell_y, d, state_inner, cell_pos_x, cell_pos_y, reso, current + (cd.xy>>uvec2(2,0)), offset.yyyy);
	nearest(cell_x, cell_y, d, state_inner, cell_pos_x, cell_pos_y, reso, current + (cd.zy>>uvec2(2,0)), offset.yyyy);

	ivec4 is_update = ivec4(d != old_d);
	ivec4 write = (ivec4(cell_y)<<16) | ivec4(cell_x) | (ivec4(state_inner)<<31) | ((1-ivec4(is_update))*(ivec4(state_invalid)<<15));
//	for(int i = 0; i < 4; i++)
//	{
//		if(is_update[i] != 0){
//			b_jfa_ex[current.x + current.y*reso.x][i] = write[i];
//		}
//	}
	if(any(notEqual(is_update, ivec4(0))))
	{
		b_jfa_ex[current.x + current.y*reso.x] = write;
	}
}
