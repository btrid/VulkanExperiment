#version 450
#extension GL_GOOGLE_include_directive : require

#include "btrlib/ConvertDimension.glsl"
#include "btrlib/Common.glsl"
#include "btrlib/Math.glsl"

#define USE_PM 0
#define USE_PM_RENDER 1
#include "PM.glsl"

layout(push_constant) uniform BounceInfo
{
	int bounce_count;
	int store_photon_index;
} constant;
#define u16_max (0xffff)
#define fragment_state_non (0)
#define fragment_state_wall (1)
#define fragment_state_light (2)
#define fragment_state_bounce (3)
#define fragment_state_bounce_hit (4)

layout (local_size_x = 32, local_size_y = 32) in;
void main()
{
	const vec2 pixel_size = vec2(1., 1.);
	const vec2 subpixel = pixel_size.xy*(1<<constant.bounce_count);

	const ivec4 reso = ivec4(u_pm_info.m_resolution.xy, u_pm_info.m_resolution.xy/8);
	const ivec2 bounce_reso = ivec2(u_pm_info.m_resolution.xy)>>constant.bounce_count;
	const ivec2 pixel = 8*ivec2(2,1)*ivec2(gl_GlobalInvocationID.xy)<<constant.bounce_count;

	const ivec2 tile_index_2d = pixel / ivec2(u_pm_info.m_emission_tile_size.xy);
	const int tile_index = int(tile_index_2d.x + tile_index_2d.y*u_pm_info.m_emission_tile_num.x);
	for(int i = b_emission_tile_linkhead[tile_index]; i != -1; i= b_emission_tile_linklist[i].next)
	{
		vec4 end = pixel.xyxy + vec4(0,0,1,0);
		vec4 start;
		vec4 radiance;

		Emission light;
		{
			int emission_index = b_emission_tile_linklist[i].target;
			int eoffset = u_pm_info.m_emission_buffer_offset[constant.bounce_count];
			light = b_emission[emission_index+eoffset];
			radiance = light.emission;
			start = light.pos.xyxy;
		}
		ivec2 iend = ivec2(end+0.5);
		ivec2 istart = ivec2(start+0.5);
		ivec2 idir = iend - istart;
		if(all(equal(idir, ivec2(0))))
		{
			// ライト自身
//			fragment_state = fragment_state_light;
//			illuminance += albedo*radiance.xyz;
//			continue;
		}

		{
			const vec2 diff = (end - start).xy;
			vec4 l_dir = rotate2(light.dir.xx + vec2(-light.angle, light.angle));
			vec3 a = cross(vec3(l_dir.xy, 0.), vec3(diff, 0.));
			vec3 b = cross(vec3(l_dir.zw, 0.), vec3(diff, 0.));
			if(light.angle>=0. && (a.z > 0. || b.z < 0.))
			{
				// spotlight影響範囲外
				continue;
			}
		}

		int goal_index = abs(idir.x) >= abs(idir.y) ? 0: 1;

		vec4 dir = normalize(end - start);
		dir.x = dir.x == 0. ? 0.000001 : dir.x;
		dir.y = dir.y == 0. ? 0.000001 : dir.y;
		dir.z = dir.z == 0. ? 0.000001 : dir.z;
		dir.w = dir.w == 0. ? 0.000001 : dir.w;
		dir.xy *= abs(dir.x) >= abs(dir.y) ? abs(1./dir.x) : abs(1./dir.y);
		dir.zw *= abs(dir.z) >= abs(dir.w) ? abs(1./dir.z) : abs(1./dir.w);
		vec4 inv_dir = abs(1./dir);

		vec4 pos = start;
		ivec4 map_index = ivec4(pos);

		const ivec4 map_index_origin = ivec4(greaterThanEqual(dir, vec4(0.)));

		u64vec2 is_alive = u64vec2(-1);
		for(int i = 0; i <50000; i++)
		{
			// march
			{
				int hierarchy=0;
				for(int hierarchy_=7; hierarchy_>3; hierarchy_-=1)
				{
					ivec2 map_index_hie = map_index.xy>>hierarchy_;
					ivec4 fragment_index = ivec4(map_index_hie/8, map_index_hie%8);
					ivec4 findex = fragment_index.xxxx + fragment_index.yyyy*(reso.zzzz>>hierarchy_);
					findex +=  getFragmentMapHierarchyOffset(hierarchy_);
					uint64_t fragment_map = b_fragment_map[findex.x];
/*
					ivec2 cell_origin = map_index_origin<<3;
					ivec2 map_index_sub = fragment_index.zw;
					ivec2 imove = abs(cell_origin - map_index_sub);

					ivec2 r_begin = map_index_sub;
					ivec2 r_end = r_begin+imove;
					ivec2 area_begin = min(r_begin, r_end);
					ivec2 area_end = max(r_begin, r_end);
					ivec2 area = area_end - area_begin+1;
					area = clamp(area, 1, 8);

					uint64_t x_line_mask = ((0x1ul<<area.x)-1);// << area_begin.x;
					uint64_t x_mask = x_line_mask | (x_line_mask << 8) | (x_line_mask << 16) | (x_line_mask << 24) | (x_line_mask << 32) | (x_line_mask << 40) | (x_line_mask << 48) | (x_line_mask << 56);
					uint64_t y_mask = ((0x1ul<<(area.y*8))-1);// << (area_begin.y * 8);

					fragment_map &= x_mask & y_mask;
*/
					if(fragment_map == 0)
					{
						hierarchy = hierarchy_;
						break;
					}
				}

				ivec4 cell_origin = map_index_origin<<hierarchy;
				ivec4 map_index_sub = map_index - ((map_index>>hierarchy)<<hierarchy);
				vec4 cell_p = abs(cell_origin - (map_index_sub+fract(pos))) + pixel_size.xyxy*0.5;
				vec4 axis = abs(cell_p*inv_dir);
				pos += min(axis.xz, axis.yw).xxyy*dir;
				map_index = ivec4(pos);
			}

			// 終了判定
			if(abs(idir[goal_index]) - abs(map_index[goal_index]-istart[goal_index]) < 1<<constant.bounce_count)
			{
				// 距離を超えたら光がフラグメントにヒット
				break;
			}
			// hit確認
			{
				ivec4 map_index_hie = map_index>>constant.bounce_count;
				ivec4 fragment_index = map_index_hie/8;
				ivec4 shift = map_index_hie%8;

				ivec4 offset_ = ivec4(0,0,1,1);
				ivec4 findex = fragment_index.xxxx + offset_.xxzz + (fragment_index.yyyy + offset_.ywyw)*(reso.zzzz>>constant.bounce_count);
				ivec4 findex2 = fragment_index.zzzz + offset_.xxzz + (fragment_index.wwww + offset_.ywyw)*(reso.zzzz>>constant.bounce_count);

				u64vec2 fragment_map;
				{
					u64vec2 x_line_mask = 0xfful & ((u64vec2(1ul) << (shift.xz)) - 1ul);
					u64vec2 x_mask_inv = x_line_mask | (x_line_mask << 8) | (x_line_mask << 16) | (x_line_mask << 24) | (x_line_mask << 32) | (x_line_mask << 40) | (x_line_mask << 48) | (x_line_mask << 56);
					u64vec2 y_mask_inv = 0xfffffffffffffffful & ((u64vec2(1ul) << ((shift.yw) * 8)) - 1);
					u64vec2 x_mask = ~x_mask_inv;
					u64vec2 y_mask = ~y_mask_inv;

					u64vec4 b = u64vec4(b_fragment_map[findex.x],b_fragment_map[findex.y],b_fragment_map[findex.z],b_fragment_map[findex.w]);
					u64vec4 b2 = u64vec4(b_fragment_map[findex2.x],b_fragment_map[findex2.y],b_fragment_map[findex2.z],b_fragment_map[findex2.w]);

					u64vec2 mask0 =  x_mask &  y_mask;
					u64vec2 mask1 =  x_mask & ~y_mask;
					u64vec2 mask2 = ~x_mask &  y_mask;
					u64vec2 mask3 = ~x_mask & ~y_mask;
					b &= u64vec4(mask0.x, mask1.x, mask2.x, mask3.x);
					b2 &= u64vec4(mask0.y, mask1.y, mask2.y, mask3.y);

					ivec4 rs = shift.yyyy*ivec4(8,0,8,0) + shift.xxxx*ivec4(1,1,0,0);
					ivec4 ls = (8-shift.yyyy)*ivec4(0,8,0,8) + (8-shift.xxxx)*ivec4(0,0,1,1);
					b >>= rs;
					b <<= ls;

					ivec4 rs2 = shift.wwww*ivec4(8,0,8,0) + shift.zzzz*ivec4(1,1,0,0);
					ivec4 ls2 = (8-shift.wwww)*ivec4(0,8,0,8) + (8-shift.zzzz)*ivec4(0,0,1,1);
					b2 >>= rs2;
					b2 <<= ls2;

					fragment_map.x = b.x|b.y|b.z|b.w;
					fragment_map.y = b2.x|b2.y|b2.z|b2.w;

					u64vec4 dead = u64vec4(is_alive.x) & b;
					dead <<= rs;
					dead >>= ls;
//					dead.x != 0 ? atomicOr(b_emission_occlusion[findex.x], dead.x) : 0;
//					dead.y != 0 ? atomicOr(b_emission_occlusion[findex.y], dead.y) : 0;
//					dead.z != 0 ? atomicOr(b_emission_occlusion[findex.z], dead.z) : 0;
//					dead.w != 0 ? atomicOr(b_emission_occlusion[findex.w], dead.w) : 0;
					b_emission_occlusion[findex.x] |= (dead.x != 0) ? dead.x : 0;
					b_emission_occlusion[findex.y] |= (dead.y != 0) ? dead.y : 0;
					b_emission_occlusion[findex.z] |= (dead.z != 0) ? dead.z : 0;
					b_emission_occlusion[findex.w] |= (dead.w != 0) ? dead.w : 0;

					u64vec4 dead2 = u64vec4(is_alive.y) & b2;
					dead2 <<= rs2;
					dead2 >>= ls2;
//					dead.x != 0 ? atomicOr(b_emission_occlusion[findex.x], dead.x) : 0;
//					dead.y != 0 ? atomicOr(b_emission_occlusion[findex.y], dead.y) : 0;
//					dead.z != 0 ? atomicOr(b_emission_occlusion[findex.z], dead.z) : 0;
//					dead.w != 0 ? atomicOr(b_emission_occlusion[findex.w], dead.w) : 0;
					b_emission_occlusion[findex2.x] |= (dead2.x != 0) ? dead2.x : 0;
					b_emission_occlusion[findex2.y] |= (dead2.y != 0) ? dead2.y : 0;
					b_emission_occlusion[findex2.z] |= (dead2.z != 0) ? dead2.z : 0;
					b_emission_occlusion[findex2.w] |= (dead2.w != 0) ? dead2.w : 0;
				}
				is_alive &= ~fragment_map;
				if(is_alive.xy == u64vec2(0))
				{ 
					break;
				}
			}
		}

		b_emission_reached[gl_GlobalInvocationID.x*2+gl_GlobalInvocationID.y*reso.z] = is_alive.x;
		b_emission_reached[gl_GlobalInvocationID.x*2+1+gl_GlobalInvocationID.y*reso.z] = is_alive.y;
	}

}
