#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#include "GI2D.glsl"

#define HALF_PI (1.5708)
#define TWO_PI (6.2832)
#define QUARTER_PI (0.7854)


layout (local_size_x=128) in;

void main()
{
	const ivec4 reso = u_gi2d_info.m_resolution;

	uint ray_index = gl_GlobalInvocationID.x + u_radiosity_info.ray_frame_max*u_gi2d_scene.m_frame;
	D2Ray ray = b_ray[ray_index];
	if(ray.march==0){ return; }
	vec2 dir = calcDir(ray.angle);
	vec2 inv_dir = abs(1./dir);

	vec2 cell_origin = vec2(greaterThanEqual(dir, vec2(0.))) * vec2(8.);
	uint angle_index = ray_index / 1024;

	int begin = 0;
	u16vec2 begin_pos;
	int march = 0;

	int segment_index = atomicAdd(b_segment_counter.w, 1);
	if(segment_index%1024==0){
		atomicAdd(b_segment_counter.x, 1);
	}

	bool state;
	{
		ivec2 map_index = ivec2(ray.origin);
		ivec2 cell = map_index>>3;
		vec2 pos_sub = vec2(ray.origin - vec2(cell << 3));
		ivec2 cell_sub = ivec2(pos_sub);

		uint64_t map = b_diffuse_map[getMemoryOrder(cell)];
		state = (map & (1ul<<(cell_sub.x+cell_sub.y*8))) != 0ul;
		begin_pos = u16vec2(map_index);
	}

	for(; march < ray.march; )
	{
		vec2 pos = fma(dir, float(march).xx, ray.origin);
		ivec2 map_index = ivec2(pos);
		ivec2 cell = map_index>>3;
		vec2 pos_sub = vec2(pos - vec2(cell << 3));

		vec2 tp = fma(vec2(abs(cell_origin - pos_sub)), inv_dir, float(1.).xx);
		int skip = int(min(tp.x, tp.y));

		uint64_t map = b_diffuse_map[getMemoryOrder(cell)];
		if(map == (state?-1ul:0ul))
		{
			march+=skip;
			continue;
		}

		for(uint i = 0; i < skip; i++)
		{
			ivec2 cell_sub = ivec2(fma(dir, vec2(i), pos_sub));
			bool attr = (map & (1ul<<(cell_sub.x+cell_sub.y*8))) != 0ul;
			if(state != attr)
			{
//				u16vec4 end = u16vec4(fma(dir.xyxy, vec4(float(begin).xx, float(march).xx), ray.origin.xyxy));
//				b_segment_ex[segment_index] = end;

//				uvec2 index = end.xz + end.yw * reso.xx;
				if(all(notEqual(begin_pos.xyxy, uvec4(0, 0, reso.xy-1))))
				{
					uint index = begin_pos.x + begin_pos.y * reso.x;
					uint vindex = atomicAdd(b_vertex_array[b_vertex_array_index[index]].num, 1);
					b_vertex_array[b_vertex_array_index[index]].vertex[vindex] = u16vec2((cell << 3)+cell_sub);
				}
//				if(all(notEqual(end.zwzw, uvec4(0, 0, reso.xy-1))))
//				{
//					uint vindex = atomicAdd(b_vertex_array[b_vertex_array_index[index.y]].num, 1);
//					b_vertex_array[b_vertex_array_index[index.y]].vertex[vindex] = end.xy;
//				}

				state = attr;
				begin = march;
				begin_pos = u16vec2((cell << 3)+cell_sub);

				segment_index = atomicAdd(b_segment_counter.w, 1);
				if(segment_index%1024==0){
					atomicAdd(b_segment_counter.x, 1);
				}
			}
			march++;
		}

	}
	u16vec4 end = u16vec4(fma(dir.xyxy, vec4(float(begin).xx, float(ray.march).xx), ray.origin.xyxy));
//	b_segment_ex[segment_index] = end;
	if(all(notEqual(begin_pos.xyxy, uvec4(0, 0, reso.xy-1))))
	{
		uint index = begin_pos.x + begin_pos.y * reso.x;
		uint vindex = atomicAdd(b_vertex_array[b_vertex_array_index[index]].num, 1);
		b_vertex_array[b_vertex_array_index[index]].vertex[vindex] = end.zw;
	}
//	if(all(notEqual(end.zwzw, uvec4(0, 0, reso.xy-1))))
//	{
//		uint vindex = atomicAdd(b_vertex_array[b_vertex_array_index[index.y]].num, 1);
//		b_vertex_array[b_vertex_array_index[index.y]].vertex[vindex] = end.xy;
//	}
}
