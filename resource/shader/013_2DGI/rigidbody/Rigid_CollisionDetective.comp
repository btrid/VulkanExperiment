#version 460
#extension GL_GOOGLE_include_directive : require

#define USE_Rigidbody2D 0
#define USE_GI2D 1
#include "GI2D/GI2D.glsl"
#include "GI2D/Rigidbody2D.glsl"

layout (local_size_x = RB_PARTICLE_BLOCK_SIZE) in;

#define FLT_EPSIRON (1.19209290e-07)
//#define isZero(_v) (all(lessThan((_v), vec2(FLT_EPSIRON))))
#define isZero(_v) (dot((_v), (_v)) < FLT_EPSIRON)

vec2 calcTangent(in vec2 I, in vec2 N)
{
	return I - N * dot(N, I);
}
vec2 normalize_safe(in vec2 v)
{
	return isZero(v) ? vec2(0.) : normalize(v);
}
float length_safe(in vec2 v)
{
	return isZero(v) ? 0. : length(v);
}
void main() 
{
	uint pb_id = b_pb_update_list[b_world.cpu_index*b_manager.pb_list_size+gl_WorkGroupID.x];
	uint p_id = pb_id*RB_PARTICLE_BLOCK_SIZE + gl_LocalInvocationID.x;
	if((b_rbParticle[p_id].flag_color & RBP_FLAG_ACTIVE) == 0){ return; }

	const ivec4 reso = u_gi2d_info.m_resolution;

	uint r_id = b_rbParticle_map[pb_id];

	vec2 pos = b_rbParticle[p_id].pos;
	vec2 pos_old = b_rbParticle[p_id].pos_old;
	vec2 sdf = b_rbParticle[p_id].local_sdf;
	vec2 sdf_n = normalize_safe(b_rbParticle[p_id].local_sdf);
	float mass = 1.;

	vec2 vel = pos - pos_old;
	float len = length_safe(vel);
	vec2 dir = normalize_safe(vel);

	bool is_hit = false;

	// まず壁と判定
	for(uint iter = 0; iter < len+1.; iter++)
	{
		vec2 pos_i = pos_old + dir * min(iter, len);

		uvec2 map_index = uvec2(pos_i);
		if(any(greaterThanEqual(map_index, reso.xy))){ continue; }
		uint findex = map_index.x + map_index.y * reso.x;
		vec2 sdf_j = -b_collidable_wall[findex].sdf;

		// sdfが無いなら壁ではない
		if(dot(sdf_j,sdf_j) <= 0.001){ continue; }

		vec2 pos_j = map_index + vec2(0.5);
		{
			vec2 n_vec = (pos_j - pos_i) + sdf_j;
//				pos += dot(n_vec, sdf_j) * sdf_j * ((mass /total_mass) * c);
			pos = pos_i + sdf_j;
		}
		is_hit = true;
		iter = 9999;
	}

	// 壁を抜けないならほかの動的オブジェクトと判定
	if(!is_hit)
	{
		ivec2 map_index = ivec2(pos);
		int findex = map_index.x + map_index.y * u_gi2d_info.m_resolution.x;
		int count = int(min(b_collidable_counter[findex], COLLIDABLE_NUM));

		for(uint ii = 0; ii < count; ii++)
		{
			uint fj_id = findex*COLLIDABLE_NUM + ii;
			if( b_collidable[fj_id].r_id == r_id)
			{
				// 自分とは判定しない
				continue;
			}

			vec2 pos_j = vec2(b_collidable[fj_id].grid_relative_pos) + map_index;
			vec2 rela_pos = pos-pos_j;
			if(dot(rela_pos, rela_pos) >= k_delimiter*k_delimiter)
			{
				// 距離が離れている
				continue;
			}

			vec2 sdf_j = -b_collidable[fj_id].sdf;
			float mass_j = float(b_collidable[fj_id].mass_inv);
			float c = max(dot(sdf, sdf_j), 0.);
			float s = max(cross(vec3(sdf, 0.0), vec3(sdf_j, 0.0)).z, 0.);
			float total_mass = mass + mass_j;
			{
				vec2 n_vec = (pos_j - pos) + sdf_j;
//				pos += dot(n_vec, sdf_j) * sdf_j * ((mass /total_mass) * c);
				pos += sdf_j;

//				pos += sdf_j*dot(sdf_n, normalize_safe(sdf_j));

				// 摩擦
//				vec2 t_vec = calcTangent(dir, normalize_safe(sdf_j)) * s;
//				pos -= t_vec*0.2;
			}
			is_hit = true;
		}	
	}

	if(is_hit)
	{
		b_rbParticle[p_id].flag_color |= _RBP_FLAG_COLLIDED;
		b_rbParticle[p_id].pos = pos;
	}
	else
	{
		b_rbParticle[p_id].flag_color &= ~_RBP_FLAG_COLLIDED;
	}

	if(((b_rigidbody[r_id].flag & RB_FLAG_FLUID) == 0))
	{
		ivec2 pos_integer = ivec2(round((pos-b_rigidbody[r_id].cm) * CM_WORK_PRECISION));
		atomicAdd(b_rigidbody[r_id].cm_work.x, pos_integer.x);
		atomicAdd(b_rigidbody[r_id].cm_work.y, pos_integer.y);
	}
	else
	{
		ivec2 index = ivec2(pos);
		uint i = index.x+index.y*u_gi2d_info.m_resolution.x;
		atomicAdd(b_fluid_counter[i], 1);
	}


}

