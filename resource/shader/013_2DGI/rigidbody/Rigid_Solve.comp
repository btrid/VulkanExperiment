#version 460
#extension GL_GOOGLE_include_directive : require

#define USE_Rigidbody2D 0
#define USE_GI2D 1
#include "GI2D.glsl"
#include "Rigidbody2D.glsl"

layout (local_size_x = 256) in;


vec2 rotate(in vec2 v, in float angle)
{
	float c = cos(angle);
	float s = sin(angle);

	vec2 Result;
	Result.x = v.x * c - v.y * s;
	Result.y = v.x * s + v.y * c;
	return Result;
}


vec2 calcTangent(in vec2 normal)
{
	vec3 vec = vec3(0.,0.,1.);
	return normalize(cross(vec3(normal, 0.),vec)).xy;
}

float spring = 1.2;
float decay = 0.1;
void main()
{
	uint index = gl_GlobalInvocationID.x;
	if(index >= b_constraint_count.w)
	{
		return;
	}

	Constraint constraint = b_constraint[index];

	vec2 rela_pos = constraint.ri;
	vec2 local_pos = rotate(rela_pos, b_rigidbody.angle);
	vec2 pos = b_rigidbody.pos + local_pos;

//	vec2 vel = b_rigidbody.vel+b_rigidbody.vel_delta;
	vec2 vel = b_rigidbody.vel;
//	vec2 angular_vel = cross(vec3(local_pos, 0.), vec3(0., 0., (b_rigidbody.angle_vel+b_rigidbody.angle_vel_delta)*DT)).xy;
	vec2 angular_vel = cross(vec3(local_pos, 0.), vec3(0., 0., (b_rigidbody.angle_vel)*DT)).xy;

	vec2 dir = vel + angular_vel;
	float advance = length(dir);
	dir = normalize(dir);

//	float sinking = advance;// - distance(constraint.rj, pos);
	float sinking = advance - distance(constraint.rj, pos);
	vec2 delta_linear_vel = vec2(0.);
	float delta_angular_vel = 0.;
	{
		float impluse = sinking - constraint.impulse;
//		impulse *= dot(constraint.vi,dir);

		vec2 restitution = -spring*impluse*constraint.vi; // 反発力 めり込んだ量を戻す
//		vec2 damping = -decay*advance*constraint.vi; //減衰力
		vec2 damping = vec2(0.); //減衰力
		delta_linear_vel += restitution + damping;
		delta_angular_vel += cross(vec3(local_pos, 0.), vec3(restitution + damping, 0.)).z;

		b_constraint[index].impulse += impluse;

	}
	{
//		vec2 tangent_dir = dir-dot(dir,r)*r;
//		vec2 restitution = -spring*tangent_dir;// * progress; // 反発力
//		vec2 damping = -decay * tangent_dir * advance;
//		delta_linear_vel += restitution + damping;
//		delta_angular_vel += cross(vec3(local_pos, 0.), vec3(restitution + damping, 0.)).z;
	}
	{
		atomicAdd(b_rigidbody.vel_work.x, int(delta_linear_vel.x * 65535.));
		atomicAdd(b_rigidbody.vel_work.y, int(delta_linear_vel.y * 65535.));
//		atomicAdd(b_rigidbody.angle_vel_work, int(delta_angular_vel * 65535.));
	}

}

