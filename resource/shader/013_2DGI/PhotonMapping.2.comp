#version 450

#extension GL_GOOGLE_cpp_style_line_directive : require

#include <btrlib/ConvertDimension.glsl>
#include <btrlib/Common.glsl>
#include <btrlib/Math.glsl>

#define USE_PM 0
#include <PM.glsl>

#define assert(_x) for(int i = 0; i < 10000 && (_x); i++)
layout (local_size_x = 32, local_size_y = 32) in;
shared Emission s_emission[64];
shared uint64_t s_fragment_map[16];
void main()
{
	const int hierarchy_rate[2] = {1, 8};
	const vec2 c_cell_size[2] = {vec2(1.), vec2(1.)*hierarchy_rate[1]};
	const ivec4 reso = ivec4(u_pm_info.m_resolution.xy, u_pm_info.m_resolution.xy/8);

	const ivec4 pixel = ivec4(gl_GlobalInvocationID.xy, gl_GlobalInvocationID.xy)*ivec4(2,1,2,1)+ivec4(0,0,1,0);

	const vec4 end = vec4(pixel);
	vec3 photon[2] = {vec3(0.), vec3(0.)};

	const ivec4 tile_index_2d = pixel / ivec4(u_pm_info.m_emission_tile_size.xyxy);
	const ivec2 tile_index = ivec2(tile_index_2d.xz + tile_index_2d.yw*u_pm_info.m_emission_tile_num.x);
	int emission_num = min(b_emission_tile_counter[tile_index.x], 64);
	{
		if(gl_LocalInvocationIndex < emission_num)
		{
			int emission_index = b_emission_tile_map[tile_index.x*u_pm_info.m_emission_tile_map_max + gl_LocalInvocationIndex];
			s_emission[gl_LocalInvocationIndex] = b_emission[emission_index];		
		}
		barrier();
		memoryBarrierShared();
	}
	for(int i = 0; i < emission_num; i++)
	{
		vec4 emission = s_emission[i].value;
		vec4 emission_pos = s_emission[i].pos;
		const vec4 start = emission_pos.xzxz;
		vec4 pos = start;
		ivec4 map_index = ivec4(pos / c_cell_size[0].xyxy);


		const vec4 diff = (end - pos);
		const vec2 ray_dist = vec2(length(diff.xy), length(diff.zw));

		ivec2 is_died = ivec2(lessThan(ray_dist, vec2(1.0)));
		if(all(notEqual(is_died, ivec2(0)))){
			continue;
		}

		vec4 dir = vec4(normalize(is_died.x != 0 ? vec2(1.) : diff.xy), normalize(is_died.y != 0 ? vec2(1.) : diff.zw));
		dir.x = abs(dir.x) <= FLT_EPSIRON ? FLT_EPSIRON*2. : dir.x;
		dir.y = abs(dir.y) <= FLT_EPSIRON ? FLT_EPSIRON*2. : dir.y;
		dir.z = abs(dir.z) <= FLT_EPSIRON ? FLT_EPSIRON*2. : dir.z;
		dir.w = abs(dir.w) <= FLT_EPSIRON ? FLT_EPSIRON*2. : dir.w;

		const ivec3 next_step = ivec3((dir.x < 0. ? -1 : 1), (dir.y < 0. ? -1 : 1), 0);
		const ivec3 next_step2 = ivec3((dir.z < 0. ? -1 : 1), (dir.w < 0. ? -1 : 1), 0);

		u64vec2 fragment_map;
		{
			ivec4 fragment_index = map_index/8;
			ivec2 fragment_index_1d = fragment_index.xz + fragment_index.yw*reso.z;
			fragment_map.x = is_died.x!=0 ? 0 : b_fragment_hierarchy[fragment_index_1d.x];
			fragment_map.y = is_died.y!=0 ? 0 : b_fragment_hierarchy[fragment_index_1d.y];

			ivec4 fragment_index_sub = map_index%8;
			ivec2 fragment_index_sub_1d = fragment_index_sub.xz + fragment_index_sub.yw*8;
			u64vec2 bit = u64vec2(1)<<fragment_index_sub_1d;

			is_died |= ivec2((fragment_map & bit) != u64vec2(0));
		}

		for(int i = 0; i < 50; i++)
//		for(;;)
		{
			const ivec2 hierarchy = ivec2(equal(fragment_map, u64vec2(0)));
			vec4 cell_size = vec4(c_cell_size[hierarchy.x], c_cell_size[hierarchy.y]);

			// march
			{
				vec4 cell_origin = vec4(map_index / ivec4(hierarchy_rate[hierarchy.x].xx, hierarchy_rate[hierarchy.y].xx))*cell_size;
				vec4 cell_p = pos - cell_origin;

				float x = dir.x < 0. ? cell_p.x : (cell_size.x- cell_p.x);
				float y = dir.y < 0. ? cell_p.y : (cell_size.y- cell_p.y);
				float z = dir.z < 0. ? cell_p.z : (cell_size.z- cell_p.z);
				float w = dir.w < 0. ? cell_p.w : (cell_size.w- cell_p.w);

				x = x <= FLT_EPSIRON ? (x+cell_size.x) : x;
				y = y <= FLT_EPSIRON ? (y+cell_size.y) : y;
				z = z <= FLT_EPSIRON ? (z+cell_size.z) : z;
				w = w <= FLT_EPSIRON ? (w+cell_size.w) : w;

				vec4 dist = abs(vec4(x, y, z, w) / dir.xyzw);
				int next_ = dist.x < dist.y ? 0 : 1;
				int next2_ = dist.z < dist.w ? 2 : 3;
				pos += dir * vec4(vec2(dist[next_]), vec2(dist[next2_]));

				ivec4 next;
				next.xy = next_ == 0 ? next_step.xz : next_step.zy;
				next.zw = next2_ == 2 ? next_step2.xz : next_step2.zy;
				map_index = ivec4((pos+ next*0.1) / c_cell_size[0].xyxy);
			}

			// 終了判定
			if(is_died.x == 0 && distance(start.xy, pos.xy) >= ray_dist.x)
			{
				// 距離を超えたら光がフラグメントにヒット
				photon[0] += vec3(0., 0., 1.) * emission_pos.w / (1+ray_dist.x*ray_dist.x);
				is_died.x = 1;
			}
			if(is_died.y == 0 && distance(start.zw, pos.zw) >= ray_dist.y)
			{
				// 距離を超えたら光がフラグメントにヒット
				photon[1] += vec3(0., 0., 1.) * emission_pos.w / (1+ray_dist.y*ray_dist.y);
				is_died.y = 1;
			}

			// hit確認
			{
				ivec4 fragment_index = map_index/8;
				ivec2 fragment_index_1d = fragment_index.xz + fragment_index.yw*reso.z;
				fragment_map.x = is_died.x!=0 ? 0 : b_fragment_hierarchy[fragment_index_1d.x];
				fragment_map.y = is_died.y!=0 ? 0 : b_fragment_hierarchy[fragment_index_1d.y];

				ivec4 fragment_index_sub = map_index%8;
				ivec2 fragment_index_sub_1d = fragment_index_sub.xz + fragment_index_sub.yw*8;
				u64vec2 bit = u64vec2(1)<<fragment_index_sub_1d;

				is_died |= ivec2((fragment_map & bit) != u64vec2(0));
			}

			// 終わり
			if(all(notEqual(is_died, ivec2(0))))
			{
				break;
			}
		}
	}
	const ivec2 pixel_1d = ivec2(pixel.xz + pixel.yw*u_pm_info.m_resolution.x);
	b_color[pixel_1d.x] = vec4(photon[0], 1.);
	b_color[pixel_1d.y] = vec4(photon[1], 1.);
}
