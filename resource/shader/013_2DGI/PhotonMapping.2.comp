#version 450

#extension GL_GOOGLE_cpp_style_line_directive : require

#include <btrlib/ConvertDimension.glsl>
#include <btrlib/Common.glsl>
#include <btrlib/Math.glsl>

#define USE_OIT 0
#include <OIT.glsl>

layout (local_size_x = 32, local_size_y = 32) in;
shared uint64_t s_bit[9];
void main()
{
	ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
	int pixel_1d = int(pixel.x + pixel.y*u_OIT_info.m_resolution.x);
	int tile_index = int(gl_WorkGroupID.x + gl_WorkGroupID.y*32);
	ivec2 reso = ivec2(u_OIT_info.m_resolution.xy);

	vec2 c_cell_size[2];
	c_cell_size[0] = vec2(1.);
	c_cell_size[1] = vec2(8.);

	for(int i = 0; i < b_emissive_counter.x; i++)
	{
		int emissive_pixel_index = b_emissive_tile_map[tile_index*u_OIT_info.m_emissive_tile_map_max + i];
		ivec2 emissive_pixel_index_2d = ivec2(emissive_pixel_index % u_OIT_info.m_resolution.x, emissive_pixel_index / u_OIT_info.m_resolution.y);

		ivec2 map_index = pixel;
		vec2 pos = vec2(map_index)*c_cell_size[0];

		vec2 dir = normalize(emissive_pixel_index_2d*c_cell_size[0] - pos);
		float progress = 0.;
		ivec2 next_step = ivec2(dir.x < 0. ? -1 : 1, dir.y < 0. ? -1 : 1);

		for(;;)
		{
//			ivec2 map_index_1 = map_index/8;
//			int map_index_1_1d = map_index_1.x + map_index_1.y * (640/8);
//			uint64_t fragment_map = b_fragment_hierarchy[map_index_1_1d];

			int hierarchy = 0;
			vec2 cell_size = c_cell_size[hierarchy];

			vec2 cell_origin = vec2(map_index)*cell_size;
			vec2 cell_p = pos - cell_origin;

			float x = dir.x < 0. ? cell_p.x : (cell_size.x- cell_p.x);
			float y = dir.y < 0. ? cell_p.y : (cell_size.y- cell_p.y);

			vec2 dist = vec2(9999.);
			dist.x = abs(dir.x) < FLT_EPSIRON ? 9999.9 : abs(x / dir.x);
			dist.y = abs(dir.y) < FLT_EPSIRON ? 9999.9 : abs(y / dir.y);
			float rate = min(dist.x, dist.y);
			rate = abs(dir.x) < FLT_EPSIRON ? dist.y : rate;
			rate = abs(dir.y) < FLT_EPSIRON ? dist.x : rate;

			vec2 prog = dir * rate;

			ivec2 next = ivec2(0);
			int next_dir = dist.x < dist.y ? 0 : 1;
			next[next_dir] = next_step[next_dir];

			pos += prog;
			progress += length(prog);
			map_index = map_index + next;

			if(any(greaterThanEqual(map_index, reso)) || any(lessThan(map_index, ivec2(0, 0)))) {
				// 範囲外にはならないようになるのが理想
				b_color[0] = vec4(1., 0., 0., 1.);
				break;
			}

			int map_index_1d = map_index.x + map_index.y*reso.x;
//			if(b_fragment_map[map_index_1d] != 0){
				// hit
//				b_color[pixel_1d] = vec4(0., 0., 1., 1.);
//				break;
//			}
			if(all(equal(map_index, emissive_pixel_index_2d)))
			{
				b_color[pixel_1d] = vec4(0., 0., 1., 1.);
			}
		}
	}

}