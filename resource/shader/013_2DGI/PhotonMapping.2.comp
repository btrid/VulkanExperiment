#version 450

#extension GL_GOOGLE_cpp_style_line_directive : require

#include <btrlib/ConvertDimension.glsl>
#include <btrlib/Common.glsl>
#include <btrlib/Math.glsl>

#define USE_OIT 0
#include <OIT.glsl>

layout (local_size_x = 32, local_size_y = 32) in;
shared Emission s_emission[64];
shared uint64_t s_fragment_map[16];
void main()
{
	const ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
	const int pixel_1d = int(pixel.x + pixel.y*u_OIT_info.m_resolution.x);
	const ivec2 tile_index_2d = pixel / ivec2(u_OIT_info.m_emission_tile_size.xy);
	const int tile_index = int(tile_index_2d.x + tile_index_2d.y*u_OIT_info.m_emission_tile_num.x);
	const ivec2 reso = ivec2(u_OIT_info.m_resolution.xy);

	const int hierarchy_rate[2] = {1, 8};
	const vec2 c_cell_size[2] = {vec2(1.), vec2(1.)*hierarchy_rate[1]};

	const vec2 end = vec2(pixel)*c_cell_size[0] + c_cell_size[0]*0.5;
	vec3 photon = vec3(0.);
	int emission_num = min(b_emission_tile_counter[tile_index], 64);
	if(gl_LocalInvocationIndex < emission_num)
	{
		int emission_index = b_emission_tile_map[tile_index*u_OIT_info.m_emission_tile_map_max + gl_LocalInvocationIndex];
		s_emission[gl_LocalInvocationIndex] = b_emission[emission_index];		
	}
	barrier();
	memoryBarrierShared();

	for(int i = 0; i < emission_num; i++)
	{
		vec4 emission = s_emission[i].value;
		vec4 emission_pos = s_emission[i].pos;
		const vec2 start = emission_pos.xz;

		if(dot(start, end) <= 0.001){
			continue;
		}
		const float ray_dist = distance(start, end);

		vec2 pos = start;
		ivec2 map_index = ivec2(start / c_cell_size[0]);

		vec2 dir = normalize(end - start);
		// 0除算回避
		dir.x = abs(dir.x) < FLT_EPSIRON ? FLT_EPSIRON*2. : dir.x;
		dir.y = abs(dir.y) < FLT_EPSIRON ? FLT_EPSIRON*2. : dir.y;

		const ivec3 next_step = ivec3((dir.x < 0. ? -1 : 1), (dir.y < 0. ? -1 : 1), 0);
		ivec2 next = ivec2(0);

		ivec2 map_index_1 = map_index/8;
		int map_index_1_1d = map_index_1.x + map_index_1.y * int(u_OIT_info.m_resolution.x/8);
		uint64_t fragment_map = b_fragment_hierarchy[map_index_1_1d];

		for(;;)
		{
			const int hierarchy = fragment_map == 0 ? 1 : 0;
			vec2 cell_size = c_cell_size[hierarchy];

			vec2 cell_origin = vec2((map_index+next) / hierarchy_rate[hierarchy])*cell_size + next_step*cell_size;
			vec2 xy = abs(pos - cell_origin);
			vec2 dist = abs(xy / dir);

			int next_ = dist.x < dist.y ? 0 : 1;
			next_ = dist[next_] < FLT_EPSIRON ? (1-next_) : next_;

			pos += dir * dist[next_];
			ivec2 next = (next_ == 0) ? next_step.xz : next_step.zy;

			if(distance(start, pos) >= ray_dist)
			{
				// 距離を超えたら光がフラグメントにヒット
				photon += vec3(0., 0., 1.) * emission_pos.w / (1+ray_dist);
				break;
			}

			map_index = ivec2((pos-next*0.5) / c_cell_size[0]);
			map_index_1 = map_index/8;
			map_index_1_1d = map_index_1.x + map_index_1.y * int(u_OIT_info.m_resolution.x/8);
			fragment_map = b_fragment_hierarchy[map_index_1_1d];

			ivec2 map_index_1_sub = map_index%8;
			uint bit_offset = map_index_1_sub.x + map_index_1_sub.y*8;
			uint64_t bit = uint64_t(1)<<bit_offset;
			if((fragment_map & (bit)) != 0)
			{
				// 遮蔽物
				break;
			}
		}
	}
	b_color[pixel_1d] = vec4(photon, 1.);
}