#version 450
#extension GL_GOOGLE_include_directive : require

#define USE_GI2D 0
#define USE_GI2D_Radiosity 1
#include "GI2D.glsl"

//#define HALF_PI (1.5708)
//#define TWO_PI (6.2832)
//#define QUARTER_PI (0.7854)

#define HALF_PI radians(90.)
#define TWO_PI radians(360.)
#define PI radians(180.)
#define QUARTER_PI radians(45.)

layout (local_size_x=128) in;

bool intersection(in vec4 aabb, inout vec2 pos, in vec2 dir)
{
	vec2 inv_dir = 1./normalize(dir);
	inv_dir = vec2(isnan(inv_dir)) * 0. + inv_dir;

	float tx1 = ((aabb.x - pos.x)*inv_dir.x);
    float tx2 = ((aabb.z - pos.x)*inv_dir.x);

	float tmin = min(tx1, tx2);
	float tmax = max(tx1, tx2);

	float ty1 = ((aabb.y - pos.y)*inv_dir.y);
	float ty2 = ((aabb.w - pos.y)*inv_dir.y);

	tmin = max(tmin, min(ty1, ty2));
	tmax = min(tmax, max(ty1, ty2));

	pos += normalize(dir) * tmin;
    return tmax >= tmin;
}
D2Ray makeRay(in uint x, in uint y)
{
	const ivec4 reso = u_gi2d_info.m_resolution;

	float a = TWO_PI / (gl_NumWorkGroups.y);
	float c = (a / gl_NumWorkGroups.z) * (gl_WorkGroupID.z+0.25);
	float angle = fma(a, float(y), c);

	vec2 dir = calcDir(angle);

	uint area = uint(angle / PI);
	vec2 pos;
	pos.x = (area==0) ? reso.x : 0.;
	pos.y = (area==1) ? reso.y : 0.;
	vec2 pdir;
	pdir.x = (area%2==1) ? 1 : 0;
	pdir.y = (area%2==0) ? 1 : 0;
	if((area%2==0))
	{
		pos.y += dir.y >= 0. ? -reso.y : 0.;
	}
	else
	{
		pos.x += dir.x >= 0. ? -reso.x : 0.;
	}

	pos += pdir*x;

	vec4 aabb = vec4(0.5, 0.5, reso.xy-vec2(0.5));
	if(!intersection(aabb, pos, dir))
	{
		D2Ray ray;
		ray.origin = vec2(512.);
		ray.angle = angle;
		ray.march = 0;

		return ray;
	}
	vec2 begin = pos;
	ivec2 map_index = ivec2(begin);

	ivec2 end_pos;
	end_pos.x = dir.x >= 0. ? reso.x-1 : 0;
	end_pos.y = dir.y >= 0. ? reso.y-1 : 0;
	int march_count = 0;
	for(; march_count <5000; march_count++)
	{
		// march
		{
			// DDA
			pos = fma(dir, float(march_count).xx, begin);
			map_index = ivec2(pos);
		}
		// 範囲外?
		{
			if(any(equal(map_index.xy, end_pos)))
			{
				break;
			}
		}
	}

	D2Ray ray;
	ray.origin = begin;
	ray.angle = angle;
	ray.march = march_count;

	return ray;

}

void main()
{
	uint buffer_offset = u_radiosity_info.ray_frame_max*gl_WorkGroupID.z;
	D2Ray ray = makeRay(gl_GlobalInvocationID.x, gl_WorkGroupID.y);
	b_ray[gl_GlobalInvocationID.x + gl_WorkGroupID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x + buffer_offset] = ray;
}
