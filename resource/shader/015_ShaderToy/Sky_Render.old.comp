// https://www.gamedev.net/forums/topic/680832-horizonzero-dawn-cloud-system/?page=6

#version 460
#extension GL_GOOGLE_include_directive : require

#include "Sky.glsl"

layout (local_size_x = 32, local_size_y = 32) in;

vec3 g_noise_kernel[6];
void precomputeNoiseKernel(vec3 lightDirection)
{
	vec3 up = vec3(0., 1., 0.);
	vec3 side = cross(lightDirection, normalize(up));
	side = dot(side, side) < 0.000001 ? vec3(1., 0., 0.) : normalize(side);
	up = normalize(cross(side, lightDirection));

#if 1
	g_noise_kernel[0] = lightDirection * 0.5 + side * 0.3 + up * 0.3;
	g_noise_kernel[1] = lightDirection * 1.0 + side * 0.7 + up * -0.7;
	g_noise_kernel[2] = lightDirection * 1.5 + side * -0.1 + up * 1.3;
	g_noise_kernel[3] = lightDirection * 2.0 + side * -1.1 + up * -0.3;
	g_noise_kernel[4] = lightDirection * 2.5 + side * 1.3 + up * 0.3;
	g_noise_kernel[5] = lightDirection * 3.0 + side * -0.4 + up * -1.1;
#else
	g_noise_kernel[0] = lightDirection * 1.0 + side * 0.3 + up * 0.3;
	g_noise_kernel[1] = lightDirection * 2.0 + side * 0.7 + up * -0.7;
	g_noise_kernel[2] = lightDirection * 3.0 + side * -0.1 + up * 1.3;
	g_noise_kernel[3] = lightDirection * -1. + side * -1.1 + up * -0.3;
	g_noise_kernel[4] = lightDirection * -2. + side * 1.3 + up * 0.3;
	g_noise_kernel[5] = lightDirection * -3. + side * -0.4 + up * -1.1;
#endif
}


// 光を前方または後方に散乱します。値が0の場合、等方性散乱（bsdf と同じ）が発生し、正の値が生成されます。
// -1と1の極値は、すべての光を単一方向に散乱させ、-1の場合は光に戻り、1の場合は方向を変更しません。
float henyeyGreensteinPhaseFunction(float lightDotEye, float g)
{
	return ((1. - g*g) / pow((1. + g*g - 2.*g*lightDotEye), 1.5)) / (4.*3.1415);
}

float lightEnergy(float density_sample, float precipitation, float henyeyGreensteinFactor)
{
	float beer_lambert = exp(-density_sample * precipitation);
	float powder_sugar_effect = 1. - exp(-density_sample * precipitation * 2.0);
	return 2. * beer_lambert * powder_sugar_effect * henyeyGreensteinFactor;
}


float sampleCloudDensityAlongCone(vec3 startPos, float stepSize)
{
	float rcpThickness = 1. / (stepSize * g_noise_kernel.length());
	
	float density = 0.;
	float density_along_cone = 0.;
	float transmittance = 1.;

	float lod = 0.;
	for(uint i = 0u; i < g_noise_kernel.length(); ++i)
	{
//		vec3 conePos = startPos + g_noise_kernel[i] * float(i + 1u) * 3.;
		vec3 conePos = startPos + g_noise_kernel[i];
		float height_frac = heightFraction(conePos);
		if(height_frac < 1.0 && height_frac > 0.)
		{
			vec3 weather_data = sampleWeather(conePos);
			float d = sampleCloudDensity(conePos, weather_data, height_frac, lod);
			density += d;

//			float transmittance = 1. - (density * rcpThickness);
			float t = exp(-d * getPrecipitation(weather_data));
			transmittance *= t;
			density_along_cone += (d * transmittance);
		}
//		lod += RCP_LIGHT_RAY_ITERATIONS;
	}
	return density;
	return density_along_cone;
}

void main()
{
	precomputeNoiseKernel(-uLightRay);

//	vec3 CamPos = vec3(0., 200., 100.);
//	vec3 CamDir = normalize(-CamPos);
	vec3 CamPos = vec3(0., 1., 0.);
	float s = sin(constant.window.x * 0.02);
	float c = cos(constant.window.x * 0.02);
	vec3 CamDir = normalize(vec3(s, 0.5, c));

	// カメラレイの作成
	{
		uvec3 reso = gl_NumWorkGroups * gl_WorkGroupSize;
		vec2 ndc = (vec2(gl_GlobalInvocationID.xy) / vec2(reso.xy)) * 2. -1.;
		vec3 up = vec3(0., 1., 0.);
		vec3 side = normalize(cross(CamDir, normalize(up)));
		side = dot(side, side) < 0.000001 ? vec3(1., 0., 0.) : normalize(side);
		up = normalize(cross(CamDir, side));

		float CamFov = (radians(45.0));
		vec2 aspect = vec2(float(reso.x) / float(reso.y), 1);
		CamDir = normalize(side*ndc.x + up*ndc.y + CamDir);
	}



	// 空色
	vec3 background_color = mix(vec3(.0, 0.1, 0.4), vec3(0.3, 0.6, 0.8), 1.0 - CamDir.y);
	background_color = mix(background_color, uLightColor, smoothstep(0.9999, 1.00, dot(-uLightRay, CamDir)));

	// 地面判定
	float distance_land = intersectRaySphere(CamPos, CamDir, u_planet);
	if(distance_land >= 0.)
	{
		// 地面に当たってる
		vec3 pos = CamPos + CamDir * distance_land;
		vec2 pos_i = floor(pos * 0.5).xz;
		float p = float(mod(pos_i.x + pos_i.y, 2.));
		background_color = mix(vec3(.6, .6, .6), vec3(.75, .75, .75), p);
	}

	vec4 rays;
	int count = intersectRayAtomEx(CamPos, CamDir, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), distance_land, rays);
	{

		uint sampleCount = 64;
		float transmittance = 1.;
		float density = 0.;
		float phaseFactor = henyeyGreensteinPhaseFunction(dot(-uLightRay, CamDir), 0.2);
		vec4 cloud_color = vec4(0.);
		for(int i = 0; i <count; i++)
		{
			vec3 begin = CamPos + CamDir * rays[i*2];
			vec3 end = begin + CamDir * rays[i*2+1];

//			float thickness = rays[i*2+1];
//			float rcpThickness = 1. / thickness;
//			float stepSize = thickness / float(sampleCount);
			float thickness = rays[i*2+1];
			float rcpThickness = 1. / thickness;
			float stepSize = 1;
			sampleCount = uint(thickness)+1u;

			vec3 pos = begin;
			float cloud_depth = 0.;
			for(int s = 0; s < sampleCount; s++)
			{
				float height_frac = heightFraction(pos);
				vec3 weather_data = sampleWeather(pos);
				float d = sampleCloudDensity(pos, weather_data, height_frac, 0.);

				if(d > 0.0)
				{
//					float t = exp(-d * getPrecipitation(weather_data));
//					transmittance *= t;
					float light_density = sampleCloudDensityAlongCone(pos, stepSize);
					float t = exp(-mix(light_density, d, 1.) * getPrecipitation(weather_data));
					transmittance *= t;
					
					cloud_color.xyz = cloud_color.xyz + transmittance * d * uLightColor * lightEnergy(light_density, getPrecipitation(weather_data), phaseFactor);
					cloud_color.a = cloud_color.a + (1.-cloud_color.a) * (1.-t);

					if(transmittance < 0.0001){ break; }
				}
				pos += stepSize * CamDir;
			}
		}

		background_color = mix(background_color, cloud_color.xyz/(cloud_color.a+0.0001), cloud_color.a);
	}

	// tonemapping
	{
		float exposure = 3.5;
		background_color.xyz = vec3(1.0) - exp(-exposure * background_color.xyz);
	}

	imageStore(i_render_map, ivec2(gl_GlobalInvocationID.xy), vec4(background_color.xyz, 1.));


}