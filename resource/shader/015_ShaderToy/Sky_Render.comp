// https://www.gamedev.net/forums/topic/680832-horizonzero-dawn-cloud-system/?page=6

#version 460
#extension GL_GOOGLE_include_directive : require

#include "Sky.glsl"

layout (local_size_x = 32, local_size_y = 32) in;

vec3 g_noise_kernel[4];
float g_phase_factor;
vec3 g_light_up;
vec3 g_light_side;
vec3 uCamPos;
vec3 uCamDir;
void precompute()
{
	uCamPos = vec3(0., 1., 0.);

	// カメラレイの作成
	{
		float s = sin(constant.window.x * 0.02);
		float c = cos(constant.window.x * 0.02);
		vec3 CamDir = normalize(vec3(s, 0.5, c));

//		uCamPos = vec3(400.);
//		CamDir = normalize(-uCamPos - vec3(0., 500., 0.));

		uvec3 reso = gl_NumWorkGroups * gl_WorkGroupSize;
		vec2 ndc = (vec2(gl_GlobalInvocationID.xy) / vec2(reso.xy)) * 2. -1.;
		vec3 up = vec3(0., 1., 0.);
		vec3 side = normalize(cross(CamDir, normalize(up)));
		side = dot(side, side) < 0.000001 ? vec3(1., 0., 0.) : normalize(side);
		up = normalize(cross(CamDir, side));

		float CamFov = (radians(45.0));
		vec2 aspect = vec2(float(reso.x) / float(reso.y), 1);
		uCamDir = normalize(side*ndc.x + up*ndc.y + CamDir);


	}

	{
//		uLightRay = normalize(vec3(s, c, 0.1));
//		uLightRay = normalize(vec3(0., -1., 12));

		g_light_up = vec3(0., 0., 1.); 
		g_light_side = cross(g_light_up, uLightRay);
		g_light_side = dot(g_light_side, g_light_side) < 0.00001 ? vec3(0., 1., 0.) : normalize(g_light_side);
		g_light_up = normalize(cross(uLightRay, g_light_side));

	}

	g_phase_factor = henyeyGreenstein(dot(-uLightRay, uCamDir), 0.2);

	{
		vec3 up = vec3(0., 1., 0.);
		vec3 side = cross(-uLightRay, normalize(up));
		side = dot(side, side) < 0.000001 ? vec3(1., 0., 0.) : normalize(side);
		up = normalize(cross(side, -uLightRay));

		g_noise_kernel[0] = uLightRay * 0.5 + side * 0.5 + up * 0.5;
		g_noise_kernel[1] = uLightRay * 0.5 + side * -0.5 + up * 0.5;
		g_noise_kernel[2] = uLightRay * 0.5 + side * 0.5 + up * -0.5;
		g_noise_kernel[3] = uLightRay * 0.5 + side * -0.5 + up * -0.5;
		
	}
}

float light(in vec3 pos)
{

	vec4 rays;
	if(intersectRayAtomEx(pos, -uLightRay, u_planet.xyz, vec2(u_cloud_inner.w), -1., rays) != 0)
	{
		// 星の影
		return 0.;
	}
#if 0

	int count = intersectRayAtomEx(pos, uLightRay, u_planet.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), -1, rays);
	float a = rays[1]-rays[0];

	count = intersectRayAtomEx(pos, -uLightRay, u_planet.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), -1, rays);
	float b = rays[1]-rays[0];
	float t = rays[1] / (a+b);

	vec3 p = pos - u_planet.xyz;
	
	vec3 uv = vec3(dot(p, g_light_side), t, dot(p, g_light_up)) * vec3(u_mapping, 1., u_mapping) * vec3(0.5, 1., 0.5) + vec3(0.5, 0., 0.5);

	return texture(s_shadow_map, uv).x * g_phase_factor;

#else

	int count = intersectRayAtomEx(pos, -uLightRay, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), -1., rays);

	float density = 0.;
	for(int i = 0; i <count; i++)
	{
		int step_num = 32;
		float ray_step = (rays[2*i+1]-rays[2*i]) / float(step_num);
		vec3 p = pos -uLightRay * (rays[2*i]+0.5);
		for(int s = 0; s < step_num; s++)
		{
			float height_frac = heightFraction(p);
			vec3 weather_data = sampleWeather(p);
			float d = cloud_density(p, weather_data, height_frac, 0.);

			density = density + d*getPrecipitation(weather_data) * ray_step;
			p = p - uLightRay * ray_step;
		}
		break;

	}

	return exp(-density) * g_phase_factor;
#endif
}

float SugerPowderEffect(vec3 pos)
{
	float density = 0.;
	for(int i = 0; i < g_noise_kernel.length(); i++)
	{
		vec3 p = pos + g_noise_kernel[i]*1.;
		float height_frac = heightFraction(p);
		vec3 weather_data = sampleWeather(p);
		float d = cloud_density(p, weather_data, height_frac, 0.);
		density += d;
	}

	return 1.- exp(-density);
}


void main()
{
	precompute();

	// 空色
	vec3 background_color = mix(vec3(.0, 0.1, 0.4), vec3(0.3, 0.6, 0.8), 1.0 - uCamDir.y);
	background_color = mix(background_color, uLightColor, smoothstep(0.9999, 1.00, dot(-uLightRay, uCamDir)));

	// 地面判定
	float distance_land = intersectRaySphere(uCamPos, uCamDir, u_planet);
	if(distance_land >= 0.)
	{
		// 地面に当たってる
		vec3 pos = uCamPos + uCamDir * distance_land;
		vec2 pos_i = floor(pos * 0.5).xz;
		float p = float(mod(pos_i.x + pos_i.y, 2.));
		background_color = mix(vec3(.6, .6, .6), vec3(.75, .75, .75), p);
	}

	vec4 rays;
	int count = intersectRayAtomEx(uCamPos, uCamDir, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), distance_land, rays);

	uint sampleCount = 64;
	float transmittance = 1.;
	vec3 color = vec3(0.);
	for(int i = 0; i <count; i++)
	{

		float ray_step = (rays[i*2+1] - rays[i*2]) / float(sampleCount);
		vec3 pos = uCamPos + uCamDir * (rays[i*2]+ray_step*0.5);

		for(int s = 0; s < sampleCount; s++)
		{
			float height_frac = heightFraction(pos);
			vec3 weather_data = sampleWeather(pos);
			float d = cloud_density(pos, weather_data, height_frac, 0.);

			float light = light(pos);
			float e = light * d * transmittance;

			color += e * vec3(1., 1., 1.);

			transmittance *= exp(-d*getPrecipitation(weather_data)*ray_step);
			if(transmittance < 0.001) { break; }


			pos = pos + ray_step * uCamDir;
		}
	}
	float alpha = clamp(1.-transmittance, 0., 1.);
	background_color = mix(background_color, color/(alpha+0.0001), alpha);

	// tonemapping
	{
		float exposure = 1.5;
		background_color.xyz = vec3(1.0) - exp(-exposure * background_color.xyz);
	}

	imageStore(i_render_map, ivec2(gl_GlobalInvocationID.xy), vec4(background_color.xyz, 1.));


}