// https://www.gamedev.net/forums/topic/680832-horizonzero-dawn-cloud-system/?page=6

#version 460
#extension GL_GOOGLE_include_directive : require

#include "Sky.glsl"

layout (local_size_x = 32, local_size_y = 32) in;

vec3 g_noise_kernel[4];
float g_phase_factor;
vec3 uCamPos;
vec3 uCamDir;
void precompute()
{
	uCamPos = vec3(0., 1., 0.);

	// カメラレイの作成
	{
		float s = sin(constant.window.x * 0.02);
		float c = cos(constant.window.x * 0.02);
		vec3 CamDir = normalize(vec3(s, 0.5, c));

		uvec3 reso = gl_NumWorkGroups * gl_WorkGroupSize;
		vec2 ndc = (vec2(gl_GlobalInvocationID.xy) / vec2(reso.xy)) * 2. -1.;
		vec3 up = vec3(0., 1., 0.);
		vec3 side = normalize(cross(CamDir, normalize(up)));
		side = dot(side, side) < 0.000001 ? vec3(1., 0., 0.) : normalize(side);
		up = normalize(cross(CamDir, side));

		float CamFov = (radians(45.0));
		vec2 aspect = vec2(float(reso.x) / float(reso.y), 1);
		uCamDir = normalize(side*ndc.x + up*ndc.y + CamDir);
	}

	{
//		uLightRay = normalize(vec3(s, c, 0.1));
		uLightRay = normalize(vec3(0., -1., 12));
	}

	g_phase_factor = henyeyGreenstein(dot(-uLightRay, uCamDir), 0.2);

	{
		vec3 up = vec3(0., 1., 0.);
		vec3 side = cross(-uLightRay, normalize(up));
		side = dot(side, side) < 0.000001 ? vec3(1., 0., 0.) : normalize(side);
		up = normalize(cross(side, -uLightRay));

		g_noise_kernel[0] = uLightRay * 0.5 + side * 0.5 + up * 0.5;
		g_noise_kernel[1] = uLightRay * 0.5 + side * -0.5 + up * 0.5;
		g_noise_kernel[2] = uLightRay * 0.5 + side * 0.5 + up * -0.5;
		g_noise_kernel[3] = uLightRay * 0.5 + side * -0.5 + up * -0.5;
		
	}
}


float henyeyGreensteinPhaseFunction(float lightDotEye, float g){ return ((1. - g*g) / pow((1. + g*g - 2.*g*lightDotEye), 1.5)) / (4.*3.1415); }

float BeerLambert(float density, float precipitation){ return exp(-density * precipitation);}
float PowderSugarEffect(float density, float precipitation){ return 1. - exp(-density * precipitation * 2.0);}
float lightEnergy(float density, float light_density, float precipitation, float henyeyGreensteinFactor)
{
	float beer_lambert = BeerLambert(density, precipitation);
	float powder_sugar_effect = PowderSugarEffect(density, precipitation);
	return 2. * beer_lambert * powder_sugar_effect * henyeyGreensteinFactor;
}

float light(in vec3 pos)
{
	vec4 rays;
	if(intersectRayAtomEx(pos, -uLightRay, u_planet.xyz, vec2(u_planet.w), -1., rays) != 0)
	{
		// 星の影
		return 0.;
	}

	int count = intersectRayAtomEx(pos, -uLightRay, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), -1., rays);

	float density = 0.;
	for(int i = 0; i <count; i++)
	{
		float ray_step = 4.;
		int step_num = int(rays[2*i+1] / ray_step) + 1;
		vec3 p = pos + (rays[2*i]+0.5) * -uLightRay;
		for(int s = 0; s < step_num; s++)
		{
			float height_frac = heightFraction(p);
			vec3 weather_data = sampleWeather(p);
			float d = cloud_density(p, weather_data, height_frac, 0.) * ray_step;

			density = density + d*getPrecipitation(weather_data);
			p = p - uLightRay * ray_step;
		}

	}

	return exp(-density) * g_phase_factor;
}

float SugerPowderEffect(vec3 pos)
{
	float density = 0.;
	for(int i = 0; i < g_noise_kernel.length(); i++)
	{
		vec3 p = pos + g_noise_kernel[i]*1.;
		float height_frac = heightFraction(p);
		vec3 weather_data = sampleWeather(p);
		float d = cloud_density(p, weather_data, height_frac, 0.);
		density += d;
	}

	return 1.- exp(-density);
}


void main()
{
	precompute();

	// 空色
	vec3 background_color = mix(vec3(.0, 0.1, 0.4), vec3(0.3, 0.6, 0.8), 1.0 - uCamDir.y);
	background_color = mix(background_color, uLightColor, smoothstep(0.9999, 1.00, dot(-uLightRay, uCamDir)));

	// 地面判定
	float distance_land = intersectRaySphere(uCamPos, uCamDir, u_planet);
	if(distance_land >= 0.)
	{
		// 地面に当たってる
		vec3 pos = uCamPos + uCamDir * distance_land;
		vec2 pos_i = floor(pos * 0.5).xz;
		float p = float(mod(pos_i.x + pos_i.y, 2.));
		background_color = mix(vec3(.6, .6, .6), vec3(.75, .75, .75), p);
	}

	vec4 rays;
	int count = intersectRayAtomEx(uCamPos, uCamDir, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), distance_land, rays);

	uint sampleCount = 32;
	float transmittance = 1.;
	vec3 color = vec3(0.);
	for(int i = 0; i <count; i++)
	{

		vec3 pos = uCamPos + uCamDir * rays[i*2];
		float ray_step = rays[i*2+1] / float(sampleCount);

		for(int s = 0; s < sampleCount; s++)
		{
			float height_frac = heightFraction(pos);
			vec3 weather_data = sampleWeather(pos);
			float d = cloud_density(pos, weather_data, height_frac, 0.);

			float light = light(pos);
			float e = light * d * transmittance;

			color += e * vec3(1., 1., 1.);

			transmittance *= exp(-d*getPrecipitation(weather_data)*ray_step);
			if(transmittance < 0.001) { break; }


			pos = pos + ray_step * uCamDir;
		}
	}
	float alpha = clamp(1.-transmittance, 0., 1.);
	background_color = mix(background_color, color/(alpha+0.0001), alpha);

	// tonemapping
	{
		float exposure = 3.5;
		background_color.xyz = vec3(1.0) - exp(-exposure * background_color.xyz);
	}

	imageStore(i_render_map, ivec2(gl_GlobalInvocationID.xy), vec4(background_color.xyz, 1.));


}