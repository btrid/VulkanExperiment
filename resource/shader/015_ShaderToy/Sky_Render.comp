// https://www.gamedev.net/forums/topic/680832-horizonzero-dawn-cloud-system/?page=6

#version 460
#extension GL_GOOGLE_include_directive : require

#include "Sky.glsl"

layout (local_size_x = 32, local_size_y = 32) in;

#define light_num 4
vec3 g_noise_kernel[light_num];
float g_cam_phase_factor;
float g_light_phase_factor;
vec3 uCamDir;
vec3 uCamPos;
void precompute()
{
	uCamPos = vec3(0., 1., 0.);

	// カメラレイの作成
	{
		float s = sin(constant.window.x * 0.02);
		float c = cos(constant.window.x * 0.02);
		vec3 CamDir = normalize(vec3(s, 0.5, c));

		uvec3 reso = gl_NumWorkGroups * gl_WorkGroupSize;
		vec2 ndc = (vec2(gl_GlobalInvocationID.xy) / vec2(reso.xy)) * 2. -1.;
		vec3 up = vec3(0., 1., 0.);
		vec3 side = normalize(cross(CamDir, normalize(up)));
		side = dot(side, side) < 0.000001 ? vec3(1., 0., 0.) : normalize(side);
		up = normalize(cross(CamDir, side));

		float CamFov = (radians(45.0));
		vec2 aspect = vec2(float(reso.x) / float(reso.y), 1);
		uCamDir = normalize(side*ndc.x + up*ndc.y + CamDir);
	}

	{
//		uLightRay = normalize(vec3(s, c, 0.1));
		uLightRay = normalize(vec3(0., -1., 12));
	}

	g_cam_phase_factor = henyeyGreenstein(dot(-uLightRay, uCamDir), 0.9);
	g_light_phase_factor = henyeyGreenstein(dot(-uLightRay, -uLightRay), 0.2);

	{
		vec3 up = vec3(0., 1., 0.);
		vec3 side = cross(-uLightRay, normalize(up));
		side = dot(side, side) < 0.000001 ? vec3(1., 0., 0.) : normalize(side);
		up = normalize(cross(side, -uLightRay));

		g_noise_kernel[0] = uLightRay * 0.5 + side * 0.5 + up * 0.5;
		g_noise_kernel[1] = uLightRay * 0.5 + side * -0.5 + up * 0.5;
		g_noise_kernel[2] = uLightRay * 0.5 + side * 0.5 + up * -0.5;
		g_noise_kernel[3] = uLightRay * 0.5 + side * -0.5 + up * -0.5;
		
	}
}


// 光を前方または後方に散乱します。値が0の場合、等方性散乱（bsdf と同じ）が発生し、正の値が生成されます。
// -1と1の極値は、すべての光を単一方向に散乱させ、-1の場合は光に戻り、1の場合は方向を変更しません。
float henyeyGreensteinPhaseFunction(float lightDotEye, float g)
{
	return ((1. - g*g) / pow((1. + g*g - 2.*g*lightDotEye), 1.5)) / (4.*3.1415);
}

float BeerLambert(float density, float precipitation){ return exp(-density * precipitation);}
float PowderSugarEffect(float density, float precipitation){ return 1. - exp(-density * precipitation * 2.0);}
float lightEnergy(float density, float light_density, float precipitation, float henyeyGreensteinFactor)
{
	float beer_lambert = BeerLambert(density, precipitation);
	float powder_sugar_effect = PowderSugarEffect(density, precipitation);
	return 2. * beer_lambert * powder_sugar_effect * henyeyGreensteinFactor;
}

float light(vec3 pos, float ray_length)
{
	vec4 rays;
	if(intersectRayAtomEx(pos, -uLightRay, u_planet.xyz, vec2(u_planet.w), -1., rays) != 0)
	{
		// 星の影
		return 0.;
	}

	float density = 0.;
	int step_num = 8;
	float ray_step = ray_length / float(step_num);
	for(int i = 0; i < step_num; i++)
	{
		vec3 p = pos - uLightRay * (float(i)+0.5);
		float height_frac = heightFraction(p);
		vec3 weather_data = sampleWeather(p);
		float d = cloud_density(p, weather_data, height_frac, 0.) * ray_step;
		density += d;
	}

	return exp(-density);
}
float SugerPowderEffect(vec3 pos)
{
	float density = 0.;
	for(int i = 0; i < g_noise_kernel.length(); i++)
	{
		vec3 p = pos + g_noise_kernel[i]*1.;
		float height_frac = heightFraction(p);
		vec3 weather_data = sampleWeather(p);
		float d = cloud_density(p, weather_data, height_frac, 0.);
		density += d;
	}

	return 1.- exp(-density);
}


void main()
{
	precompute();

	// 空色
	vec3 background_color = mix(vec3(.0, 0.1, 0.4), vec3(0.3, 0.6, 0.8), 1.0 - uCamDir.y);
	background_color = mix(background_color, uLightColor, smoothstep(0.9999, 1.00, dot(-uLightRay, uCamDir)));

	// 地面判定
	float distance_land = intersectRaySphere(uCamPos, uCamDir, u_planet);
	if(distance_land >= 0.)
	{
		// 地面に当たってる
		vec3 pos = uCamPos + uCamDir * distance_land;
		vec2 pos_i = floor(pos * 0.5).xz;
		float p = float(mod(pos_i.x + pos_i.y, 2.));
		background_color = mix(vec3(.6, .6, .6), vec3(.75, .75, .75), p);
	}

	vec4 rays;
	int count = intersectRayAtomEx(uCamPos, uCamDir, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), distance_land, rays);
	{

		uint sampleCount = 16;
		float density = 0.;
		vec3 color = vec3(0.);
		for(int i = 0; i <count; i++)
		{
			vec3 begin = uCamPos + uCamDir * rays[i*2];
			vec3 end = begin + uCamDir * rays[i*2+1];

			float thickness = rays[i*2+1];
			float rcpThickness = 1. / thickness;
			sampleCount = uint(thickness)+1u;
			float ray_step =  thickness / float(sampleCount);

			vec3 pos = begin;
			for(int s = 0; s < sampleCount; s++)
			{
				float height_frac = heightFraction(pos);
				vec3 weather_data = sampleWeather(pos);
				float d = cloud_density(pos, weather_data, height_frac, 0.) * ray_step;
				density += d;

				float light = light(pos, rays[i*2+1] - ray_step*float(s));
				float lambert = BeerLambert(density);
				float powder = SugerPowderEffect(pos)*0.5+0.5;
				float e = light * lambert * g_cam_phase_factor;

				color += e * vec3(1., 1., 1.);
				float alpha = exp(-density);
				if(alpha < 0.00001) { break; }


				pos += ray_step * uCamDir;
			}
		}
		float alpha = min(1.-exp(-density), 1.);
		background_color = mix(background_color, color/(alpha+0.0001), alpha);
	}

	// tonemapping
	{
		float exposure = 3.5;
		background_color.xyz = vec3(1.0) - exp(-exposure * background_color.xyz);
	}

	imageStore(i_render_map, ivec2(gl_GlobalInvocationID.xy), vec4(background_color.xyz, 1.));


}