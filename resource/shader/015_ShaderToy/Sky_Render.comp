#version 460
#extension GL_GOOGLE_include_directive : require

#include "Sky.glsl"
layout (local_size_x = 32, local_size_y = 32) in;
layout(push_constant) uniform Input
{
	vec3 window;
} constant;
// https://www.gamedev.net/forums/topic/680832-horizonzero-dawn-cloud-system/?page=6



float beerLambert(float sampleDensity, float precipitation)
{
	return exp(-sampleDensity * precipitation);
}

float powder(float sampleDensity, float lightDotEye)
{
	return 1. - exp(-sampleDensity * 2.0);
}

// 光を前方または後方に散乱します。値が0の場合、等方性散乱（bsdf と同じ）が発生し、正の値が生成されます。
// -1と1の極値は、すべての光を単一方向に散乱させ、-1の場合は光に戻り、1の場合は方向を変更しません。
float henyeyGreensteinPhaseFunction(float lightDotEye, float g)
{
	return ((1. - g*g) / pow((1. + g*g - 2.*g*lightDotEye), 1.5)) / (4.*3.1415);
}

float lightEnergy(float lightDotEye, float densitySample, float originalDensity, float precipitation)
{
	return 2. *
		beerLambert(densitySample, precipitation) *
		powder(originalDensity, lightDotEye) * 
		henyeyGreensteinPhaseFunction(lightDotEye, 0.9);
}

// TODO get from cb values - has to change as time of day changes
vec3 ambientLight(float height_frac)
{
	return mix(vec3(0.5, 0.67, 0.82), vec3(1.0, 1.0, 1.0), height_frac);
}

float sampleCloudDensityAlongCone(vec3 startPos, float stepSize, float lightDotEye, float originalDensity)
{
	// random vectors on the unit sphere
	const vec3 RANDOM_VECTORS[] =
	{
		vec3( 0.38051305,  0.92453449, -0.02111345),
		vec3(-0.50625799, -0.03590792, -0.86163418),
		vec3(-0.32509218, -0.94557439,  0.01428793),
		vec3( 0.09026238, -0.27376545,  0.95755165),
		vec3( 0.28128598,  0.42443639, -0.86065785),
		vec3(-0.16852403,  0.14748697,  0.97460106),
	};
	const float RCP_LIGHT_RAY_ITERATIONS = 1. / float(RANDOM_VECTORS.length());
	
	vec3 lightStep = stepSize * -uLightRay;
	vec3 pos = startPos;
	float coneRadius = 1.0f;
	float coneStep = RCP_LIGHT_RAY_ITERATIONS;
	float densityAlongCone = 0.;
	float lod = 0.;
	float lodStride = RCP_LIGHT_RAY_ITERATIONS;
	vec3 weather_data = vec3(0.);
	float rcpThickness = 1. / (stepSize * RANDOM_VECTORS.length());
	float density = 0.;

	for(uint i = 0u; i < RANDOM_VECTORS.length(); ++i)
	{
		vec3 conePos = pos + coneRadius * RANDOM_VECTORS[i] * float(i + 1u);
		float height_frac = heightFraction(conePos);
		if(height_frac < 1.0 && height_frac > 0.)
		{
			weather_data = sampleWeather(conePos);
			float cloudDensity = sampleCloudDensity(conePos, weather_data, height_frac, lod);
			if(cloudDensity > 0.0)
			{
				density += cloudDensity;
				float transmittance = 1. - (density * rcpThickness);
				densityAlongCone += (cloudDensity * transmittance);
			}
		}
		pos += lightStep;
		coneRadius += coneStep;
		lod += lodStride;
	}
	// take additional step at large distance away for shadowing from other clouds
	pos = startPos + (lightStep * 8.);
	weather_data = sampleWeather(pos);
	float height_frac = heightFraction(pos);
	if(height_frac < 1.0 && height_frac > 0.)
	{
		float cloudDensity = sampleCloudDensity(pos, weather_data, height_frac, 0.8f);
		// no need to branch here since density variable is no longer used after this
		density += cloudDensity;
		float transmittance = 1. - saturate(density * rcpThickness);
		densityAlongCone += (cloudDensity * transmittance);
	}

	return saturate(lightEnergy(lightDotEye, densityAlongCone, originalDensity, getPrecipitation(weather_data)));
}

void main()
{
//	vec3 CamPos = vec3(0., 1. + constant.window.z, 0.);
//	vec3 CamDir = normalize(vec3(0., 10., 1000.) - CamPos);
	vec3 CamPos = vec3(0., 1., 0.);
	vec3 CamDir = normalize(vec3(1.5, 1.7, 1.5));
	uLightRay = -CamDir;
//	uLightRay = -normalize(vec3(-1.5, -10.7, 1.5));

	// カメラレイの作成
	{
		uvec3 reso = gl_NumWorkGroups * gl_WorkGroupSize;
		vec2 ndc = (vec2(gl_GlobalInvocationID.xy) / vec2(reso.xy)) * 2. -1.;
		vec3 up = vec3(0., 1., 0.); 
		vec3 side = normalize(cross(CamDir, normalize(up)));
		up = normalize(cross(CamDir, side));

		float CamFov = (radians(45.0));
		vec2 aspect = vec2(float(reso.x) / float(reso.y), 1);
		CamDir = normalize(side*ndc.x + up*ndc.y + CamDir);
	}

	// 空色
	vec3 background_color = mix(vec3(.0, 0.1, 0.4), vec3(0.3, 0.6, 0.8), 1.0 - CamDir.y);
	background_color = mix(background_color, uLightColor, smoothstep(0.9999, 1.00, dot(-uLightRay, CamDir)));

	// 地面判定
	float distance_land = intersectRaySphere(CamPos, CamDir, u_planet);
	if(distance_land >= 0.)
	{
		// 地面に当たってる
		vec3 pos = CamPos + CamDir * distance_land;
		vec2 pos_i = floor(pos * 0.5).xz;
		float p = float(mod(pos_i.x + pos_i.y, 2.));
		background_color = mix(vec3(.6, .6, .6), vec3(.75, .75, .75), p);
	}

	// find nearest planet surface point
		float alpha = 0.;
		vec3 color = vec3(0.);
	vec4 dist = vec4(-1.);
	if(intersectRayAtom(CamPos, CamDir, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), dist))
	{
		int count = 0;
		vec2 ray_segment[2];
		if(dist.y>0.)
		{
			// 雲の上から雲を見る
			ray_segment[count] = vec2(max(dist.x, 0.), dist.y-max(dist.x, 0.));
			count++;
		}
		if(dist.w>0. && distance_land<0.)
		{
			// 雲の下から雲を見る
			ray_segment[count] = vec2(max(dist.z, 0.), dist.w-max(dist.z, 0.));
			count++;
		}

		float transmittance = 1.;
		uint sampleCount = 128;
		float lightDotEye = dot(-uLightRay, CamDir);
		for(int i = 0; i <count; i++)
		{
			vec3 begin = CamPos + CamDir * ray_segment[i].x;
			vec3 end = begin + CamDir * ray_segment[i].y;

			vec3 dir = end - begin;
			float thickness = ray_segment[i].y;
			float rcpThickness = 1. / thickness;
			float stepSize = thickness / float(sampleCount);

			vec3 pos = begin;
			float cloud_depth = 0.;
			for(uint s = 0u; s < sampleCount; ++s)
			{
				float height_frac = heightFraction(pos);
				vec3 weather_data = sampleWeather(pos);
				float cloudDensity = sampleCloudDensity(pos, weather_data, height_frac, 0.);

				cloud_depth = cloudDensity > 0.0 ? cloud_depth + cloudDensity : 0.;
				if(cloudDensity > 0.0)
				{
					float t = exp(-cloudDensity * ABSORPTION);
					transmittance *= t;
					if (transmittance < 0.01) { i = count; break; }

					float lightDensity = sampleCloudDensityAlongCone(pos, stepSize, lightDotEye, cloudDensity);
					vec3 ambientBadApprox = ambientLight(height_frac) * min(1.0f, length(uLightColor.rgb * 0.00125)) * transmittance;
					color += transmittance * cloudDensity * vec3((uLightColor.rgb * lightDensity) + ambientBadApprox/*+ ambientLight(heightFrac)*/);
					alpha += (1.-t) *(1.-alpha);

				}
				pos = pos + CamDir * stepSize;
			}
		}

		color = mix(background_color, color/(alpha+0.0001), alpha);

	}
	// tonemapping
	{
		float exposure = 3.5;
		color.xyz = vec3(1.0) - exp(-exposure * color.xyz);
	}

	imageStore(i_render_map, ivec2(gl_GlobalInvocationID.xy), vec4(color.xyz, 1.));


}