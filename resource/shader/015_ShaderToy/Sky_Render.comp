// https://www.gamedev.net/forums/topic/680832-horizonzero-dawn-cloud-system/?page=6

#version 460
#extension GL_GOOGLE_include_directive : require

#include "Sky.glsl"

layout (local_size_x = 32, local_size_y = 32) in;

float g_phase_factor;
vec3 g_light_up;
vec3 g_light_side;
vec3 uCamPos;
vec3 uCamDir;
void precompute()
{
	uCamPos = vec3(0., 1., 0.);

	// カメラレイの作成
	{
		float s = sin(0.5);
		float c = cos(0.5);
		vec3 CamDir = normalize(vec3(s, 0.5, c));

//		uCamPos = vec3(400.);
//		CamDir = normalize(-uCamPos - vec3(0., 500., 0.));

		uvec3 reso = gl_NumWorkGroups * gl_WorkGroupSize;
		vec2 ndc = (vec2(gl_GlobalInvocationID.xy) / vec2(reso.xy)) * 2. -1.;
		vec3 up = vec3(0., 1., 0.);
		vec3 side = normalize(cross(CamDir, normalize(up)));
		side = dot(side, side) < 0.000001 ? vec3(1., 0., 0.) : normalize(side);
		up = normalize(cross(CamDir, side));

		float CamFov = (radians(45.0));
		vec2 aspect = vec2(float(reso.x) / float(reso.y), 1);
		uCamDir = normalize(side*ndc.x + up*ndc.y + CamDir);


	}

	{
//		uLightRay = normalize(vec3(s, c, 0.1));
//		uLightRay = normalize(vec3(0., -1., 12));

		g_light_up = vec3(0., 0., 1.); 
		g_light_side = cross(g_light_up, uLightRay);
		g_light_side = dot(g_light_side, g_light_side) < 0.00001 ? vec3(0., 1., 0.) : normalize(g_light_side);
		g_light_up = normalize(cross(uLightRay, g_light_side));

	}

	g_phase_factor = henyeyGreenstein(dot(-uLightRay, uCamDir), 0.2);
}

float light(in vec3 pos)
{

	vec4 rays;
	if(intersectRayAtomEx(pos, -uLightRay, u_planet.m_pos, u_planet.m_cloud_area.xx, -1., rays) != 0)
	{
		// 星の影
		return 0.;
	}
#if 1

	int count = intersectRayAtomEx(pos, uLightRay, u_planet.m_pos, u_planet.m_cloud_area, -1, rays);
	float a = rays[1]-rays[0];

	count = intersectRayAtomEx(pos, -uLightRay, u_planet.m_pos, u_planet.m_cloud_area, -1, rays);
	float b = rays[1]-rays[0];
	float t = rays[1] / (a+b);

	vec3 p = pos - u_planet.m_pos;
	
	vec3 uv = vec3(dot(p, g_light_side), t, dot(p, g_light_up)) / vec3(u_planet.m_cloud_area.y, 1., u_planet.m_cloud_area.y) * vec3(0.5, 1., 0.5) + vec3(0.5, 0., 0.5);

	return texture(s_shadow_map, uv).x * g_phase_factor;

#else

	int count = intersectRayAtomEx(pos, -uLightRay, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), -1., rays);

	float density = 0.;
	for(int i = 0; i <count; i++)
	{
		int step_num = 32;
		float ray_step = (rays[2*i+1]-rays[2*i]) / float(step_num);
		vec3 p = pos -uLightRay * (rays[2*i]+0.5);
		for(int s = 0; s < step_num; s++)
		{
			float height_frac = heightFraction(p);
			vec3 weather_data = sampleWeather(p);
			float d = cloud_density(p, weather_data, height_frac, 0.);

			density = density + d*getPrecipitation(weather_data) * ray_step;
			p = p - uLightRay * ray_step;
		}
		break;

	}

	return exp(-density) * g_phase_factor;
#endif
}

const vec3 f = vec3(0., -1., 0.);
const vec3 u = vec3(0., 0., 1.); 
const vec3 s = vec3(1., 0., 0.);
float SugerPowderEffect(vec3 pos)
{
	if(mod(constant.window.x, 1.)>0.7)
	{ 
		return 0.7; 
	}

	vec4 rays;
	intersectRayAtomEx(pos, f, u_planet.m_pos, u_planet.m_cloud_area, -1, rays);
	float a = rays[1]-rays[0];

	intersectRayAtomEx(pos, -f, u_planet.m_pos, u_planet.m_cloud_area, -1, rays);
	float b = rays[1]-rays[0];
	float t = rays[1] / (a+b);


	vec3 p = pos - u_planet.m_pos;
	vec3 uv = vec3(dot(p, s), dot(p, u), t) / vec3(u_planet.m_cloud_area.yy, 1.) * vec3(0.5, 0.5, 1.) + vec3(0.5, 0.5, 0.);

	return 1. - texture(s_along_density_map, uv).x;

}


void main()
{
	precompute();

	// 空色
	vec3 background_color = mix(vec3(0.3, 0.6, 0.9), vec3(0.4, 0.7, 1.5), 1.0 - uCamDir.y);
	background_color = mix(background_color, uLightColor, smoothstep(0.9999, 1.00, dot(-uLightRay, uCamDir)));

	// 地面判定
	float distance_land = intersectRaySphere(uCamPos, uCamDir, vec4(u_planet.m_pos, u_planet.m_radius));
	if(distance_land >= 0.)
	{
		// 地面に当たってる
		vec3 pos = uCamPos + uCamDir * distance_land;
		vec2 pos_i = floor(pos * 0.5).xz;
		float p = float(mod(pos_i.x + pos_i.y, 2.));
		background_color = mix(vec3(.6, .6, .6), vec3(.75, .75, .75), p);
	}

	vec4 rays;
	int count = intersectRayAtomEx(uCamPos, uCamDir, u_planet.m_pos, u_planet.m_cloud_area, distance_land, rays);

	uint sampleCount = 32;
	float transmittance = 1.;
	vec3 color = vec3(0.);
	for(int i = 0; i <count; i++)
	{

		float ray_step = (rays[i*2+1] - rays[i*2]) / float(sampleCount);
		vec3 begin = uCamPos + uCamDir * (rays[i*2]+ray_step*0.5);
		for(int s=0; s<sampleCount; s++)
		{
			vec3 pos = begin + uCamDir * ray_step * float(s);
			float height_frac = heightFraction(pos);
			vec3 weather_data = sampleWeather(pos);
			float d = cloud_density(pos, weather_data, height_frac, 0., true);
			if(d<=0.){ continue; }

			float light = light(pos);
			float e = light * d * transmittance;
			float powder = SugerPowderEffect(pos);

			color += e * vec3(1., 1., 1.) * powder * ray_step;

			transmittance *= exp(-d*getPrecipitation(weather_data)*ray_step);
			if(transmittance < 0.01) { break; }

		}
	}
	float alpha = clamp(1.-transmittance, 0., 1.);
	background_color = mix(background_color, color/(alpha+0.0001), alpha);

	// tonemapping
	{
		float exposure = 2.;
		background_color.xyz = vec3(1.0) - exp(-exposure * background_color.xyz);
	}

	imageStore(i_render_map, ivec2(gl_GlobalInvocationID.xy), vec4(background_color.xyz, 1.));


}