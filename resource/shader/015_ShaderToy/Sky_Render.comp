#version 460
#extension GL_GOOGLE_include_directive : require

#include "Sky.glsl"
layout (local_size_x = 32, local_size_y = 32) in;
layout(push_constant) uniform Input
{
	vec3 window;
} constant;
// https://www.gamedev.net/forums/topic/680832-horizonzero-dawn-cloud-system/?page=6

vec3 g_noise_kernel[6];
void precomputeNoiseKernel(vec3 lightDirection)
{
    vec3 maxCompUnitVector;
    if(abs(lightDirection.x) > abs(lightDirection.y) && (abs(lightDirection.x) > abs(lightDirection.z))){
        maxCompUnitVector = vec3( abs(lightDirection.x), 0.0, 0.0);
    }
    else if(abs(lightDirection.y) > abs(lightDirection.x) && (abs(lightDirection.y) > abs(lightDirection.z))){
        maxCompUnitVector = vec3(0.0, abs(lightDirection.y), 0.0);
    }
    else{
        maxCompUnitVector = vec3(0.0, 0.0, abs(lightDirection.z));
    }
    vec3 zcom = cross(lightDirection, maxCompUnitVector);
    vec3 xcom = cross(zcom, lightDirection);
    mat3 sunRotMatrix = mat3(xcom, lightDirection, zcom);
    // Noise light kernell
    g_noise_kernel[0] = sunRotMatrix * vec3(0.1, 0.25, -0.15);
    g_noise_kernel[1] = sunRotMatrix * vec3(0.2,  0.50,  0.20);
    g_noise_kernel[2] = sunRotMatrix * vec3(-0.2,   0.10, -0.10);
    g_noise_kernel[3] = sunRotMatrix * vec3(-0.05,  0.75,  0.05);
    g_noise_kernel[4] = sunRotMatrix * vec3(-0.1,   1.00,  0.00);
    g_noise_kernel[5] = sunRotMatrix * vec3(0.0,    3.00,  0.00);
}


// 光を前方または後方に散乱します。値が0の場合、等方性散乱（bsdf と同じ）が発生し、正の値が生成されます。
// -1と1の極値は、すべての光を単一方向に散乱させ、-1の場合は光に戻り、1の場合は方向を変更しません。
float henyeyGreensteinPhaseFunction(float lightDotEye, float g)
{
	return ((1. - g*g) / pow((1. + g*g - 2.*g*lightDotEye), 1.5)) / (4.*3.1415);
}

float lightEnergy(float density_sample, float precipitation, float henyeyGreensteinFactor)
{
	float beer_lambert = exp(-density_sample * precipitation);
	float powder_sugar_effect = 1. - exp(-density_sample * 2.0);
	return 2. * beer_lambert * powder_sugar_effect * henyeyGreensteinFactor;
}

// TODO get from cb values - has to change as time of day changes
vec3 ambientLight(float height_frac)
{
	return mix(vec3(0.5, 0.67, 0.82), vec3(1.0, 1.0, 1.0), height_frac);
}

float sampleCloudDensityAlongCone(vec3 startPos, float stepSize)
{
	// random vectors on the unit sphere
	const float RCP_LIGHT_RAY_ITERATIONS = 1. / float(g_noise_kernel.length());
	float rcpThickness = 1. / (stepSize * g_noise_kernel.length());

	vec3 lightStep = stepSize * -uLightRay;
	vec3 pos = startPos;
	float density = 0.;
	float lod = 0.;
	for(uint i = 0u; i < g_noise_kernel.length(); ++i)
	{
		vec3 conePos = pos + g_noise_kernel[i] * float(i + 1u);
		float height_frac = heightFraction(conePos);
		if(height_frac < 1.0 && height_frac > 0.)
		{
			vec3 weather_data = sampleWeather(conePos);
			float d = sampleCloudDensity(conePos, weather_data, height_frac, lod);
			if(d > 0.0)
			{
				float transmittance = 1. - (d * rcpThickness);
				density += (d * transmittance);
//				density += d;
			}
		}
//		lod += RCP_LIGHT_RAY_ITERATIONS;
	}

	return density;
}

void main()
{
	precomputeNoiseKernel(uLightRay);

//	vec3 CamPos = vec3(0., 200., 100.);
//	vec3 CamDir = normalize(-CamPos);
	vec3 CamPos = vec3(0., 1., 0.);
	vec3 CamDir = normalize(vec3(1.5, 1.7, 1.5));

	// カメラレイの作成
	{
		uvec3 reso = gl_NumWorkGroups * gl_WorkGroupSize;
		vec2 ndc = (vec2(gl_GlobalInvocationID.xy) / vec2(reso.xy)) * 2. -1.;
		vec3 up = vec3(0., 1., 0.); 
		vec3 side = normalize(cross(CamDir, normalize(up)));
		up = normalize(cross(CamDir, side));

		float CamFov = (radians(45.0));
		vec2 aspect = vec2(float(reso.x) / float(reso.y), 1);
		CamDir = normalize(side*ndc.x + up*ndc.y + CamDir);
	}



	// 空色
	vec3 background_color = mix(vec3(.0, 0.1, 0.4), vec3(0.3, 0.6, 0.8), 1.0 - CamDir.y);
	background_color = mix(background_color, uLightColor, smoothstep(0.9999, 1.00, dot(-uLightRay, CamDir)));

	// 地面判定
	float distance_land = intersectRaySphere(CamPos, CamDir, u_planet);
	if(distance_land >= 0.)
	{
		// 地面に当たってる
		vec3 pos = CamPos + CamDir * distance_land;
		vec2 pos_i = floor(pos * 0.5).xz;
		float p = float(mod(pos_i.x + pos_i.y, 2.));
		background_color = mix(vec3(.6, .6, .6), vec3(.75, .75, .75), p);
	}

	float alpha = 0.;
	vec3 color = vec3(0.);
	vec4 dist = vec4(-1.);
	if(intersectRayAtom(CamPos, CamDir, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), dist))
	{
		int count = 0;
		vec2 ray_segment[2];
		if(dist.y>0.)
		{
			// 雲の上から雲を見る
			ray_segment[count] = vec2(max(dist.x, 0.), dist.y-max(dist.x, 0.));
			count++;
		}
		if(dist.w>0. && distance_land<0.)
		{
			// 雲の下から雲を見る
			ray_segment[count] = vec2(max(dist.z, 0.), dist.w-max(dist.z, 0.));
			count++;
		}


		uint sampleCount = 64;
		float transmittance = 1.;
		float phaseFactor = henyeyGreensteinPhaseFunction(dot(-uLightRay, CamDir), 0.2);
		for(int i = 0; i <count; i++)
		{
			vec3 begin = CamPos + CamDir * ray_segment[i].x;
			vec3 end = begin + CamDir * ray_segment[i].y;

			vec3 dir = end - begin;
			float thickness = ray_segment[i].y;
			float rcpThickness = 1. / thickness;
			float stepSize = thickness / float(sampleCount);

			vec3 pos = begin;
			float cloud_depth = 0.;
			for(int s = 0; s < sampleCount; s++)
			{
				float height_frac = heightFraction(pos);
				vec3 weather_data = sampleWeather(pos);
				float d = sampleCloudDensity(pos, weather_data, height_frac, 0.);

				if(d > 0.0)
				{
					float t = exp(-d*getPrecipitation(weather_data));
					transmittance *= t;
//					if (transmittance < 0.01) { i = count; break; }
					vec3 p = vec3(pos.x, height_frac, pos.z) * vec3(u_mapping, 1., u_mapping);// UV[0~1]


					float light_density = sampleCloudDensityAlongCone(pos, stepSize);
//					vec2 shadow = texture(s_shadow_map, p).xy;
//					color += shadow.x * d * uLightColor.rgb * lightEnergy(light_density, getPrecipitation(weather_data), phaseFactor);
					color += transmittance  * lightEnergy(light_density, getPrecipitation(weather_data), phaseFactor);
					alpha += (1.-t) *(1.-alpha);
				}

				pos += stepSize * CamDir;
			}
		}

		color = mix(background_color, color.xyz/(alpha+0.0001), alpha);

	}
	// tonemapping
	{
		float exposure = 3.5;
		color.xyz = vec3(1.0) - exp(-exposure * color.xyz);
	}

	imageStore(i_render_map, ivec2(gl_GlobalInvocationID.xy), vec4(color.xyz, 1.));


}