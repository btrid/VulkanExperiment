// https://www.gamedev.net/forums/topic/680832-horizonzero-dawn-cloud-system/?page=6

#version 460
#extension GL_GOOGLE_include_directive : require

#include "Sky.glsl"

layout (local_size_x = 32, local_size_y = 32) in;

vec3 g_noise_kernel[4];
float g_phase_factor;
vec3 uCamPos;
vec3 uCamDir;
void precompute()
{
	uCamPos = vec3(0., 1., 0.);

	// カメラレイの作成
	{
		float s = sin(constant.window.x * 0.02);
		float c = cos(constant.window.x * 0.02);
		vec3 CamDir = normalize(vec3(s, 0.5, c));

		uvec3 reso = gl_NumWorkGroups * gl_WorkGroupSize;
		vec2 ndc = (vec2(gl_GlobalInvocationID.xy) / vec2(reso.xy)) * 2. -1.;
		vec3 up = vec3(0., 1., 0.);
		vec3 side = normalize(cross(CamDir, normalize(up)));
		side = dot(side, side) < 0.000001 ? vec3(1., 0., 0.) : normalize(side);
		up = normalize(cross(CamDir, side));

		float CamFov = (radians(45.0));
		vec2 aspect = vec2(float(reso.x) / float(reso.y), 1);
		uCamDir = normalize(side*ndc.x + up*ndc.y + CamDir);
	}

	{
//		uLightRay = normalize(vec3(s, c, 0.1));
//		uLightRay = normalize(vec3(0., -1., 12));
	}

	g_phase_factor = henyeyGreenstein(dot(-uLightRay, uCamDir), 0.2);

	{
		vec3 up = vec3(0., 1., 0.);
		vec3 side = cross(-uLightRay, normalize(up));
		side = dot(side, side) < 0.000001 ? vec3(1., 0., 0.) : normalize(side);
		up = normalize(cross(side, -uLightRay));

		g_noise_kernel[0] = uLightRay * 0.5 + side * 0.5 + up * 0.5;
		g_noise_kernel[1] = uLightRay * 0.5 + side * -0.5 + up * 0.5;
		g_noise_kernel[2] = uLightRay * 0.5 + side * 0.5 + up * -0.5;
		g_noise_kernel[3] = uLightRay * 0.5 + side * -0.5 + up * -0.5;
		
	}
}

float light(in vec3 pos)
{
#if 1
	vec3 up = vec3(0., 1., 0.); 
	vec3 side = cross(uLightRay, normalize(up));
	side = dot(side, side) < 0.00001 ? vec3(0., 0., 1.) : normalize(side);
	up = normalize(cross(side, uLightRay));

	vec3 pf = uLightRay*dot(pos, uLightRay);
	vec3 pu = up*dot(pos, up);
	vec3 ps = side*dot(pos, side);

	vec4 rays;
	int count = intersectRayAtomEx(pos-uLightRay*1000., uLightRay, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), -1, rays);
	if(count == 0){ return 0.;}

	float t = (length(pf)-rays[0]) /(rays[1]-rays[0]);

	vec3 p = vec3(pos.x, 1.-t, pos.z) * vec3(u_mapping, 1., u_mapping) * vec3(0.5, 1., 0.5) + vec3(0.5, 0., 0.5);
	return texture(s_shadow_map, p).x * g_phase_factor;

#else
	vec4 rays;
	if(intersectRayAtomEx(pos, -uLightRay, u_planet.xyz, vec2(u_planet.w), -1., rays) != 0)
	{
		// 星の影
		return 0.;
	}

	int count = intersectRayAtomEx(pos, -uLightRay, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), -1., rays);

	float density = 0.;
	for(int i = 0; i <count; i++)
	{
		int step_num = 6;
		float ray_step = rays[2*i+1] / float(step_num);
		vec3 p = pos -uLightRay * (rays[2*i]+0.5);
		for(int s = 0; s < step_num; s++)
		{
			float height_frac = heightFraction(p);
			vec3 weather_data = sampleWeather(p);
			float d = cloud_density(p, weather_data, height_frac, 0.) * ray_step;

			density = density + d*getPrecipitation(weather_data);
			p = p - uLightRay * ray_step;
		}

	}

	return exp(-density) * g_phase_factor;
#endif
}

float SugerPowderEffect(vec3 pos)
{
	float density = 0.;
	for(int i = 0; i < g_noise_kernel.length(); i++)
	{
		vec3 p = pos + g_noise_kernel[i]*1.;
		float height_frac = heightFraction(p);
		vec3 weather_data = sampleWeather(p);
		float d = cloud_density(p, weather_data, height_frac, 0.);
		density += d;
	}

	return 1.- exp(-density);
}


void main()
{
	precompute();

	// 空色
	vec3 background_color = mix(vec3(.0, 0.1, 0.4), vec3(0.3, 0.6, 0.8), 1.0 - uCamDir.y);
	background_color = mix(background_color, uLightColor, smoothstep(0.9999, 1.00, dot(-uLightRay, uCamDir)));

	// 地面判定
	float distance_land = intersectRaySphere(uCamPos, uCamDir, u_planet);
	if(distance_land >= 0.)
	{
		// 地面に当たってる
		vec3 pos = uCamPos + uCamDir * distance_land;
		vec2 pos_i = floor(pos * 0.5).xz;
		float p = float(mod(pos_i.x + pos_i.y, 2.));
		background_color = mix(vec3(.6, .6, .6), vec3(.75, .75, .75), p);
	}

	vec4 rays;
	int count = intersectRayAtomEx(uCamPos, uCamDir, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), distance_land, rays);

	uint sampleCount = 128;
	float transmittance = 1.;
	vec3 color = vec3(0.);
	for(int i = 0; i <count; i++)
	{

		float ray_step = (rays[i*2+1] - rays[i*2]) / float(sampleCount);
		vec3 pos = uCamPos + uCamDir * (rays[i*2]+ray_step*0.5);

		for(int s = 0; s < sampleCount; s++)
		{
			float height_frac = heightFraction(pos);
			vec3 weather_data = sampleWeather(pos);
			float d = cloud_density(pos, weather_data, height_frac, 0.);

			float light = light(pos);
			float e = light * d * transmittance;

			color += e * vec3(1., 1., 1.);

			transmittance *= exp(-d*getPrecipitation(weather_data)*ray_step);
			if(transmittance < 0.001) { break; }


			pos = pos + ray_step * uCamDir;
		}
	}
	float alpha = clamp(1.-transmittance, 0., 1.);
	background_color = mix(background_color, color/(alpha+0.0001), alpha);

	// tonemapping
	{
		float exposure = 3.5;
		background_color.xyz = vec3(1.0) - exp(-exposure * background_color.xyz);
	}

	imageStore(i_render_map, ivec2(gl_GlobalInvocationID.xy), vec4(background_color.xyz, 1.));


}