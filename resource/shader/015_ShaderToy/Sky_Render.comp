#version 460
#extension GL_GOOGLE_include_directive : require

#include "Sky.glsl"
layout (local_size_x = 32, local_size_y = 32) in;
#define saturate(_a) clamp(_a, 0., 1.)

// https://www.gamedev.net/forums/topic/680832-horizonzero-dawn-cloud-system/?page=6


bool intersectRayAtom(vec3 Pos, vec3 Dir, vec3 AtomPos, vec2 Area, out vec4 OutDist)
{
	vec3 RelativePos = AtomPos - Pos;
	float tca = dot(RelativePos, Dir);

	vec2 RadiusSq = Area * Area;
	float d2 = dot(RelativePos, RelativePos) - tca * tca;

	OutDist = vec4(tca) + vec4(sqrt(RadiusSq.yxxy - d2)) * vec4(-1., -1., 1., 1.);
	return d2 <= RadiusSq.y;
}

float intersectRaySphere(in vec3 origin, in vec3 ray, in vec4 sphere)
{
	vec3 relative_pos = sphere.xyz - origin;
	float tca = dot(relative_pos, ray);
//	if (tca < 0.) return -1.;

	float radiusSq = sphere.w * sphere.w;
	float d2 = dot(relative_pos, relative_pos) - tca * tca;
	if (d2 > radiusSq)
		return -1.;

	float thc = sqrt(radiusSq - d2);
	float t0 = tca - thc;
	float t1 = tca + thc;
	if (t0 < 0.) t0 = t1;
	return t0;
}
float remap(float value, float oldMin, float oldMax, float newMin, float newMax){ return newMin + (value - oldMin) / (oldMax - oldMin) * (newMax - newMin); }

vec3 sampleWeather(vec3 pos){ return texture(s_weather_map, (vec3(pos) * vec3(u_mapping, 1., u_mapping) + vec3(0.5, 0., 0.5)).xz).xyz; }
float getCoverage(vec3 weather_data){ return weather_data.r; }
float getPrecipitation(vec3 weather_data){ return weather_data.g; }
float getCloudType(vec3 weather_data){ return weather_data.b; }// weather b channel tells the cloud type 0.0 = stratus, 0.5 = stratocumulus, 1.0 = cumulus

float heightFraction(vec3 pos) { return (distance(pos,u_cloud_inner.xyz)-u_cloud_inner.w)*u_cloud_area_inv; }

vec4 mixGradients(float cloudType)
{
	#define STRATUS_GRADIENT vec4(0.02, 0.05, 0.09, 0.11)
	#define STRATOCUMULUS_GRADIENT vec4(0.02, 0.2, 0.48, 0.625)
	#define CUMULUS_GRADIENT vec4(0.01, 0.0625, 0.78, 1.0)

	float stratus = 1.0 - saturate(cloudType * 2.);
	float stratocumulus = 1.0 - abs(cloudType - 0.5) * 2.0;
	float cumulus = saturate(cloudType - 0.5) * 2.0;
	return STRATUS_GRADIENT * stratus + STRATOCUMULUS_GRADIENT * stratocumulus + CUMULUS_GRADIENT * cumulus;
}
float densityHeightGradient(float height_frac, float cloudType)
{
	vec4 cloudGradient = mixGradients(cloudType);
	return smoothstep(cloudGradient.x, cloudGradient.y, height_frac) - smoothstep(cloudGradient.z, cloudGradient.w, height_frac);
}

float sampleCloudDensity(vec3 pos, vec3 weather_data, float height_frac, float lod)
{
	if(height_frac>= 1. || height_frac <= 0.) { return 0.; } //範囲外

	pos = vec3(pos.x, height_frac, pos.z) * vec3(u_mapping, 1., u_mapping) + vec3(0.5, 0., 0.5);// UV[0~1]
	
	vec4 low_freq_noise = texture(s_cloud_map, pos);
	float low_freq_fBM = dot(low_freq_noise.yzw, vec3(0.625, 0.25, 0.125));
	float baseCloud = remap(low_freq_noise.r, -(1.0 - low_freq_fBM), 1.0, 0.0, 1.0);

	float densityGradient = densityHeightGradient(height_frac, getCloudType(weather_data));
	baseCloud *= densityGradient;

	float cloudCoverage = getCoverage(weather_data);
	float baseCloudWithCoverage = remap(baseCloud, 1.0 - cloudCoverage, 1., 0., 1.);
	baseCloudWithCoverage *= cloudCoverage;

	//// TODO add curl noise
	//// pos += curlNoise.xy * (1.0f - height_frac);

	vec3 high_freq_noise = texture(s_cloud_detail_map, pos * 10.15).xyz;
	float high_freq_fBM = dot(high_freq_noise, vec3(0.625, 0.25, 0.125));
	float high_freq_foise_modifier = mix(high_freq_fBM, 1.0 - high_freq_fBM, saturate(height_frac * 10.0f));

	baseCloudWithCoverage = remap(baseCloudWithCoverage, high_freq_foise_modifier * 0.2, 1.0, 0.0, 1.0);
	return saturate(baseCloudWithCoverage);
}

// random vectors on the unit sphere
const vec3 RANDOM_VECTORS[] =
{
	vec3( 0.38051305f,  0.92453449f, -0.02111345f),
	vec3(-0.50625799f, -0.03590792f, -0.86163418f),
	vec3(-0.32509218f, -0.94557439f,  0.01428793f),
	vec3( 0.09026238f, -0.27376545f,  0.95755165f),
	vec3( 0.28128598f,  0.42443639f, -0.86065785f),
	vec3(-0.16852403f,  0.14748697f,  0.97460106f)
};
const uint LIGHT_RAY_ITERATIONS = 6u;
const float RCP_LIGHT_RAY_ITERATIONS = 1.0f / float(LIGHT_RAY_ITERATIONS);

float beerLambert(float sampleDensity, float precipitation)
{
	return exp(-sampleDensity * precipitation);
}

float powder(float sampleDensity, float lightDotEye)
{
	float powd = 1.0f - exp(-sampleDensity * 2.0f);
	return mix(1.0f, powd, clamp((-lightDotEye * 0.5f) + 0.5f, 0., 1.));
}

float henyeyGreenstein(float lightDotEye, float g)
{
	return ((1.0f - g*g) / pow((1. + g*g - 2.*g*lightDotEye), 1.5)) / (4.*3.1415);
}

float lightEnergy(float lightDotEye, float densitySample, float originalDensity, float precipitation)
{
	return 2.0f *
		beerLambert(densitySample, precipitation) *
		powder(originalDensity, lightDotEye) * 
		mix(henyeyGreenstein(lightDotEye, 0.2f), henyeyGreenstein(lightDotEye, -0.5f), 0.5f);
}

// TODO get from cb values - has to change as time of day changes
vec3 ambientLight(float height_frac)
{
	return mix(vec3(0.5f, 0.67f, 0.82f), vec3(1.0f, 1.0f, 1.0f), height_frac);
}

float sampleCloudDensityAlongCone(vec3 startPos, float stepSize, float lightDotEye, float originalDensity)
{
	vec3 lightStep = stepSize * -uLightRay;
	vec3 pos = startPos;
	float coneRadius = 1.0f;
	float coneStep = RCP_LIGHT_RAY_ITERATIONS;
	float densityAlongCone = 0.;
	float lod = 0.;
	float lodStride = RCP_LIGHT_RAY_ITERATIONS;
	vec3 weather_data = vec3(0.);
	float rcpThickness = 1. / (stepSize * LIGHT_RAY_ITERATIONS);
	float density = 0.;

	for(uint i = 0u; i < LIGHT_RAY_ITERATIONS; ++i)
	{
		vec3 conePos = pos + coneRadius * RANDOM_VECTORS[i] * float(i + 1u);
		float height_frac = heightFraction(conePos);
		if(height_frac <= 1.0)
		{
			weather_data = sampleWeather(conePos);
			float cloudDensity = sampleCloudDensity(conePos, weather_data, height_frac, lod);
			if(cloudDensity > 0.0)
			{
				density += cloudDensity;
				float transmittance = 1.0f - (density * rcpThickness);
				densityAlongCone += (cloudDensity * transmittance);
			}
		}
		pos += lightStep;
		coneRadius += coneStep;
		lod += lodStride;
	}
	// take additional step at large distance away for shadowing from other clouds
	pos = pos + (lightStep * 8.0f);
	weather_data = sampleWeather(pos);
	float height_frac = heightFraction(pos);
	if(height_frac <= 1.0f)
	{
		float cloudDensity = sampleCloudDensity(pos, weather_data, height_frac, 0.8f);
		// no need to branch here since density variable is no longer used after this
		density += cloudDensity;
		float transmittance = 1.0f - saturate(density * rcpThickness);
		densityAlongCone += (cloudDensity * transmittance);
	}

	return saturate(lightEnergy(lightDotEye, densityAlongCone, originalDensity, mix(1., 2., getPrecipitation(weather_data))));
}

vec4 traceClouds(vec3 viewDirW, vec3 startPos, vec3 endPos)
{
	vec3 dir = endPos - startPos;
	float thickness = length(dir);
	float rcpThickness = 1. / thickness;
	uint sampleCount = 16;
	float stepSize = thickness / float(sampleCount);
	dir /= thickness;
	vec3 posStep = stepSize * dir;

	float lightDotEye = dot(-uLightRay, viewDirW);

	vec3 pos = startPos;
	vec3 weather_data = vec3(0.);
	vec4 result = vec4(0.);
	float density = 0.;
	
	for(uint i = 0u; i < sampleCount; ++i)
	{
		float height_frac = heightFraction(pos);
		weather_data = sampleWeather(pos);
		float cloudDensity = sampleCloudDensity(pos, weather_data, height_frac, 0.);

		if(cloudDensity > 0.0)
		{
			density += cloudDensity;
			float transmittance = 1. - (density * rcpThickness);
			float lightDensity = sampleCloudDensityAlongCone(pos, stepSize, lightDotEye, cloudDensity);

			vec3 ambientBadApprox = ambientLight(height_frac) * min(1.0f, length(uLightColor.rgb * 0.925)) * transmittance;
			vec4 source = vec4((uLightColor.rgb * lightDensity) + ambientBadApprox/*+ ambientLight(heightFrac)*/, cloudDensity * transmittance); // TODO enable ambient when added to constant buffer
			source.rgb *= source.a;
			result = (1.0 - result.a) * source + result;
			if(result.a >= 1.0) break;
		}

		pos += posStep;
	}

	// experimental fog - may not be needed if clouds are drawn before atmosphere - would have to draw sun by itself, then clouds, then atmosphere
	// fogAmt = 0 to disable
//	float fogAmt = 1.0f - exp(-distance(startPos, uCamPos) * 0.00001f);
//	vec3 fogColor = vec3(0.3f, 0.4f, 0.45f) * length(uLightColor.rgb * 0.125f) * 0.8f;
//	vec3 sunColor = normalize(uLightColor.rgb) * 4.0f * length(uLightColor.rgb * 0.125f);
//	fogColor = mix(fogColor, sunColor, pow(saturate(lightDotEye), 8.0f));
//	return vec4(clamp(mix(result.rgb, fogColor, fogAmt), 0.0f, 1000.0f), saturate(result.a));
	return saturate(vec4(result));
}

void main()
{
//	ivec3 loadIndices = ivec3(pIn.posH.xy, 0);
//	float zwDepth = depthTexture.Load(loadIndices).r;
	bool depthPresent = false;
//	float depth = linearizeDepth(zwDepth);
	float depth = 9999999999.;
//	vec3 posV = pIn.viewRay * depth;
//	vec3 posW = mul(vec4(posV, 1.0f), cb_inverseViewMatrix).xyz;
	vec3 CamPos = vec3(0., 1., 0.);
	vec3 CamDir = normalize(vec3(1.5, 1.7, 1.5));

	// カメラレイの作成
	{
		uvec3 reso = gl_NumWorkGroups * gl_WorkGroupSize;
		vec2 ndc = (vec2(gl_GlobalInvocationID.xy) / vec2(reso.xy)) * 2. -1.;
		vec3 up = vec3(0., 1., 0.); 
		vec3 side = normalize(cross(CamDir, normalize(up)));
		up = normalize(cross(CamDir, side));

		float CamFov = (radians(45.0));
		vec2 aspect = vec2(float(reso.x) / float(reso.y), 1);
		CamDir = normalize(side*ndc.x + up*ndc.y + CamDir);
	}
	uCamPos = CamPos;
	uCamDir = CamDir;

	// 地面判定
	float distance_land = intersectRaySphere(CamPos, CamDir, u_planet);
	if(distance_land >= 0.)
	{
		// 地面に当たってる
		vec3 pos = CamPos + CamDir * distance_land;
		vec2 pos_i = floor(pos * 0.5).xz;
		float p = float(mod(pos_i.x + pos_i.y, 2.));
		vec3 ground_color = mix(vec3(.6, .6, .6), vec3(.75, .75, .75), p);
		imageStore(i_render_map, ivec2(gl_GlobalInvocationID.xy), vec4(ground_color, 1.));
		return;
	}

	// find nearest planet surface point
	vec4 dist;
	if(!intersectRayAtom(CamPos, CamDir, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), dist))
	{
		// 雲にヒットしない
		imageStore(i_render_map, ivec2(gl_GlobalInvocationID.xy), vec4(1.,0., 1., 1.));
		return;
	}
	
	vec3 sky_color = mix(vec3(.0, 0.1, 0.4), vec3(0.3, 0.6, 0.8), 1.0 - CamDir.y);
	sky_color = mix(sky_color, uLightColor, smoothstep(0.9999, 1.00, dot(-uLightRay, CamDir)));

	int count = 0;
	vec2 ray_segment[2];
	if(dist.y>0.)
	{
		// 雲の上から雲を見る
		ray_segment[count] = vec2(max(dist.x, 0.), dist.y-max(dist.x, 0.));
		count++;
	}
	if(dist.w>0. && distance_land<0.)
	{
		// 雲の下から雲を見る
		ray_segment[count] = vec2(max(dist.z, 0.), dist.w-max(dist.z, 0.));
		count++;
	}

	for(int i = 0; i <count; i++)
	{
		vec3 begin = CamPos + CamDir * ray_segment[i].x;
		vec3 end = begin + CamDir * ray_segment[i].y;
		vec4 color = traceClouds( CamDir, begin, end);
		color.xyz = mix(sky_color, color.xyz/(color.a+0.0001), color.a);

		// tonemapping
		{
			float exposure = 2.5;
			color.xyz = vec3(1.0) - exp(-exposure * color.xyz);
		}

		imageStore(i_render_map, ivec2(gl_GlobalInvocationID.xy), vec4(color.xyz, 1.));
		return;
	}

	imageStore(i_render_map, ivec2(gl_GlobalInvocationID.xy), vec4(0.,0., 1., 1.));

}