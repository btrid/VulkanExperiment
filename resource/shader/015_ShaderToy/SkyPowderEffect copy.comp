#version 460
#extension GL_GOOGLE_include_directive : require

#include "Sky.glsl"

layout (local_size_x = 32, local_size_y = 32) in;

shared vec3 s_density[32][32];
shared int s_count[32][32];
shared vec4 s_rays[32][32];

void compute()
{

}
void main()
{
	ivec2 global = ivec2(gl_WorkGroupID.xy*gl_WorkGroupSize.xy);

	vec3 CamPos = vec3(0., 1., 0.);
	vec3 CamDir = uLightRay;

	vec3 up; 
	vec3 side;
	ivec3 reso = imageSize(i_density_along_map);


	// カメラ位置の作成
	{

		up = vec3(0., 0., 1.); 
		side = cross(normalize(up), CamDir);
		side = dot(side, side) < 0.00001 ? vec3(0., 1., 0.) : normalize(side);
		up = normalize(cross(CamDir, side));

		vec2 ndc = ((vec2(gl_GlobalInvocationID.xy)+0.5) / vec2(reso.xz)) * 2. -1.;
		ndc *= vec2(u_cloud_outer.w);
		CamPos = side*ndc.x + up*ndc.y -CamDir*3000. + u_planet.xyz;
	}


	// 事前計算
	{
		ivec2 local = ivec2(gl_LocalInvocationID.xy);

		vec2 ndc = ((vec2(global + local)+0.5) / vec2(reso.xz)) * 2. -1.;
		ndc *= vec2(u_cloud_outer.w);
		vec3 CamPos = side*ndc.x + up*ndc.y -CamDir*3000. + u_planet.xyz;
		s_count[local.y][local.x] = intersectRayAtomEx(CamPos, CamDir, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), -1, s_rays[local.y][local.x]);


		float step = (s_rays[local.y][local.x][1] - s_rays[local.y][local.x][0]) / float(sampleCount);
		vec3 pos = CamPos + CamDir * (s_rays[local.y][local.x][0]+step*0.5);

		for(int ii = 0; ii<3; ii++)
		{
			vec3 p = pos + CamDir * (ii-1) * step;
			float height_frac = heightFraction(p);
			vec3 weather_data = sampleWeather(p);
			float d = cloud_density(pos, weather_data, height_frac, 0., true);

			s_density[local.y][local.x][ii] = d;
		}
	}
	
	int sampleCount = reso.y;
	float density = 0.;
	ivec2 local = ivec2(gl_LocalInvocationID.xy) + ivec2(1, 0);
//	for(int i = 0; i <count; i++)
	{
		vec2 ndc = ((vec2(global + local)+0.5) / vec2(reso.xz)) * 2. -1.;
		ndc *= vec2(u_cloud_outer.w);
		vec3 CamPos = side*ndc.x + up*ndc.y -CamDir*3000. + u_planet.xyz;
		float step = (s_rays[local.y][local.x][1] - s_rays[local.y][local.x][0]) / float(sampleCount);
		vec3 pos = CamPos + CamDir * (s_rays[local.y][local.x][0]+step*0.5);

		for(int s = 1; s < sampleCount; s++)
		{
			imageStore(i_along_density_map, ivec3(gl_GlobalInvocationID.x, s, gl_GlobalInvocationID.y), ivec4(exp(-density)*65535.));

			pos = fma(CamDir, vec3(step), pos);
			break;
		}
	}

}