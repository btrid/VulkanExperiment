#version 460
#extension GL_GOOGLE_include_directive : require

#include "Sky.glsl"

layout (local_size_x = 32, local_size_y = 32) in;



void main()
{

	vec3 CamPos = vec3(0., 1., 0.);
	vec3 CamDir = uLightRay;
	ivec3 reso = imageSize(i_shadow_map);

	// カメラ位置の作成
	{
		vec2 ndc = ((vec2(gl_GlobalInvocationID.xy)+0.5) / vec2(reso.xz)) * 2. -1.;
		ndc /= vec2(u_mapping);

		vec3 up = vec3(0., 0., 1.); 
		vec3 side = cross(normalize(up), CamDir);
		side = dot(side, side) < 0.00001 ? vec3(0., 1., 0.) : normalize(side);
		up = normalize(cross(CamDir, side));

		CamPos = side*ndc.x + up*ndc.y -CamDir*3000. + u_planet.xyz;

	}

	// find nearest planet surface point
	vec4 rays;
	int count = intersectRayAtomEx(CamPos, CamDir, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), -1, rays);

	int sampleCount = reso.y;
	float density = 0.;
	for(int i = 0; i <count; i++)
	{
		float step = (rays[i*2+1] - rays[i*2]) / float(sampleCount);
		vec3 pos = CamPos + CamDir * (rays[i*2]+step*0.5);
		for(int s = 0; s < sampleCount; s++)
		{
			float height_frac = heightFraction(pos);
			vec3 weather_data = sampleWeather(pos);
			float d = cloud_density(pos, weather_data, height_frac, 0.);

			density = fma(d, getPrecipitation(weather_data)*step, density);

			imageStore(i_shadow_map, ivec3(gl_GlobalInvocationID.x, s, gl_GlobalInvocationID.y), ivec4(exp(-density)*65535.));
//			imageStore(i_shadow_map, ivec3(gl_GlobalInvocationID.x, s, gl_GlobalInvocationID.y), ivec4(exp(-density)*255.));

			pos = fma(CamDir, vec3(step), pos);
		}
		break;
	}

}