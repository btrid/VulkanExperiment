#version 460
#extension GL_GOOGLE_include_directive : require

#include "Sky.glsl"

layout (local_size_x = 32, local_size_y = 32) in;



void main()
{

	vec3 CamPos = vec3(0., 1., 0.);
	vec3 CamDir = vec3(0., -1., 0.);

	// カメラ位置の作成
	{
		uvec3 reso = gl_NumWorkGroups * gl_WorkGroupSize;
		vec2 ndc = ((vec2(gl_GlobalInvocationID.xy)+0.5) / vec2(reso.xy)) * 2. -1.;
		ndc /= vec2(u_mapping);

/*		vec3 up = vec3(0., 1., 0.); 
		vec3 side = cross(uLightRay, normalize(up));
		side = dot(side, side) < 0.000001 ? vec3(1., 0., 0.) : normalize(side);
		up = normalize(cross(side, uLightRay));
*/
		vec3 up = vec3(0., 0., 1.); 
		vec3 side = vec3(1., 0., 0.);
		CamPos = side*ndc.x + up*ndc.y -CamDir*2000.;


/*
		vec2 ndc = vec2(gl_GlobalInvocationID.xy) / vec2(reso.xy);
		float s = sin(ndc.x*6.28);
		float c = cos(ndc.x*6.28);
		vec3 dir = normalize(vec3(s, 0., c)) * ndc.y;
		dir /= (vec3(u_mapping, 1., u_mapping));


		CamPos = dir - CamDir*2000.;
*/

	}

	// find nearest planet surface point
	vec4 ray_segment;
	int count = intersectRayAtomEx(CamPos, CamDir, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), -1, ray_segment);
	int sampleCount = 32;
	float transmittance = 1.;
	for(int i = 0; i <1; i++)
	{
		float step = (ray_segment[i*2+1] - ray_segment[i*2]) / float(sampleCount);
		vec3 pos = CamPos + CamDir * (ray_segment[i*2]+step*0.5);
//		float step = (ray_segment[i*2+1]) / float(sampleCount);
//		vec3 pos = CamPos + CamDir * (ray_segment[i*2] + 0.5);
		for(int s = 0; s < sampleCount; s++)
		{
			float height_frac = heightFraction(pos);
			vec3 weather_data = sampleWeather(pos);
			float density = cloud_density(pos, weather_data, height_frac, 0.);

			transmittance *= exp(-density*getPrecipitation(weather_data)*step);

//			vec3 uv = getAtmosphereUV(pos);
			float t = float(s)/float(sampleCount);
//			float t = heightFraction(pos);
			vec3 uv = vec3(pos.x, t, pos.z) * vec3(u_mapping, 1., u_mapping) * vec3(0.5, 1., 0.5) + vec3(0.5, 0., 0.5);// UV[0~1]

			imageStore(i_shadow_map, ivec3(uv*imageSize(i_shadow_map)), ivec4(vec2(transmittance).xxxx*255.));

			pos = pos + CamDir * step;
		}
	}

	if(count==0)
	{
		for(int s = 0; s < sampleCount; s++)
		{
			imageStore(i_shadow_map, ivec3(gl_GlobalInvocationID.x, s, gl_GlobalInvocationID.y), ivec4(s/float(sampleCount) * 255.));
		}
	}

}