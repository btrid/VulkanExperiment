#version 460
#extension GL_GOOGLE_include_directive : require

#include "Sky.glsl"

layout (local_size_x = 32, local_size_y = 32) in;

layout(push_constant) uniform Input
{
	vec3 window;
} constant;


void main()
{

	vec3 CamPos = vec3(0., 1., 0.);
	vec3 CamDir = uLightRay;

	// カメラ位置の作成
	{
		uvec3 reso = gl_NumWorkGroups * gl_WorkGroupSize;
		vec2 ndc = ((vec2(gl_GlobalInvocationID.xy) + 0.5) / vec2(reso.xy)) * 2. -1.;
		ndc /= vec2(u_mapping);

		vec3 up = vec3(0., 1., 0.); 
		vec3 side = cross(uLightRay, normalize(up));
		side = dot(side, side) <= 0.000001 ? vec3(1., 0., 0.) : normalize(side);
		up = normalize(cross(side, uLightRay));
		CamPos = side*ndc.x + up*ndc.y -uLightRay*3000.;
	}

	// find nearest planet surface point
	vec4 dist = vec4(-1.);
	if(intersectRayAtom(CamPos, CamDir, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), dist))
	{
		int count = 0;
		vec2 ray_segment[2];
		if(dist.y>0.)
		{
			// 雲の上から雲を見る
			ray_segment[count] = vec2(max(dist.x, 0.), dist.y-max(dist.x, 0.));
			count++;
		}
		int sampleCount = 16;
		float transmittance = 1.;
		for(int i = 0; i <count; i++)
		{
			float step = ray_segment[i].y / float(sampleCount);
			vec3 pos = CamPos + CamDir * (ray_segment[i].x + 0.5);
			
			for(int s = 0; s < sampleCount; s++)
			{
				float height_frac = heightFraction(pos);
				vec3 weather_data = sampleWeather(pos);
				float density = sampleCloudDensity(pos, weather_data, height_frac, 0.);

				transmittance *= exp(-density*getPrecipitation(weather_data));

				vec3 p = vec3(pos.x, height_frac, pos.z) * vec3(u_mapping, 1., u_mapping) * vec3(0.5, 1., 0.5) + vec3(0.5, 0., 0.5);// UV[0~1]
				imageStore(i_shadow_map, ivec3(p*imageSize(i_shadow_map)), ivec4(transmittance*255.));

				pos = pos + CamDir * step;		
			}
		}
	}

}