#version 460
#extension GL_GOOGLE_include_directive : require

#include "Sky.glsl"

layout (local_size_x = 32, local_size_y = 32) in;

//shared vec3 s_density[32+2][32+2];
shared vec4 s_begin_step[32+2][32+2];

vec3 g_density[3][3];

void store(/*ivec2 local, ivec2 offset, */int y)
{
	for(int _z = -1; _z<=1; _z++)
	for(int _x = -1; _x<=1; _x++)
	{
		ivec2 local = ivec2(gl_LocalInvocationID.xy) + 1 + ivec2(_x, _z);
		vec4 pos_step = s_begin_step[local.y][local.x];
		vec3 p = pos_step.xyz + uLightRay * pos_step.w*y;

		float height_frac = heightFraction(p);
		vec3 weather_data = sampleWeather(p);
		float d = cloud_density(p, weather_data, height_frac, 0., true);
		if(pos_step.w<0.)
		{
			// cloudにヒットしない
			d=0.;
		}

		g_density[_z+1][_x+1][(y+1)%3] = d;
	}


}
void main()
{

	vec3 CamDir = uLightRay;
	vec3 up; 
	vec3 side;
	ivec3 reso = imageSize(i_along_density_map);
	int sampleCount = reso.y;


	// カメラ位置の作成
	{

		up = vec3(0., 0., 1.); 
		side = cross(normalize(up), CamDir);
		side = dot(side, side) < 0.00001 ? vec3(0., 1., 0.) : normalize(side);
		up = normalize(cross(CamDir, side));

	}


	if(gl_LocalInvocationIndex<34*16)
	{
		ivec2 global = ivec2(gl_WorkGroupID.xy*gl_WorkGroupSize.xy);
		for(int yy = 0; yy<2; yy++)
		{
			ivec2 local = ivec2(gl_LocalInvocationIndex%34, gl_LocalInvocationIndex/34 * yy);
			vec2 ndc = ((vec2(global + local)+0.5) / vec2(reso.xz)) * 2. -1.;
			ndc *= vec2(u_cloud_outer.w);
			vec3 CamPos = side*ndc.x + up*ndc.y -CamDir*3000. + u_planet.xyz;

			vec4 rays;
			int count = intersectRayAtomEx(CamPos, CamDir, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), -1, rays);

			float step = (rays[1] - rays[0]) / float(sampleCount);
			vec3 pos = CamPos + CamDir * (rays[0]+step*0.5);
			s_begin_step[local.y][local.x] = vec4(pos, step);

			if(count==0){s_begin_step[local.y][local.x]=vec4(-1.); }

		}
	}

	barrier();
	memoryBarrierShared();

	for(int y = -1; y<=0; y++)
	{
		store(y);
	}
	
	float density = 0.;
	ivec2 local = ivec2(gl_LocalInvocationID.xy) + ivec2(1, 1);
	{
//		vec2 ndc = ((vec2(gl_GlobalInvocationID.xy)+0.5) / vec2(reso.xz)) * 2. -1.;
//		ndc *= vec2(u_cloud_outer.w);
//		vec3 CamPos = side*ndc.x + up*ndc.y -CamDir*3000. + u_planet.xyz;

		vec4 pos_step = s_begin_step[local.y][local.x];
		vec3 pos = pos_step.xyz;
		float step = pos_step.w;

		for(int s = 0; s < sampleCount; s++)
		{
			store(s+1);
			
			float density = 0.;
			density += dot(g_density[0][0], vec3(1.))+dot(g_density[0][1], vec3(1.,1.,1.))+dot(g_density[0][2], vec3(1.));
			density += dot(g_density[1][0], vec3(1.))+dot(g_density[1][1], vec3(1.,0.,1.))+dot(g_density[1][2], vec3(1.));
			density += dot(g_density[2][0], vec3(1.))+dot(g_density[2][1], vec3(1.,1.,1.))+dot(g_density[2][2], vec3(1.));
			imageStore(i_along_density_map, ivec3(gl_GlobalInvocationID.x, s, gl_GlobalInvocationID.y), ivec4(exp(-density)*65535.));

			pos = fma(CamDir, vec3(step), pos);
			break;
		}
	}

}