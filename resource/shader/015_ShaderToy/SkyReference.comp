#version 460
#extension GL_GOOGLE_include_directive : require

#include "Sky.glsl"

// 雲の光の吸収量
#define ABSORPTION		0.15

layout (local_size_x = 32, local_size_y = 32) in;

float rand(in vec3 co)
{
	return fract(sin(dot(co, vec3(12.98,78.23, 45.41))) * 43758.5);
}
float _noise1(in vec3 pos)
{
	vec3 ip = floor(pos);
	vec3 fp = smoothstep(0., 1., fract(pos));
	vec2 offset = vec2(0., 1.);
	vec4 a = vec4(rand(ip+offset.xxx),rand(ip+offset.yxx),rand(ip+offset.xyx),rand(ip+offset.yyx));
	vec4 b = vec4(rand(ip+offset.xxy),rand(ip+offset.yxy),rand(ip+offset.xyy),rand(ip+offset.yyy));
	a = mix(a, b, fp.z);
	a.xy = mix(a.xy, a.zw, fp.y);
	return mix(a.x, a.y, fp.x);
}

/*
float grad(int hash, vec3 fp)
{
    switch(hash & 0xF)
    {
        case 0x0: return  fp.x + fp.y;
        case 0x1: return -fp.x + fp.y;
        case 0x2: return  fp.x - fp.y;
        case 0x3: return -fp.x - fp.y;
        case 0x4: return  fp.x + fp.z;
        case 0x5: return -fp.x + fp.z;
        case 0x6: return  fp.x - fp.z;
        case 0x7: return -fp.x - fp.z;
        case 0x8: return  fp.y + fp.z;
        case 0x9: return -fp.y + fp.z;
        case 0xA: return  fp.y - fp.z;
        case 0xB: return -fp.y - fp.z;
        case 0xC: return  fp.y + fp.x;
        case 0xD: return -fp.y + fp.z;
        case 0xE: return  fp.y - fp.x;
        case 0xF: return -fp.y - fp.z;
    }
	return 0.;
}
float _noise2(in vec3 pos)
{
	ivec3 ip = ivec3(floor(pos))%ivec3(hash_size/2-1);
	vec3 fp = smoothstep(0., 1., fract(pos));

	int aaa, aba, aab, abb, baa, bba, bab, bbb;
	aaa = u_hash[u_hash[u_hash[ip.x]+ip.y]+ip.z];
	aba = u_hash[u_hash[u_hash[ip.x]+ip.y+1]+ip.z];
	aab = u_hash[u_hash[u_hash[ip.x]+ip.y]+ip.z+1];
	abb = u_hash[u_hash[u_hash[ip.x]+ip.y+1]+ip.z+1];
	baa = u_hash[u_hash[u_hash[ip.x+1]+ip.y]+ip.z];
	bba = u_hash[u_hash[u_hash[ip.x+1]+ip.y+1]+ip.z];
	bab = u_hash[u_hash[u_hash[ip.x+1]+ip.y]+ip.z+1];
	bbb = u_hash[u_hash[u_hash[ip.x+1]+ip.y+1]+ip.z+1];

	float x1, x2, y1, y2;
	x1 = mix(grad(aaa, fp), grad(baa, fp-vec3(1., 0., 0.)), fp.x);
	x2 = mix(grad(aba, fp-vec3(0.,1.,0.)),grad(bba, fp-vec3(1.,1.,0.)),fp.x);
	y1 = mix(x1, x2, fp.y);
	x1 = mix(grad(aab, fp-vec3(0.,0.,1)), grad(bab, fp-vec3(1.,0.,1)),fp.x);
	x2 = mix(grad(abb, fp-vec3(0.,1.,1)), grad(bbb, fp-vec3(1.,1.,1)),fp.x);
	y2 = mix(x1, x2, fp.y);
	return mix(y1, y2, fp.z)*0.5+0.5;
}
*/
#define noise _noise1
// https://thebookofshaders.com/13/?lan=jp
// 非整数ブラウン運動
float fBM(in vec3 pos, in int octaves)
{
	float lacunarity = 2.5;
	float total = 0.;
	float value = 0.;
	for(int i = 0; i < octaves; i++)
	{
		pos *= lacunarity;
		value = value*2. + noise(pos);
		total = total*2. + 1.;
	}

	return value / total;
}

vec3 getSkyColor(in vec3 ray)
{
	// 太陽の色
	vec3 vSkyColor = mix(vec3(.0, 0.1, 0.4), vec3(0.3, 0.6, 0.8), 1.0 - ray.y);

	// 太陽
	vSkyColor = mix(vSkyColor, uLightColor, smoothstep(0.999, 1.00, dot(uLightRay, ray)));


	return vSkyColor;
}


float cloud_density(in vec3 pos)
{
//	float t = (distance(pos, u_cloud_inner.xyz)-u_cloud_inner.w) * u_cloud_area_inv;
//	vec3 p = pos * vec3(0.01,0.,0.01) + vec3(0., t, 0.);
	vec3 p = pos * vec3(0.01,0.01,0.01);

	float density = fBM(p + vec3(0., 0., constant.window.z*0.2), 4);

	float coverage = 0.5;
	float alpha = 0.05;

	density = density * smoothstep(coverage, coverage+alpha, density);

	density = band(0., 0.5, 1., (distance(pos,u_cloud_inner.xyz)-u_cloud_inner.w)*u_cloud_area_inv) * density;
	return density;
}

float cloud_lighting(in vec3 pos)
{
	float transparent = 1.;
	const int steps = 1;
	for (int i = 0; i < steps; i++) 
	{
		pos = pos + uLightRay * 4.;
		float density = cloud_density(pos);

		transparent *= exp(-density * ABSORPTION);
	}
	return transparent;
}

vec4 cloud(in vec3 rayPos, in vec3 rayDir, float depth)
{
	vec4 dist;
	if(!intersectRayAtom(rayPos, rayDir, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), dist))
	{
		// 雲にヒットしない
		return vec4(0.);
	}
	

	int count = 0;
	vec2 ray_segment[2];
	if(dist.y>0.)
	{
		// 雲の上から雲を見る
		ray_segment[count] = vec2(max(dist.x, 0.), dist.y-max(dist.x, 0.));
		count++;
	}
	if(dist.w>0. && depth<0.)
	{
		// 雲の下から雲を見る
		ray_segment[count] = vec2(max(dist.z, 0.), dist.w-max(dist.z, 0.));
		count++;
	}
#define STEP_LENGTH	1.
	float transparent = 1.;
	float alpha = 0.;
	vec3 color = vec3(0.);
	for(int i = 0; i <count; i++)
	{
		int step_num = int(ray_segment[i].y / STEP_LENGTH);
		float ray_step = ray_segment[i].y / float(step_num);
		vec3 pos = rayPos + rayDir * (ray_segment[i].x+ray_step*0.5);
		for(int step = 0; step < step_num; step++)
		{
			float density = cloud_density(pos);

			float t = exp(-density * ABSORPTION);
			transparent *= t;
			if (transparent < 0.01) { i = count; break; }

			color += transparent * density * cloud_lighting(pos);
			alpha += (1.-t) *(1.-alpha);

			pos = pos + rayDir * ray_step;

		}

	}
	return vec4(color, min(alpha, 1.));
}

void main()
{
	vec3 CamPos = vec3(0., 1., 0.);
	vec3 CamDir = normalize(vec3(1.5, 1.7, 1.5));
	// カメラレイの作成
	{
		uvec3 reso = gl_NumWorkGroups * gl_WorkGroupSize;
		vec2 ndc = (vec2(gl_GlobalInvocationID.xy) / vec2(reso.xy)) * 2. -1.;
		vec3 up = vec3(0., 1., 0.); 
		vec3 side = normalize(cross(CamDir, normalize(up)));
		up = normalize(cross(CamDir, side));

		float CamFov = (radians(45.0));
		vec2 aspect = vec2(float(reso.x) / float(reso.y), 1);
		CamDir = normalize(side*ndc.x + up*ndc.y + CamDir);
	}
	vec3 sky_color = getSkyColor(CamDir);

	// 地面判定
	float distance_land = intersectRaySphere(CamPos, CamDir, u_planet);
	if(distance_land >= 0.)
	{
		// 地面に当たってる
		vec3 pos = CamPos + CamDir * distance_land;
		vec2 pos_i = floor(pos * 0.5).xz;
		float p = float(mod(pos_i.x + pos_i.y, 2.));
		sky_color = mix(vec3(.6, .6, .6), vec3(.75, .75, .75), p);

		// shadow
/*		if(true)
		{
			#define SHADOW_RAY_STEP 12
			#define SHADOW_RAY_LENGTH 5.
			float d1 = intersectRaySphere(pos, uLightRay, u_cloud_inner);
			float d2 = intersectRaySphere(pos, uLightRay, u_cloud_outer);
			int step_num = min(int((max(d2, 0.)-max(d1, 0.)) / float(SHADOW_RAY_LENGTH)), SHADOW_RAY_STEP);
			pos = pos + uLightRay * (d1 + SHADOW_RAY_LENGTH*0.5);
			vec3 ray = uLightRay/uLightRay.y;

			float transparent = 1.;
			for(int step = 0; step < step_num; step++)
			{
				float density = cloud_density(pos);

				float t = exp(-density * ABSORPTION);
				transparent *= t;
				if (transparent < 0.01) break;

				pos += ray * SHADOW_RAY_LENGTH; 
			}
			sky_color = mix(sky_color, vec3(0.), 1.-transparent);
		}
*/		
	}

	vec3 pos = CamPos + CamDir;
	vec4 color = cloud(pos, CamDir, distance_land);

	color.xyz = mix(sky_color, color.xyz/(color.a+0.0001), color.a);

	imageStore(i_render_target, ivec2(gl_GlobalInvocationID.xy), vec4(color.xyz, 1.));

}