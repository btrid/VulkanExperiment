#version 460
#extension GL_GOOGLE_include_directive : require

#include "Sky.glsl"

#define saturate(_a) clamp(_a, 0., 1.)

// https://www.gamedev.net/forums/topic/680832-horizonzero-dawn-cloud-system/?page=6

static const float VOLUME_END_HEIGHT = cb_cloudVolumeStartHeight + cb_cloudVolumeHeight;
// planet center (world space)
static const vec3 PLANET_CENTER = vec3(0.0f, -cb_groundRadius - 100.0f, 0.0f); // TODO revisit - 100.0f offset is to match planet sky settings
// radius from the planet center to the bottom of the cloud volume
static const float PLANET_CENTER_TO_LOWER_CLOUD_RADIUS = cb_groundRadius + cb_cloudVolumeStartHeight;
// radius from the planet center to the top of the cloud volume
static const float PLANET_CENTER_TO_UPPER_CLOUD_RADIUS = cb_groundRadius + VOLUME_END_HEIGHT;
static const float CLOUD_SCALE = 1.0 / VOLUME_END_HEIGHT;
static const vec3 WEATHER_TEX_MOD = vec3(1.0 / (VOLUME_END_HEIGHT * cb_weatherTexMod.x), cb_weatherTexMod.y, cb_weatherTexMod.z); 
static const vec2 WEATHER_TEX_MOVE_SPEED = vec2(cb_windStrength * cb_windDirection.x, cb_windStrength * cb_windDirection.z); // this is modded by app run time
// samples based on shell thickness between inner and outer volume
static const uvec2 SAMPLE_RANGE = uvec2(64u, 128u);

static const vec4 STRATUS_GRADIENT = vec4(0.02, 0.05, 0.09, 0.11);
static const vec4 STRATOCUMULUS_GRADIENT = vec4(0.02, 0.2, 0.48, 0.625);
static const vec4 CUMULUS_GRADIENT = vec4(0.01, 0.0625, 0.78, 1.0); // these fractions would need to be altered if cumulonimbus are added to the same pass


bool intersectRayAtom(vec3 Pos, vec3 Dir, vec3 AtomPos, vec2 Area, out vec4 OutDist)
{
	vec3 RelativePos = AtomPos - Pos;
	float tca = dot(RelativePos, Dir);

	vec2 RadiusSq = Area * Area;
	float d2 = dot(RelativePos, RelativePos) - tca * tca;

	OutDist = vec4(tca) + vec4(sqrt(RadiusSq.yxxy - d2)) * vec4(-1., -1., 1., 1.);
	return d2 <= RadiusSq.y;
}

float remap(float value, float oldMin, float oldMax, float newMin, float newMax)
{
	return newMin + (value - oldMin) / (oldMax - oldMin) * (newMax - newMin);
}

vec3 sampleWeather(vec3 pos)
{
	return weatherLookup.SampleLevel(texSampler, pos.xz * WEATHER_TEX_MOD.x + WEATHER_TEX_MOD.yz + (WEATHER_TEX_MOVE_SPEED * cb_appRunTime), 0.0f).rgb;
}

float getCoverage(vec3 weatherData)
{
	return weatherData.r;
}

float getPrecipitation(vec3 weatherData)
{
	return weatherData.g;
}

float getCloudType(vec3 weatherData)
{
	// weather b channel tells the cloud type 0.0 = stratus, 0.5 = stratocumulus, 1.0 = cumulus
	return weatherData.b;
}

float heightFraction(vec3 pos)
{
	return saturate((distance(pos, PLANET_CENTER) - PLANET_CENTER_TO_LOWER_CLOUD_RADIUS) / cb_cloudVolumeHeight);
}

vec4 mixGradients(float cloudType)
{
	float stratus = 1.0 - saturate(cloudType * 2.);
	float stratocumulus = 1.0 - abs(cloudType - 0.5) * 2.0;
	float cumulus = saturate(cloudType - 0.5) * 2.0;
	return STRATUS_GRADIENT * stratus + STRATOCUMULUS_GRADIENT * stratocumulus + CUMULUS_GRADIENT * cumulus;
}

float densityHeightGradient(float heightFrac, float cloudType)
{
	vec4 cloudGradient = mixGradients(cloudType);
	return smoothstep(cloudGradient.x, cloudGradient.y, heightFrac) - smoothstep(cloudGradient.z, cloudGradient.w, heightFrac);
}

float sampleCloudDensity(vec3 pos, vec3 weatherData, float heightFrac, float lod)
{
	pos += heightFrac * cb_windDirection * cb_cloudTopOffset;
	pos += (cb_windDirection + vec3(0.0f, -0.25f, 0.0f)) * cb_cloudSpeed * (cb_appRunTime/* * 25.0f*/); // the * 25.0f is just for testing to make the effect obvious
	pos *= CLOUD_SCALE;
	
	vec4 lowFreqNoise = baseShapeLookup.SampleLevel(texSampler, pos, lerp(0.0f, cb_baseShapeTextureBottomMipLevel, lod));
	float lowFreqFBM =
		(lowFreqNoise.g * 0.625f) +
		(lowFreqNoise.b * 0.25f) +
		(lowFreqNoise.a * 0.125f);

	float baseCloud = remap(lowFreqNoise.r, -(1.0f - lowFreqFBM), 1.0f, /* gets about the same results just using -lowFreqFBM*/ 0.0f, 1.0f);

	float densityGradient = densityHeightGradient(heightFrac, getCloudType(weatherData));
	baseCloud *= densityGradient;

	float cloudCoverage = getCoverage(weatherData);
	float baseCloudWithCoverage = remap(baseCloud, 1.0f - cloudCoverage, 1.0f, 0.0f, 1.0f);
	baseCloudWithCoverage *= cloudCoverage;

	//// TODO add curl noise
	//// pos += curlNoise.xy * (1.0f - heightFrac);

	vec3 highFreqNoise = erosionLookup.SampleLevel(texSampler, pos * 0.1f, lerp(0.0f, cb_erosionTextureBottomMipLevel, lod)).rgb;
	float highFreqFBM =
		(highFreqNoise.r * 0.625f) +
		(highFreqNoise.g * 0.25f) +
		(highFreqNoise.b * 0.125f);

	float highFreqNoiseModifier = lerp(highFreqFBM, 1.0f - highFreqFBM, saturate(heightFrac * 10.0f));

	baseCloudWithCoverage = remap(baseCloudWithCoverage, highFreqNoiseModifier * 0.2f, 1.0f, 0.0f, 1.0f);

	return saturate(baseCloudWithCoverage);
}

// random vectors on the unit sphere
static const vec3 RANDOM_VECTORS[] =
{
	vec3( 0.38051305f,  0.92453449f, -0.02111345f),
	vec3(-0.50625799f, -0.03590792f, -0.86163418f),
	vec3(-0.32509218f, -0.94557439f,  0.01428793f),
	vec3( 0.09026238f, -0.27376545f,  0.95755165f),
	vec3( 0.28128598f,  0.42443639f, -0.86065785f),
	vec3(-0.16852403f,  0.14748697f,  0.97460106f)
};

static const uint LIGHT_RAY_ITERATIONS = 6u;
static const float RCP_LIGHT_RAY_ITERATIONS = 1.0f / float(LIGHT_RAY_ITERATIONS);

float beerLambert(float sampleDensity, float precipitation)
{
	return exp(-sampleDensity * precipitation);
}

float powder(float sampleDensity, float lightDotEye)
{
	float powd = 1.0f - exp(-sampleDensity * 2.0f);
	return mix(1.0f, powd, clamp((-lightDotEye * 0.5f) + 0.5f, 0., 1.));
}

float henyeyGreenstein(float lightDotEye, float g)
{
	float g2 = g * g;
	return ((1.0f - g2) / pow((1.0f + g2 - 2.0f * g * lightDotEye), 1.5f)) * 0.25f;
}

float lightEnergy(
	float lightDotEye,
	float densitySample,
	float originalDensity,
	float precipitation)
{
	return 2.0f *
		beerLambert(densitySample, precipitation) *
		powder(originalDensity, lightDotEye) * 
		lerp(henyeyGreenstein(lightDotEye, 0.8f), henyeyGreenstein(lightDotEye, -0.5f), 0.5f);
}

// TODO get from cb values - has to change as time of day changes
vec3 ambientLight(float heightFrac)
{
	return lerp(vec3(0.5f, 0.67f, 0.82f), vec3(1.0f, 1.0f, 1.0f), heightFrac);
}

float sampleCloudDensityAlongCone(
	vec3 startPos,
	float  stepSize,
	float  lightDotEye,
	float  originalDensity)
{
	vec3 lightStep = stepSize * -cb_lightDirection;
	vec3 pos = startPos;
	float coneRadius = 1.0f;
	float coneStep = RCP_LIGHT_RAY_ITERATIONS;
	float densityAlongCone = 0.0f;
	float lod = 0.0f;
	float lodStride = RCP_LIGHT_RAY_ITERATIONS;
	vec3 weatherData = 0.0f;
	float rcpThickness = 1.0f / (stepSize * LIGHT_RAY_ITERATIONS);
	float density = 0.0f;

	for(uint i = 0u; i < LIGHT_RAY_ITERATIONS; ++i)
	{
		vec3 conePos = pos + coneRadius * RANDOM_VECTORS[i] * float(i + 1u);
		float heightFrac = heightFraction(conePos);
		if(heightFrac <= 1.0f)
		{
			weatherData = sampleWeather(conePos);
			float cloudDensity = sampleCloudDensity(
				conePos,
				weatherData,
				heightFrac,
				lod);
			if(cloudDensity > 0.0f)
			{
				density += cloudDensity;
				float transmittance = 1.0f - (density * rcpThickness);
				densityAlongCone += (cloudDensity * transmittance);
			}
		}
		pos += lightStep;
		coneRadius += coneStep;
		lod += lodStride;
	}
	// take additional step at large distance away for shadowing from other clouds
	pos = pos + (lightStep * 8.0f);
	weatherData = sampleWeather(pos);
	float heightFrac = heightFraction(pos);
	if(heightFrac <= 1.0f)
	{
		float cloudDensity = sampleCloudDensity(
			pos,
			weatherData,
			heightFrac,
			0.8f);
		// no need to branch here since density variable is no longer used after this
		density += cloudDensity;
		float transmittance = 1.0f - saturate(density * rcpThickness);
		densityAlongCone += (cloudDensity * transmittance);
	}

	return saturate(lightEnergy(
		lightDotEye,
		densityAlongCone,
		originalDensity,
		lerp(1.0f, 2.0f, getPrecipitation(weatherData))));
}

vec4 traceClouds(
	vec3 viewDirW,		// world space view direction
	vec3 startPos,		// world space start position
	vec3 endPos)			// world space end position
{
	vec3 dir = endPos - startPos;
	float thickness = length(dir);
	float rcpThickness = 1.0f / thickness;
	uint sampleCount = lerp(SAMPLE_RANGE.x, SAMPLE_RANGE.y, saturate((thickness - cb_cloudVolumeHeight) / cb_cloudVolumeHeight));
	float stepSize = thickness / float(sampleCount);
	dir /= thickness;
	vec3 posStep = stepSize * dir;

	float lightDotEye = -dot(cb_lightDirection, viewDirW);

	vec3 pos = startPos;
	vec3 weatherData = 0.0f;
	vec4 result = 0.0f;
	float density = 0.0f;
	
	for(uint i = 0u; i < sampleCount; ++i)
	{
		float heightFrac = heightFraction(pos);
		weatherData = sampleWeather(pos);
		float cloudDensity = sampleCloudDensity(
			pos,
			weatherData,
			heightFrac,
			0.0f);

		if(cloudDensity > 0.0f)
		{
			density += cloudDensity;
			float transmittance = 1.0f - (density * rcpThickness);
			float lightDensity = sampleCloudDensityAlongCone(
				pos,
				stepSize,
				lightDotEye,
				cloudDensity);

			vec3 ambientBadApprox = ambientLight(heightFrac) * min(1.0f, length(cb_sunColor.rgb * 0.0125f)) * transmittance;
			vec4 source = vec4((cb_sunColor.rgb * lightDensity) + ambientBadApprox/*+ ambientLight(heightFrac)*/, cloudDensity * transmittance); // TODO enable ambient when added to constant buffer
			source.rgb *= source.a;
			result = (1.0f - result.a) * source + result;
			if(result.a >= 1.0f) break;
		}

		pos += posStep;
	}

	// experimental fog - may not be needed if clouds are drawn before atmosphere - would have to draw sun by itself, then clouds, then atmosphere
	// fogAmt = 0 to disable
	float fogAmt = 1.0f - exp(-distance(startPos, cb_eyePositionW) * 0.00001f);
	vec3 fogColor = vec3(0.3f, 0.4f, 0.45f) * length(cb_sunColor.rgb * 0.125f) * 0.8f;
	vec3 sunColor = normalize(cb_sunColor.rgb) * 4.0f * length(cb_sunColor.rgb * 0.125f);
	fogColor = lerp(fogColor, sunColor, pow(saturate(lightDotEye), 8.0f));
	return vec4(clamp(lerp(result.rgb, fogColor, fogAmt), 0.0f, 1000.0f), saturate(result.a));
}

void main()
{
	ivec3 loadIndices = ivec3(pIn.posH.xy, 0);
	float zwDepth = depthTexture.Load(loadIndices).r;
	bool depthPresent = zwDepth < 1.0f;
	float depth = linearizeDepth(zwDepth);
	vec3 posV = pIn.viewRay * depth;
	vec3 posW = mul(vec4(posV, 1.0f), cb_inverseViewMatrix).xyz;
	vec3 viewDirW = normalize(posW - cb_eyePositionW);

	// find nearest planet surface point
	vec4 dist;
	if(!intersectRayAtom(rayPos, rayDir, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), dist))
	{
		// 雲にヒットしない
		return vec4(0.);
	}
	

	int count = 0;
	vec2 ray_segment[2];
	if(dist.y>0.)
	{
		// 雲の上から雲を見る
		ray_segment[count] = vec2(max(dist.x, 0.), dist.y-max(dist.x, 0.));
		count++;
	}
	if(dist.w>0. && depth<0.)
	{
		// 雲の下から雲を見る
		ray_segment[count] = vec2(max(dist.z, 0.), dist.w-max(dist.z, 0.));
		count++;
	}
	for(int i = 0; i <count; i++)
	{
		vec3 begin = rayPos + rayDir * ray_segment[i].x;
		vec3 end = begin + rayDir * ray_segment[i].y;
		return traceClouds( rayDir, begin, end);
	}
}