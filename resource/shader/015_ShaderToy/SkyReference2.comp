#version 460
#extension GL_GOOGLE_include_directive : require

#include "Sky.glsl"

#define ABSORPTION		0.15

layout (local_size_x = 32, local_size_y = 32) in;

float rand(in vec3 co)
{
	return fract(sin(dot(co, vec3(12.98,78.23, 45.41))) * 43758.5);
}
float _noise1(in vec3 pos)
{
	vec3 ip = floor(pos);
	vec3 fp = smoothstep(0., 1., fract(pos));
	vec2 offset = vec2(0., 1.);
	vec4 a = vec4(rand(ip+offset.xxx),rand(ip+offset.yxx),rand(ip+offset.xyx),rand(ip+offset.yyx));
	vec4 b = vec4(rand(ip+offset.xxy),rand(ip+offset.yxy),rand(ip+offset.xyy),rand(ip+offset.yyy));
	a = mix(a, b, fp.z);
	a.xy = mix(a.xy, a.zw, fp.y);
	return mix(a.x, a.y, fp.x);
}
#define noise _noise1
float fBM(in vec3 pos, in int octaves)
{
	float total = 0.;
	float value = 0.;
	for(int i = 0; i < octaves; i++)
	{
		pos = pos * 2.;
		value = value*2. + noise(pos);
		total = total*2. + 1.;
	}

	return value / total;
}

vec3 g_noise_kernel[4];
float g_cam_phase_factor;
float g_light_phase_factor;
vec3 uCamDir;
vec3 uCamPos;
void precompute()
{
	uCamPos = vec3(0., 1., 0.);

	// カメラレイの作成
	{
		float s = sin(constant.window.x * 0.02);
		float c = cos(constant.window.x * 0.02);
		vec3 CamDir = normalize(vec3(s, 0.5, c));

		uvec3 reso = gl_NumWorkGroups * gl_WorkGroupSize;
		vec2 ndc = (vec2(gl_GlobalInvocationID.xy) / vec2(reso.xy)) * 2. -1.;
		vec3 up = vec3(0., 1., 0.);
		vec3 side = normalize(cross(CamDir, normalize(up)));
		side = dot(side, side) < 0.000001 ? vec3(1., 0., 0.) : normalize(side);
		up = normalize(cross(CamDir, side));

		float CamFov = (radians(45.0));
		vec2 aspect = vec2(float(reso.x) / float(reso.y), 1);
		uCamDir = normalize(side*ndc.x + up*ndc.y + CamDir);
	}

	{
//		uLightRay = normalize(vec3(s, c, 0.1));
		uLightRay = normalize(vec3(0., -1., 12));
	}

	g_cam_phase_factor = henyeyGreenstein(dot(-uLightRay, uCamDir), 0.2);
	g_light_phase_factor = henyeyGreenstein(dot(-uLightRay, -uLightRay), 0.2);

	{
		vec3 up = vec3(0., 1., 0.);
		vec3 side = cross(-uLightRay, normalize(up));
		side = dot(side, side) < 0.000001 ? vec3(1., 0., 0.) : normalize(side);
		up = normalize(cross(side, -uLightRay));

		g_noise_kernel[0] = uLightRay * 0.5 + side * 0.5 + up * 0.5;
		g_noise_kernel[1] = uLightRay * 0.5 + side * -0.5 + up * 0.5;
		g_noise_kernel[2] = uLightRay * 0.5 + side * 0.5 + up * -0.5;
		g_noise_kernel[3] = uLightRay * 0.5 + side * -0.5 + up * -0.5;
		
	}
}


float henyeyGreensteinPhaseFunction(float lightDotEye, float g){ return ((1. - g*g) / pow((1. + g*g - 2.*g*lightDotEye), 1.5)) / (4.*3.1415); }

float BeerLambert(float density, float precipitation){ return exp(-density * precipitation);}
float PowderSugarEffect(float density, float precipitation){ return 1. - exp(-density * precipitation * 2.0);}
float lightEnergy(float density, float light_density, float precipitation, float henyeyGreensteinFactor)
{
	float beer_lambert = BeerLambert(density, precipitation);
	float powder_sugar_effect = PowderSugarEffect(density, precipitation);
	return 2. * beer_lambert * powder_sugar_effect * henyeyGreensteinFactor;
}

float cloud_density(in vec3 pos, in int lod)
{
	float t = (distance(pos, u_cloud_inner.xyz)-u_cloud_inner.w) * u_cloud_area_inv;
	if(t<=0.||t>=1.){ return 0.; }

	vec3 p = pos * vec3(0.01,0.01,0.01);

	float density = fBM(p + vec3(0., 0., constant.window.z*0.2), lod);

	float coverage = 0.5;
	float alpha = 0.05;

	density = density * smoothstep(coverage, coverage+alpha, density);

	density = band(0., 0.5, 1., t) * density;
	return density;
}

float light(in vec3 pos)
{
	vec4 rays;
	if(intersectRayAtomEx(pos, -uLightRay, u_planet.xyz, vec2(u_planet.w), -1., rays) != 0)
	{
		// 星の影
		return 0.;
	}

	float density = 0.;
	for (int i = 0; i < 3; i++) 
	{
		pos = pos + uLightRay * 4.;
		density += cloud_density(pos, 2);
	}
	return exp(-density);
}

float light(vec3 pos, float ray_length)
{
	vec4 rays;
	if(intersectRayAtomEx(pos, -uLightRay, u_planet.xyz, vec2(u_planet.w), -1., rays) != 0)
	{
		// 星の影
		return 0.;
	}

	float density = 0.;
	int step_num = 8;
	float ray_step = ray_length / float(step_num);
	for(int i = 0; i < step_num; i++)
	{
		vec3 p = pos - uLightRay * (float(i)+0.5) * ray_step;
		density += cloud_density(p, 2) * ray_step;
	}

	return exp(-density);
}
float SugerPowderEffect(vec3 pos)
{
	float density = 0.;
	for(int i = 0; i < g_noise_kernel.length(); i++)
	{
		vec3 p = pos + g_noise_kernel[i]*1.;
		float d = cloud_density(p, 2);
		density += d;
	}

	return 1.- exp(-density);
}

vec4 cloud(in vec3 rayPos, in vec3 rayDir, float depth)
{
	vec4 rays;
	int count = intersectRayAtomEx(uCamPos, uCamDir, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), depth, rays);

	uint sampleCount = 16;
	float density = 0.;
	vec3 color = vec3(0.);
	for(int i = 0; i <count; i++)
	{
		vec3 begin = uCamPos + uCamDir * rays[i*2];
		vec3 end = begin + uCamDir * rays[i*2+1];

		float thickness = rays[i*2+1];
		float rcpThickness = 1. / thickness;
//		sampleCount = uint(thickness);
		float ray_step =  thickness / float(sampleCount);

		vec3 pos = begin;
		for(int s = 0; s < sampleCount; s++)
		{
			float d = cloud_density(pos, 4) * ray_step;
			density += d;

			float light = light(pos, rays[i*2+1] - ray_step*float(s));
			float lambert = BeerLambert(density);
			float powder = SugerPowderEffect(pos)*0.5+0.5;
			float e = light * lambert;

			color += e * vec3(1., 1., 1.);
			float alpha = exp(-density);
			if(alpha < 0.00001) { break; }

			pos += ray_step * uCamDir;
		}
	}
	float alpha = min(1.-exp(-density), 1.);
//	background_color = mix(background_color, color/(alpha+0.0001), alpha);
	return vec4(color, alpha);
}


vec3 getSkyColor(in vec3 ray)
{
	vec3 vSkyColor = mix(vec3(.0, 0.1, 0.4), vec3(0.3, 0.6, 0.8), 1.0 - ray.y);
	vSkyColor = mix(vSkyColor, uLightColor, smoothstep(0.999, 1.00, dot(uLightRay, ray)));
	return vSkyColor;
}

void main()
{
	precompute();
	vec3 sky_color = getSkyColor(uCamDir);

	// 地面判定
	float distance_land = intersectRaySphere(uCamPos, uCamDir, u_planet);
	if(distance_land >= 0.)
	{
		// 地面に当たってる
		vec3 pos = uCamPos + uCamDir * distance_land;
		vec2 pos_i = floor(pos * 0.5).xz;
		float p = float(mod(pos_i.x + pos_i.y, 2.));
		sky_color = mix(vec3(.6, .6, .6), vec3(.75, .75, .75), p);

		// shadow
/*		if(true)
		{
			#define SHADOW_RAY_STEP 12
			#define SHADOW_RAY_LENGTH 5.
			float d1 = intersectRaySphere(pos, uLightRay, u_cloud_inner);
			float d2 = intersectRaySphere(pos, uLightRay, u_cloud_outer);
			int step_num = min(int((max(d2, 0.)-max(d1, 0.)) / float(SHADOW_RAY_LENGTH)), SHADOW_RAY_STEP);
			pos = pos + uLightRay * (d1 + SHADOW_RAY_LENGTH*0.5);
			vec3 ray = uLightRay/uLightRay.y;

			float transparent = 1.;
			for(int step = 0; step < step_num; step++)
			{
				float density = cloud_density(pos);

				float t = exp(-density * ABSORPTION);
				transparent *= t;
				if (transparent < 0.01) break;

				pos += ray * SHADOW_RAY_LENGTH; 
			}
			sky_color = mix(sky_color, vec3(0.), 1.-transparent);
		}
*/		
	}

	vec4 color = cloud(uCamPos, uCamDir, distance_land);

	color.xyz = mix(sky_color, color.xyz/(color.a+0.0001), color.a);
	imageStore(i_render_target, ivec2(gl_GlobalInvocationID.xy), vec4(color.xyz, 1.));

}