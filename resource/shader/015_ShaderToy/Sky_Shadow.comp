#version 460
#extension GL_GOOGLE_include_directive : require

#include "Sky.glsl"

layout (local_size_x = 128) in;

layout(push_constant) uniform Input
{
	vec3 window;
} constant;

bool intersectRayAtom(vec3 Pos, vec3 Dir, vec3 AtomPos, vec2 Area, out vec4 OutDist)
{
	vec3 RelativePos = AtomPos - Pos;
	float tca = dot(RelativePos, Dir);

	vec2 RadiusSq = Area * Area;
	float d2 = dot(RelativePos, RelativePos) - tca * tca;

	OutDist = vec4(tca) + vec4(sqrt(RadiusSq.yxxy - d2)) * vec4(-1., -1., 1., 1.);
	return d2 <= RadiusSq.y;
}

void main()
{
	uvec2 reso = (gl_NumWorkGroups * gl_WorkGroupSize).xz;
	vec2 p = ((vec2(gl_GlobalInvocationID.xz) + 0.5)/reso)*2.-1.;
	p = p * u_cloud_outer.w;

	vec4 dist;
	if(!intersectRayAtom(rayPos, uLightDir, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), dist))
	{
		// 雲にヒットしない
		return;
	}
	int count = 0;
	vec2 ray_segment[2];
/*	if(dist.y>0.)
	{
		// 雲の上から雲を見る
		ray_segment[count] = vec2(max(dist.x, 0.), dist.y-max(dist.x, 0.));
		count++;
	}
*/	if(dist.w>0. && depth<0.)
	{
		// 雲の下から雲を見る
		ray_segment[count] = vec2(max(dist.z, 0.), dist.w-max(dist.z, 0.));
		count++;
	}
#define STEP_LENGTH	1.
	float transparent = 1.;
	float alpha = 0.;
//	vec3 color = vec3(0.);
	for(int i = 0; i <count; i++)
	{
		int step_num = 8;
		float ray_step = ray_segment[i].y / float(step_num);
		vec3 pos = vec3(p.x, 0., p.y) + uLightDir * (ray_segment[i].x+ray_step*0.5);
		for(int step = 0; step < step_num; step++)
		{
			float density = cloud_density(pos);

			float t = exp(-density * ABSORPTION * exp(ray_step-1.));
			transparent *= t;
			if (transparent < 0.01) { i = count; break; }

//			color += transparent * density * cloud_lighting(pos);
			alpha += (1.-t) *(1.-alpha);

			pos = pos + uLightDir * ray_step;
		}

	}
}