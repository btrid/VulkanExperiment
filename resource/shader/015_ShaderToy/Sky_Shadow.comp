#version 460
#extension GL_GOOGLE_include_directive : require

#include "Sky.glsl"

layout (local_size_x = 128) in;

layout(push_constant) uniform Input
{
	vec3 window;
} constant;


void main()
{

	vec3 CamPos = vec3(0., 1., 0.);
	vec3 CamDir = uLightRay;

	// カメラ位置の作成
	{
		uvec3 reso = gl_NumWorkGroups * gl_WorkGroupSize;
		vec2 ndc = ((vec2(gl_GlobalInvocationID.xy) + 0.5) / vec2(reso.xy)) * 2. -1.;
		CamPos.xz = u_cloud_inner.ww * ndc + (-CamDir * u_cloud_outer.www * 1.5);
	}

	// find nearest planet surface point
	vec4 dist = vec4(-1.);
	if(intersectRayAtom(CamPos, CamDir, u_cloud_inner.xyz, vec2(u_cloud_inner.w, u_cloud_outer.w), dist))
	{
		int count = 0;
		vec2 ray_segment[2];
		if(dist.y>0.)
		{
			// 雲の上から雲を見る
			ray_segment[count] = vec2(max(dist.x, 0.), dist.y-max(dist.x, 0.));
			count++;
		}

		vec4 result = vec4(0.);
		float density = 0.;
		uint sampleCount = 16;
//		float lightDotEye = dot(-uLightRay, CamDir);
		for(int i = 0; i <count; i++)
		{
			vec3 begin = CamPos + CamDir * ray_segment[i].x;
			vec3 end = begin + CamDir * ray_segment[i].y;

			vec3 dir = end - begin;
			float thickness = ray_segment[i].y;
			float rcpThickness = 1. / thickness;
			float stepSize = thickness / float(sampleCount);
			dir /= thickness;
			vec3 posStep = stepSize * dir;


			vec3 pos = begin;
			
			for(uint i = 0u; i < sampleCount; ++i)
			{
				float height_frac = heightFraction(pos);
				vec3 weather_data = sampleWeather(pos);
				float cloudDensity = sampleCloudDensity(pos, weather_data, height_frac, 0.);

				if(cloudDensity > 0.0)
				{
					density += cloudDensity;
					float transmittance = 1. - (density * rcpThickness);
					float lightDensity = sampleCloudDensityAlongCone(pos, stepSize, lightDotEye, cloudDensity);

					vec3 ambientBadApprox = ambientLight(height_frac) * min(1.0f, length(uLightColor.rgb * 0.0125)) * transmittance;
					vec4 source = vec4((uLightColor.rgb * lightDensity) + ambientBadApprox/*+ ambientLight(heightFrac)*/, cloudDensity * transmittance);
					source.rgb *= source.a;
					result = (1.0 - result.a) * source + result;
					if(result.a >= 1.0) break;
				}

				pos += posStep;
			}
		}

		result.xyz = mix(color, result.xyz/(result.a+0.0001), result.a);
		color = result.xyz;

	}

}