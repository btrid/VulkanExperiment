#version 460
#extension GL_GOOGLE_include_directive : require
#include "Sky.glsl"

layout (local_size_x = 32, local_size_z = 2) in;
//shared f16vec4 s_rand[1024][3];


layout(push_constant) uniform Input
{
	vec3 window;
} constant;

float rand(in vec3 co)
{
	return fract(sin(dot(co, vec3(12.98,78.23, 45.41))) * 43758.5);
}
float noise(in vec3 pos)
{
	vec3 ip = floor(pos);
	vec3 fp = smoothstep(0., 1., fract(pos));
	vec2 offset = vec2(0., 1.);
	vec4 a = vec4(rand(ip+offset.xxx),rand(ip+offset.yxx),rand(ip+offset.xyx),rand(ip+offset.yyx));
	vec4 b = vec4(rand(ip+offset.xxy),rand(ip+offset.yxy),rand(ip+offset.xyy),rand(ip+offset.yyy));
	a = mix(a, b, fp.z);
	a.xy = mix(a.xy, a.zw, fp.y);
	return mix(a.x, a.y, fp.x);
}

// https://thebookofshaders.com/13/?lan=jp
float fBM(in vec3 pos, in int octaves)
{
	float lacunarity = 2.971;
	float total = 0.;
	float value = 0.;
	for(int i = 0; i < octaves; i++)
	{
		value = value*2. + noise(pos);
		total = total*2. + 1.;
		pos = pos * lacunarity;
	}

	return value / total;
}
void main()
{
	uvec4 v;
	for(int i=0; i<4; i++)
	{
		vec4 e; 
		for(int j=0; j<4; j++)
		{
			e[j] = fBM((vec3(gl_GlobalInvocationID.xyz)*vec3(16.,1.,1.)+vec3(i*4+j,0.,0.) + floor(constant.window)) * vec3(0.1, 0.25, 0.1), 3);
		}
		uvec4 ie = uvec4(e * smoothstep(0.65, 0.655, e) * 255.);
		ie=ie<<uvec4(0,8,16,24);
		v[i] = ie.x|ie.y|ie.z|ie.w;
	}
	// 雲っぽく
	uvec3 reso = gl_WorkGroupSize * gl_NumWorkGroups;
	b_density[gl_GlobalInvocationID.x+gl_GlobalInvocationID.y*reso.x+gl_GlobalInvocationID.z*reso.x*reso.y] = v;

//	imageStore(i_map, ivec3(gl_GlobalInvocationID.xyz), uvec4(v*255.));

}