#version 460
// http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.42.3443&rep=rep1&type=pdf

#extension GL_GOOGLE_include_directive : require
#define USE_Voxel 0
#include "Voxel.glsl"

#define SETPOINT_CAMERA 1
#include "btrlib/camera.glsl"

#define USE_RenderTarget 2
#include "applib/System.glsl"
layout (local_size_x = 8, local_size_y = 8) in;

bool intersection(vec3 aabb_min, vec3 aabb_max, vec3 pos, vec3 inv_dir, out float n, out float f)
{
	// https://tavianator.com/fast-branchless-raybounding-box-intersections/
	vec3 t1 = (aabb_min - pos) * inv_dir;
	vec3 t2 = (aabb_max - pos) * inv_dir;

	vec3 tmin = min(t1, t2);
	vec3 tmax = max(t1, t2);

	n = max(max(tmin.x, tmin.y), tmin.z);
	f = min(min(tmax.x, tmax.y), tmax.z);

	return f > n;
}
shared VoxelInfo s_info;
shared f16mat3 s_view;

void init()
{
	if(gl_LocalInvocationIndex == 0)
	{
		s_info = u_info;
		s_view = transpose(f16mat3(u_camera[0].u_view));
	}

	memoryBarrierShared();
	barrier();

}
void MakeRay(out vec3 pos, out vec3 dir, out vec3 inv_dir)
{
	vec2 screen = (gl_GlobalInvocationID / vec3(gl_WorkGroupSize * gl_NumWorkGroups)).xy * 2. - 1.;
	screen *= tan(u_camera[0].u_fov_y / 2.);

	dir = normalize(s_view[2] + s_view[0] * screen.x * u_camera[0].u_aspect + s_view[1] * screen.y);
	pos = u_camera[0].u_eye.xyz;
	
	inv_dir.x = abs(dir.x) < 0.00001 ? 99999.f : 1. / dir.x;
	inv_dir.y = abs(dir.y) < 0.00001 ? 99999.f : 1. / dir.y;
	inv_dir.z = abs(dir.z) < 0.00001 ? 99999.f : 1. / dir.z;

	int axis = abs(dir.x) > abs(dir.y) ? 0 : 1;
	axis = abs(dir[axis]) > abs(dir.z) ? axis : 2;
	dir *= abs(inv_dir[axis]);
	inv_dir /= abs(inv_dir[axis]);

}

int To1D(in ivec3 p, in ivec3 s){ return p.x + p.y*s.x + p.z*s.x*s.y; }
int To1D(in ivec3 p, in ivec4 s){ return p.x + p.y*s.x + p.z*s.x*s.y; }
ivec3 ToTopIndex(in ivec3 p){ return p >> (s_info.top_brick_sqrt + s_info.bottom_brick_sqrt).xyz; }
ivec3 ToTopBit(in ivec3 p){ return ((p >> s_info.bottom_brick_sqrt.xyz) % s_info.top_brick.xyz); }
ivec3 ToBottomIndex(in ivec3 p){ return p >> s_info.bottom_brick_sqrt.xyz; }
void main()
{
	
	init();

	vec3 dir,pos, inv_dir;
	MakeRay(pos, dir, inv_dir);

	float n, f;
	intersection(vec3(0.01), vec3(s_info.reso.xyz)-0.01, pos, inv_dir, n, f);
	pos = pos + max(n, 0.) * dir;

//	vec3 error = mix(fract(pos), vec3(1.) - fract(pos), step(dir, vec3(0.)));
//	ivec3 ipos = ivec3(pos);

	f16vec4 c = f16vec4(0,0,0,1);
//	int count = 0;
	while (all(lessThan(pos, s_info.reso.xyz)) && all(greaterThanEqual(pos, vec3(0))))
	{
//		count++;
//		ivec3 ipos = ivec3(pos);
		ivec3 i = ToBottomIndex(ivec3(pos));
		uvec4 bottom = b_bottom[To1D(i, s_info.bottom_reso)];

		if(all(equal(bottom, uvec4(0))))
		{
			// skip
			intersection(i*s_info.bottom_brick.xyz-0.01, (i+1)*s_info.bottom_brick.xyz+0.01, pos, inv_dir, n, f);
			pos = pos + dir * max(f, 0.);
			continue;
		}

		do
		{
			ivec3 bit = ivec3(pos)%s_info.bottom_brick.xyz;
			int b = To1D(bit, s_info.bottom_brick);
			if((bottom[b/32] & (1<<(b%32))) == 0)
			{
				pos += dir;				
				continue;
			}

			c = f16vec4(1.);
			pos = vec3(99999);
			break;

		} while(all(greaterThanEqual(pos, vec3(0))) && all(equal(i, ivec3(pos)>>s_info.bottom_brick_sqrt.xyz)));
	}
//	float _b = count % 10;
//	float _g = (count / 200.)*100.;
//	float _r = (count / 500)*1000.;
//	if(count != 0){ c = f16vec4(normalize(vec3(_r, _g, _b+0.1)), 1.);}
	imageStore(i_render_target, ivec2(gl_GlobalInvocationID.xy), c);
}