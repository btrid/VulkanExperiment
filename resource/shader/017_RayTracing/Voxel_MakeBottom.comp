#version 460

#extension GL_GOOGLE_include_directive : require
#define USE_Voxel 0
#include "Voxel.glsl"

layout (local_size_x = 4, local_size_y = 8, local_size_z = 4) in;
shared uvec4 s_map;
float sdBox( vec3 p, vec3 b )
{
	vec3 d = abs(p) - b;
	return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}
float sdSphere( vec3 p, float s )
{
  return length( p ) - s;
}

float map(in vec3 p)
{
	float d = 9999999.;
	{
//		d = min(d, sdBox(p-vec3(500., 200., 700.), vec3(300.)));
		d = min(d, sdSphere(p-vec3(1000., 250., 1000.), 1000.));
	}
	return d;
}


void main() 
{
	if(gl_LocalInvocationIndex==0)
	{
		s_map = uvec4(0);
	}
	memoryBarrierShared();
	barrier();

	vec3 p = vec3(gl_GlobalInvocationID.xyz)+0.5;
	vec4 d = vec4(0.);
	d[0] = map(p);
	d[1] = map(p+1.);
	d[2] = map(p);
	d[3] = map(p+1.);
//	d[2] = map(p+vec3(1., 1., -1.));
//	d[3] = map(p+vec3(-1., -1., 1.));

	// 境界のみボクセル化する
	if(any(greaterThanEqual(d, vec4(0))) && any(lessThanEqual(d, vec4(0))))
//	if(any(lessThan(d, vec4(0))))
	{
		uint index = gl_LocalInvocationID.x+ gl_LocalInvocationID.y*gl_WorkGroupSize.x+gl_LocalInvocationID.z*gl_WorkGroupSize.x*gl_WorkGroupSize.y;
		atomicOr(s_map[index/32], 1<<(index%32));
	}

	memoryBarrierShared();
	barrier();
	if(gl_LocalInvocationIndex==0)
	{
		uint index = gl_WorkGroupID.x + gl_WorkGroupID.y*gl_NumWorkGroups.x + gl_WorkGroupID.z*gl_NumWorkGroups.x*gl_NumWorkGroups.y;
		b_bottom[index] = s_map;
//		b_bottom[index] = uvec4(0xffffffff);
	}
}
