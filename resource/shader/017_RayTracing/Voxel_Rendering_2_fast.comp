// dirを必ず+方向にすることで演算を少なくして高速化

#version 460

#extension GL_GOOGLE_include_directive : require
#define USE_Voxel 0
#include "Voxel.glsl"

#define SETPOINT_CAMERA 1
#include "btrlib/camera.glsl"

#define USE_RenderTarget 2
#include "applib/System.glsl"
layout (local_size_x = 8, local_size_y = 8) in;

bool intersection(vec3 aabb_min, vec3 aabb_max, vec3 pos, vec3 inv_dir, out float n, out float f, out vec3 comp_mask)
{
	// https://tavianator.com/fast-branchless-raybounding-box-intersections/
	vec3 t1 = (aabb_min - pos) * inv_dir;
	vec3 t2 = (aabb_max - pos) * inv_dir;

	vec3 tmin = min(t1, t2);
	vec3 tmax = max(t1, t2);

	n = max(max(tmin.x, tmin.y), tmin.z);
	f = min(min(tmax.x, tmax.y), tmax.z);

	comp_mask = vec3(lessThanEqual(tmax, vec3(f)));
	f = max(f, 0.);

	return f >= n;
}

void MakeRay(out vec3 pos, out vec3 dir, out vec3 inv_dir)
{
	vec2 screen = (gl_GlobalInvocationID / vec3(gl_WorkGroupSize * gl_NumWorkGroups)).xy * 2. - 1.;
	screen *= tan(u_camera[0].u_fov_y / 2.);

	mat3 axis = transpose(mat3(u_camera[0].u_view));

	dir = normalize(axis[2] + axis[0] * screen.x * u_camera[0].u_aspect + axis[1] * screen.y);
	pos = u_camera[0].u_eye.xyz;

	inv_dir = 1./dir;
	
	inv_dir.x = abs(dir.x) < 0.00001 ? 100000. : (1./dir.x);
	inv_dir.y = abs(dir.y) < 0.00001 ? 100000. : (1./dir.y);
	inv_dir.z = abs(dir.z) < 0.00001 ? 100000. : (1./dir.z);

}

uint To1D(in uvec3 p, in uvec3 s){ return p.x + p.y*s.x + p.z*s.x*s.y; }
uint To1D(in uvec3 p, in uvec4 s){ return p.x + p.y*s.x + p.z*s.x*s.y; }


void march(inout uvec3 Cell, inout vec3 t, in vec3 dir, in vec3 deltaT)
{
	float tmin = min(min(t.x, t.y), t.z);
	vec3 mask = vec3(lessThanEqual(t, vec3(tmin)));

	Cell += sign(dir)*mask;
	t = fma(deltaT, mask, t);

}


void main() 
{	
	vec3 dir,pos_origin, inv_dir;
	MakeRay(pos_origin, dir, inv_dir);

	float n, f;
	vec3 comp_mask;
	intersection(vec3(0.01), vec3(u_info.reso.xyz)-0.01, pos_origin, inv_dir, n, f, comp_mask);
	pos_origin = pos_origin + max(n, 0.) * dir;
	if(!all(lessThan(pos_origin, u_info.reso.xyz)) || !all(greaterThanEqual(pos_origin, ivec3(0))))
	{
		imageStore(i_render_target, ivec2(gl_GlobalInvocationID.xy), f16vec4(0,0,0,1));
		return;	
	}

	bvec3 dir_sign = greaterThan(dir, vec3(0.));
	uvec3 reso = u_info.reso.xyz;

	pos_origin = mix(vec3(reso)-pos_origin, pos_origin, dir_sign);
//	vec3 deltaT = abs(inv_dir);
	vec3 pos = pos_origin;
	uvec3 Cell = uvec3(floor(pos));
	vec3 t = (1.f-fract(pos)) * abs(inv_dir);

	f16vec4 c = f16vec4(0.);
	while(all(lessThan(Cell, reso)))
	{
		uvec3 top_index = ToTopIndex(Cell);
		int hash = b_hashmap[To1D(mix(((reso>>4)-1)-top_index, top_index, dir_sign), reso>>4)];

		if(hash<0)
		{
			// skip
			vec3 min_ = top_index<<4;
			vec3 max_ = (top_index+1)<<4;
			bool b = intersection(min_, max_, pos_origin, abs(inv_dir), n, f, comp_mask);
//			if(!b){ imageStore(i_render_target, ivec2(gl_GlobalInvocationID.xy), vec4(1., 1., 0.,1.)); return; }
			
			pos = abs(dir) * vec3(f) + pos_origin;
			Cell = max(uvec3(floor(pos+comp_mask*0.5)), Cell);
			t = mix(1.f-fract(pos), vec3(1.), comp_mask) * abs(inv_dir);

			continue;
		}
		InteriorNode top = b_interior[hash];

		while(all(equal(top_index, ToTopIndex(Cell))))
		{
			uvec3 mid_index = ToMidIndex(Cell);
			uvec3 top_bit = ToTopBit(mix((reso-1)-Cell, Cell, dir_sign));
			uint tb = top_bit.x+top_bit.y*4+top_bit.z*16;

			if(!isBitOn(top.bitmask, tb))
			{
				// skip
				vec3 min_ = mid_index<<2;
				vec3 max_ = (mid_index+1)<<2;
				bool b = intersection(min_, max_, pos_origin, abs(inv_dir), n, f, comp_mask);
//				if(!b){ imageStore(i_render_target, ivec2(gl_GlobalInvocationID.xy), vec4(1., 0., 0.,1.)); return; }
				
				pos = abs(dir) * vec3(f) + pos_origin;
				Cell = max(ivec3(floor(pos+comp_mask*0.5)), Cell);
				t = mix(1.f-fract(pos), vec3(1.), comp_mask) * abs(inv_dir);

				continue;
			}
			InteriorNode mid = b_interior[top.child+bitcount(top.bitmask,tb)];

			while(all(equal(mid_index, ToMidIndex(Cell))))
			{
				uvec3 mid_bit = ToMidBit(mix((reso-1)-Cell, Cell, dir_sign));
				uint bb = mid_bit.x+mid_bit.y*4+mid_bit.z*16;
				if(!isBitOn(mid.bitmask, bb))
				{
					march(Cell, t, abs(dir), abs(inv_dir));
					continue;
				}

//				return;


				LeafNode leaf = b_leaf[mid.child+bitcount(mid.bitmask,bb)];
				c.xyz = f16vec3(abs(unpack_normal(leaf.normal)));
				c.w = 1.hf;
				Cell = uvec3(99999);
				break;

			}
		}
	}

	imageStore(i_render_target, ivec2(gl_GlobalInvocationID.xy), c);
}
