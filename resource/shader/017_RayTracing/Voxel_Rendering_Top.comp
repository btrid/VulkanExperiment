#version 460

#extension GL_GOOGLE_include_directive : require
#define USE_Voxel 0
#include "Voxel.glsl"

#define SETPOINT_CAMERA 1
#include "btrlib/camera.glsl"

#define USE_RenderTarget 2
#include "applib/System.glsl"
layout (local_size_x = 8, local_size_y = 8) in;

bool intersection(vec3 aabb_min, vec3 aabb_max, vec3 pos, vec3 inv_dir, out float n, out float f)
{
	// https://tavianator.com/fast-branchless-raybounding-box-intersections/
	vec3 t1 = (aabb_min - pos) * inv_dir;
	vec3 t2 = (aabb_max - pos) * inv_dir;

	vec3 tmin = min(t1, t2);
	vec3 tmax = max(t1, t2);

	n = max(max(tmin.x, tmin.y), tmin.z);
	f = min(min(tmax.x, tmax.y), tmax.z);

	return f > n;
}

void MakeRay(out vec3 pos, out vec3 dir)
{
	Camera cam = u_camera[0];
	vec3 f = normalize(cam.u_target.xyz - cam.u_eye.xyz).xyz;
	vec3 s = normalize(cross(cam.u_up.xyz, f));
	vec3 u = cam.u_up.xyz;

	// イメージセンサー上の位置
	vec2 screen = (gl_GlobalInvocationID / vec3(gl_WorkGroupSize * gl_NumWorkGroups)).xy * 2. - 1.;
	screen *= tan(cam.u_fov_y / 2.);

	dir = normalize(f + s * screen.x * cam.u_aspect + u * screen.y);
	pos = cam.u_eye.xyz;
}

int To1D(in ivec3 p, in ivec3 s){ return p.x + p.y*s.x + p.z*s.x*s.y; }
int To1D(in ivec3 p, in ivec4 s){ return p.x + p.y*s.x + p.z*s.x*s.y; }
//int To1D(in i8vec3 p, in i8vec4 s){ return p.x + p.y*s.x + p.z*s.x*s.y; }
ivec3 ToTopIndex(in ivec3 p){ return p / (u_info.top_brick * u_info.bottom_brick).xyz; }
ivec3 ToTopBit(in ivec3 p){ return ((p / u_info.bottom_brick.xyz) % u_info.top_brick.xyz); }
ivec3 ToBottomIndex(in ivec3 p){ return p / u_info.bottom_brick.xyz; }
void main() 
{

	vec3 dir,pos;
	MakeRay(pos, dir);

	vec3 inv_d;
	inv_d.x = abs(dir.x) < 0.00001 ? 99999.f : 1. / dir.x;
	inv_d.y = abs(dir.y) < 0.00001 ? 99999.f : 1. / dir.y;
	inv_d.z = abs(dir.z) < 0.00001 ? 99999.f : 1. / dir.z;
	{
		int axis = abs(dir.x) > abs(dir.y) ? 0 : 1;
		axis = abs(dir[axis]) > abs(dir.z) ? axis : 2;
		dir *= abs(inv_d[axis]);
		inv_d /= abs(inv_d[axis]);		
	}

	float n, f;
	intersection(vec3(0), vec3(u_info.reso.xyz), pos, inv_d, n, f);
	pos = ivec3(pos + max(n+0.01, 0.) * dir);

	f16vec4 c = f16vec4(0.);

	// http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.42.3443&rep=rep1&type=pdf


	vec3 error = mix(fract(pos), vec3(1.) - fract(pos), step(dir, vec3(0.)));
	pos = floor(pos) + vec3(0.5);

	while (all(lessThan(pos, u_info.reso.xyz)) && all(greaterThanEqual(pos, vec3(0.f))))
	{
		ivec3 top_index = ToTopIndex(ivec3(pos));
		uvec4 top = b_top[To1D(top_index, u_info.top_reso)];

		if(all(equal(top, uvec4(0))))
		{
			// skip
			intersection(top_index*(u_info.top_brick * u_info.bottom_brick).xyz, (top_index+1)*(u_info.top_brick * u_info.bottom_brick).xyz, pos, inv_d, n, f);

			error = error + abs(dir) * max(f+0.01, 0.);
			pos += sign(dir) * floor(error);
			error = fract(error);

			continue;
		}

		do
		{
			ivec3 top_bit = ToTopBit(ivec3(pos));
			int tb = To1D(top_bit, u_info.top_brick);
			if((top[tb/32] & (1<<(tb%32))) == 0)
			{
//				error += abs(dir);
//				pos += sign(dir) * floor(error);
//				error = fract(error);

				ivec3 bottom_index = ToBottomIndex(ivec3(pos));
				intersection(bottom_index*u_info.bottom_brick.xyz, (bottom_index+1)*u_info.bottom_brick.xyz, pos, inv_d, n, f);

				error = error + abs(dir) * max(f+0.01, 0.);
				pos += sign(dir) * floor(error);
				error = fract(error);

				continue;
			}
			c = f16vec4(1.);
			pos = uvec3(999999);
			break;



		}
		while(all(greaterThanEqual(pos, vec3(0.f))) && all(equal(top_index, ToTopIndex(ivec3(pos)))));

/*		uvec3 i = uvec3(pos)/u_info.bottom_brick.xyz;
		uvec4 bottom = b_bottom[To1D(i, u_info.bottom_reso)];

		if(all(equal(bottom, uvec4(0))))
		{
			// skip
			intersection(i*u_info.bottom_brick.xyz, (i+1)*u_info.bottom_brick.xyz, pos, inv_d, n, f);

			error = error + abs(dir) * max(f+0.01, 0.);
			pos += sign(dir) * floor(error);
			error = fract(error);

			continue;
		}

		do
		{
			uvec3 bit = uvec3(pos)%u_info.bottom_brick.xyz;
			uint b = To1D(bit, u_info.bottom_brick);
			if((bottom[b/32] & (1<<(b%32))) != 0)
			{
				c = vec4(1.);
				pos = uvec3(999999);
				break;
			}
			error += abs(dir);
			pos += sign(dir) * floor(error);
			error = fract(error);

		} while(all(equal(i, uvec3(pos)/u_info.bottom_brick.xyz)));
*/		
	}
	imageStore(i_render_target, ivec2(gl_GlobalInvocationID.xy), c);
}