
struct Particle
{
	vec3 pos;
	vec3 vel;
	vec3 acc;
	int b_index;
	int type
	ivec4 idx;

};

void MkBkt(inout Particle p)
{
	if (p.type == PT_Ghost) { return; }

	int pnumber = atomicExchange(GridLinkHead[p.grid_pos.w], p.b_index);
	GridLinkNext[p.b_index] = pnumber;
}

float getPrs(in ivec3 idx, in vec3 pos)
{
	idx = min(idx, u_info.GridCellNum - 1);
	vec3 pa = u_info.GridMin + u_info.GridCellSize * vec3(idx);
	vec3 fp = (pos - pa) * u_info.GridCellSizeInv;
	float value = sdf(dFluid, idx);

	ivec2 offset = ivec2(0, 1);
	vec4 a = vec4(prs(dFluid, idx + offset.xxx), prs(dFluid, idx + offset.yxx), prs(dFluid, idx + offset.xyx), prs(dFluid, idx + offset.yyx));
	vec4 b = vec4(prs(dFluid, idx + offset.xxy), prs(dFluid, idx + offset.yxy), prs(dFluid, idx + offset.xyy), prs(dFluid, idx + offset.yyy));
	float z = mix(a, b, fp.z);
	float xy = vec2(mix(z.xy(), z.zw(), fp.yy()));
	float dist = mix(vec1(xy.x), vec1(xy.y), vec1(fp.x)).x;

	return dist;
}

void VscTrm(inout Particle p) 
{
	int i = (int)gl_GlobalInvocationID.x;
	if (p.type == PT_Ghost || p.type == PT_Wall)
	{
		return;
	}
	vec3 viscosity = vec3(0.0);
	for (int jz = p.idx.z - 1; jz <= p.idx.z + 1; jz++) {
		if (jz < 0 || jz >= u_info.GridCellNum.z) { continue; }
		for (int jy = p.idx.y - 1; jy <= p.idx.y + 1; jy++) {
			if (jy < 0 || jy >= u_info.GridCellNum.y) { continue; }
			for (int jx = p.idx.x - 1; jx <= p.idx.x + 1; jx++) {
				if (jx < 0 || jx >= u_info.GridCellNum.x) { continue; }
				int jb = ToGridIndex(ivec3(jx, jy, jz));
				for (int j = GridLinkHead[jb]; j != -1; j = GridLinkNext[j])
				{
					if (i == j) { continue; }
					float dist2 = distance2(b_pos[j], p.pos);
					if (dist2 >= radius2) { continue; }

					float dist = sqrt(dist2);
					float w = WEI(dist, radius);
					viscosity += (b_vel[j] - p.vel) * w;
				}

			}
		}
	}

	float sdf = b_sdf[i];
	if (sdf < radius)
	{
		float w = WEI(sdf, radius);
		viscosity += (-vel) * w;
	}

	p.acc = viscosity * (u_info.viscosity / u_info.n0 / u_info.lmd);

}

void UpPcl1(inout Particle p)
{
//	int i = (int)gl_GlobalInvocationID.x;
//	if(i >= u_info.PNum) { return; }
	if (p.type == PT_Fluid || p.type == PT_Smoke)
	{
		if (p.type == PT_Fluid)
		{
			p.acc += Gravity;
		}
		p.vel += p.acc * DT;
		b_vel[p.b_index] = p.vel;
//		std::tie(std::ignore, b_pos[i], b_vel[i]) = raymarch(dFluid, b_pos[i], b_vel[i]);
//		vec4 sdf = getSDF(dFluid, ToGridCellIndex(dFluid, dFluid.Pos[i]), dFluid.Pos[i]);
//		b_sdf[i] = sdf.x;
//		b_sdf_normaln[i] = sdf.yzw;

		b_acc[i] = vec3(0.0);
	}
}

void ChkCol(inout Particle p)
{
	if (p.type != PT_Fluid && p.type != PT_Smoke) {
		return;
	}
	float mi = Dns[p.type];
	vec3 newvec = p.vel;
	for (int jz = p.idx.z - 1; jz <= p.idx.z + 1; jz++) {
		if (jz < 0 || jz >= u_info.GridCellNum.z) { continue; }
		for (int jy = p.idx.y - 1; jy <= p.idx.y + 1; jy++) {
			if (jy < 0 || jy >= u_info.GridCellNum.y) { continue; }
			for (int jx = p.idx.x - 1; jx <= p.idx.x + 1; jx++) {
				if (jx < 0 || jx >= u_info.GridCellNum.x) { continue; }
				int jb = ToGridIndex(dFluid, ivec3(jx, jy, jz));
				for (int j = GridLinkHead[jb]; j != -1; j = GridLinkNext[j])
				{
					if (i == j) { continue; }

					vec3 v = b_pos[j] - p.pos;
					float dist2 = dot(v, v);
					if (dist2 >= u_info.rlim2) { continue; }
					v = normalize(v);
					float fDT = dot((p.vel - b_vel[j]) * v, vec3(1.));
					if (fDT <= 0.0) { continue; } 

					float mj = Dns[b_type[j]];
					fDT *= u_info.COL * mj / (mi + mj);
					newvec -= v * fDT;
				}

			}
		}
	}
//	float sdf = b_sdf[i];
//	if (sdf < radius)
//	{
//		vec3 sdf_n = b_sdf_normal[i];
//		auto wallp = pos - sdf_n * sdf;
//
//		float fDT = dot(vel * -sdf_n, vec3(1.));
//		if (fDT > 0.0) {
//			float mj = Dns[PT_Wall];
//			fDT *= u_info.COL * mj / (mi + mj);
//			newvec -= -sdf_n * fDT;
//		}
//	}
	p.acc = newvec;
//	b_vel[p.b_index] = newvec;
}
void SetVel(inout Particle p)
{
	b_vel[p.b_index] = p.acc;
}

void MkPrs(inout Particle p) 
{
	if (p.type != PT_Fluid && p.type != PT_Smoke) {
		return;
	}
	float ni = 0.0;
	for (int jz = p.idx.z - 1; jz <= p.idx.z + 1; jz++) {
		if (jz < 0 || jz >= u_info.GridCellNum.z) { continue; }
		for (int jy = p.idx.y - 1; jy <= p.idx.y + 1; jy++) {
			if (jy < 0 || jy >= u_info.GridCellNum.y) { continue; }
			for (int jx = p.idx.x - 1; jx <= p.idx.x + 1; jx++) {
				if (jx < 0 || jx >= u_info.GridCellNum.x) { continue; }
				int jb = ToGridIndex(ivec3(jx, jy, jz));
				for (int j = GridLinkHead[jb]; j != -1; j = GridLinkNext[j])
				{
					if (i == j) { continue; }
					float dist2 = distance2(b_pos[j], pos);
					if (dist2 >= radius2) { continue; }
					float dist = sqrt(dist2);
					float w = WEI(dist, radius);
					ni += w;
				}
			}
		}
	}
	float mi = Dns[p.type];
	float pressure = (ni > u_info.n0) * (ni - u_info.n0) * mi;
	b_prs[p.b_index] = pressure;
}

void MkPrsWall() 
{
	for (int z = 0; z < u_info.GridCellNum.z; z++) {
		for (int y = 0; y < u_info.GridCellNum.y; y++) {
			for (int x = 0; x < u_info.GridCellNum.x; x++) {
				int i = ToGridIndex(dFluid, ivec3(x, y, z));
				{
					if (dFluid.m_WallSDF[i] > radius * 2 * sqrt(3.f))
					{
						continue;
					}

				}

				float ni = 0.0;
				for (int jz = z - 1; jz <= z + 1; jz++) {
					if (jz < 0 || jz >= u_info.GridCellNum.z) { continue; }
					for (int jy = y - 1; jy <= y + 1; jy++) {
						if (jy < 0 || jy >= u_info.GridCellNum.y) { continue; }
						for (int jx = x - 1; jx <= x + 1; jx++) {
							if (jx < 0 || jx >= u_info.GridCellNum.x) { continue; }
							int jb = ToGridIndex(dFluid, ivec3(jx, jy, jz));
							for (int j = GridLinkHead[jb]; j != -1; j = GridLinkNext[j])
							{
								if (b_type[j] != PT_Fluid) {
									continue;
								}
								float sdf = b_sdf[j];
								if (sdf >= radius) { continue; }
								float w = WEI(sdf, radius);
								ni += w;
							}
						}
					}
				}
				float mi = Dns[PT_Wall];
				float pressure = (ni > u_info.n0) * (ni - u_info.n0) * mi;
				wallPrs[i] = pressure;

			}
		}
	}
}

void PrsGrdTrm(inout Particle p)
{
	int i = (int)gl_GlobalInvocationID.x;
	if(i >= u_info.PNum) { return; }
	if (p.type != PT_Fluid && p.type != PT_Smoke) {
		return;
	}
	vec3 acc = vec3(0.0);
	float pre_min = b_prs[i];
	for (int jz = p.idx.z - 1; jz <= p.idx.z + 1; jz++) {
		if (jz < 0 || jz >= u_info.GridCellNum.z) { continue; }
		for (int jy = p.idx.y - 1; jy <= p.idx.y + 1; jy++) {
			if (jy < 0 || jy >= u_info.GridCellNum.y) { continue; }
			for (int jx = p.idx.x - 1; jx <= p.idx.x + 1; jx++) {
				if (jx < 0 || jx >= u_info.GridCellNum.x) { continue; }
				int jb = ToGridIndex(dFluid, ivec3(jx, jy, jz));
				for (int j = GridLinkHead[jb]; j != -1; j = GridLinkNext[j])
				{
					if (i == j) { continue; }
					if (distance2(b_pos[j], p.pos) >= radius2) { continue; }
					if (pre_min > b_prs[j])
					{
						pre_min = b_prs[j];
					}
				}

				if (pre_min > wallPrs[jb])
				{
					float sdf = b_sdf[jb];
					if (sdf < radius)
					{
						pre_min = wallPrs[jb];
					}
				}

			}
		}
	}
	for (int jz = idx.z - 1; jz <= idx.z + 1; jz++) {
		if (jz < 0 || jz >= u_info.GridCellNum.z) { continue; }
		for (int jy = idx.y - 1; jy <= idx.y + 1; jy++) {
			if (jy < 0 || jy >= u_info.GridCellNum.y) { continue; }
			for (int jx = idx.x - 1; jx <= idx.x + 1; jx++) {
				if (jx < 0 || jx >= u_info.GridCellNum.x) { continue; }
				int jb = ToGridIndex(dFluid, ivec3(jx, jy, jz));
				for (int j = GridLinkHead[jb]; j != -1; j = GridLinkNext[j])
				{
					if (i == j) { continue; }
					auto v = b_pos[j] - pos;
					float dist2 = dot(v, v);
					if (dist2 >= radius2) { continue; }

					float dist = sqrt(dist2);
					float w = WEI(dist, radius);
					w *= (b_prs[j] - pre_min) / (dist2);
					acc += v * w;
				}
			}
		}
	}
	float sdf = b_sdf[i];
	if (sdf < radius)
	{
		float w = WEI(sdf, radius);
		w *= (wallPrs[idx.w] - pre_min);

		float sdf_n = b_sdf_normal[i];
		auto wallp = pos - sdf_n * sdf;
		acc += -sdf_n * w;
	}

	p.acc = acc * invDns[PT_Fluid] * -1.f;
}

void UpPcl2(inout Particle p)
{
	if (p.type != PT_Fluid && p.type != PT_Smoke) {
		return;
	}
	b_vel[p.b_index] += p.acc * DT;
	p.acc = vec3(0.0);
}

void main()
{
	int i = (int)gl_GlobalInvocationID.x;
	Particle p;
	p.pos = b_pos[i];
	p.vel = b_vel[i];
	p.type = b_type[i];
	p.b_index = i;
	p.idx = ToGridIndex(p.pos);

	MkBkt(p);
	memoryBarrierBuffer();
	VscTrm(p);
	memoryBarrierBuffer();
	UpPcl1(p);
	memoryBarrierBuffer();
	ChkCol(p);
	memoryBarrierBuffer();
	SetVel(p);
	memoryBarrierBuffer();
	MkPrs(p);
	memoryBarrierBuffer();
	PrsGrdTrm(p);
	memoryBarrierBuffer();
	UpPcl2(p);
}
