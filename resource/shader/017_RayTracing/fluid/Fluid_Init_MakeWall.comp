

void MkBkt()
{
	int i = (int)gl_GlobalInvocationID.x;
	if(i >= u_info.PNum) { return; }
	if (b_PType[i] == PT_Ghost) { return; }

	int ib = ToGridIndex(b_pos[i]);
	int pnumber = atomicExchange(GridLinkHead[ib], i);
	GridLinkNext[i] = pnumber;
}

float sdf(in ivec3 idx)
{
	return dFluid.m_WallSDF[ToGridIndex(idx)];
}

float prs(in ivec3 idx)
{
	return wallPrs[ToGridIndex(idx)];
}

float getPrs(in ivec3 idx, in vec3 pos)
{
	idx = min(idx, u_info.GridCellNum - 1);
	vec3 pa = u_info.GridMin + u_info.GridCellSize * vec3(idx);
	vec3 fp = (pos - pa) * u_info.GridCellSizeInv;
	auto value = sdf(dFluid, idx);

	ivec2 offset = ivec2(0, 1);
	vec4 a = vec4(prs(dFluid, idx + offset.xxx), prs(dFluid, idx + offset.yxx), prs(dFluid, idx + offset.xyx), prs(dFluid, idx + offset.yyx));
	vec4 b = vec4(prs(dFluid, idx + offset.xxy), prs(dFluid, idx + offset.yxy), prs(dFluid, idx + offset.xyy), prs(dFluid, idx + offset.yyy));
	auto z = mix(a, b, fp.z);
	auto xy = vec2(mix(z.xy(), z.zw(), fp.yy()));
	auto dist = mix(vec1(xy.x), vec1(xy.y), vec1(fp.x)).x;

	return dist;
}

void VscTrm() 
{
	int i = (int)gl_GlobalInvocationID.x;
	if (b_type[i] == PT_Ghost || b_type[i] == PT_Wall)
	{
		return;
	}
	vec3 viscosity = vec3(0.0);
	vec3 pos = b_pos[i];
	vec3 vel = b_vel[i];
	ivec3 idx = ToGridCellIndex(dFluid, pos);
	for (int jz = idx.z - 1; jz <= idx.z + 1; jz++) {
		if (jz < 0 || jz >= u_info.GridCellNum.z) { continue; }
		for (int jy = idx.y - 1; jy <= idx.y + 1; jy++) {
			if (jy < 0 || jy >= u_info.GridCellNum.y) { continue; }
			for (int jx = idx.x - 1; jx <= idx.x + 1; jx++) {
				if (jx < 0 || jx >= u_info.GridCellNum.x) { continue; }
				int jb = ToGridIndex(dFluid, ivec3(jx, jy, jz));
				for (int j = GridLinkHead[jb]; j != -1; j = GridLinkNext[j])
				{
					if (i == j) { continue; }
					float dist2 = distance2(b_pos[j], pos);
					if (dist2 >= radius2) { continue; }

					float dist = sqrt(dist2);
					float w = WEI(dist, radius);
					viscosity += (b_vel[j] - vel) * w;
				}

			}
		}
	}

	float sdf = b_sdf[i];
	if (sdf < radius)
	{
		float w = WEI(sdf, radius);
		viscosity += (-vel) * w;
	}

	b_acc[i] = viscosity * (u_info.viscosity / u_info.n0 / u_info.lmd);

}

void UpPcl1()
{
	int i = (int)gl_GlobalInvocationID.x;
	if (b_type[i] == PT_Fluid || b_type[i] == PT_Smoke)
	{
		vec3 acc = b_acc[i];
		if (b_type[i] == PT_Fluid)
		{
			acc += Gravity;
		}
		b_vel[i] += acc * DT;
		std::tie(std::ignore, b_pos[i], b_vel[i]) = raymarch(dFluid, b_pos[i], b_vel[i]);
		vec4 sdf = getSDF(dFluid, ToGridCellIndex(dFluid, dFluid.Pos[i]), dFluid.Pos[i]);
		b_sdf[i] = sdf.x;
		b_sdf_normaln[i] = sdf.yzw;

		b_acc[i] = vec3(0.0);
	}
}

void ChkCol()
{
	int i = (int)gl_GlobalInvocationID.x;
	if (b_type[i] != PT_Fluid && b_type[i] != PT_Smoke) {
		return;
	}
	float mi = Dns[b_type[i]];
	vec3 pos = b_pos[i];
	vec3 vel = b_vel[i];
	vec3 vec_ix2 = vel;
	ivec4 idx = ToGridIndex(pos);
	for (int jz = idx.z - 1; jz <= idx.z + 1; jz++) {
		if (jz < 0 || jz >= u_info.GridCellNum.z) { continue; }
		for (int jy = idx.y - 1; jy <= idx.y + 1; jy++) {
			if (jy < 0 || jy >= u_info.GridCellNum.y) { continue; }
			for (int jx = idx.x - 1; jx <= idx.x + 1; jx++) {
				if (jx < 0 || jx >= u_info.GridCellNum.x) { continue; }
				int jb = ToGridIndex(dFluid, ivec3(jx, jy, jz));
				for (int j = GridLinkHead[jb]; j != -1; j = GridLinkNext[j])
				{
					if (i == j) { continue; }

					vec3 v = b_pos[j] - pos;
					float dist2 = dot(v, v);
					if (dist2 >= u_info.rlim2) { continue; }
					v = normalize(v);
					float fDT = dot((vel - b_vel[j]) * v, vec3(1.));
					if (fDT <= 0.0) { continue; } 

					float mj = Dns[b_type[j]];
					fDT *= u_info.COL * mj / (mi + mj);
					vec_ix2 -= v * fDT;
				}

			}
		}
	}
	float sdf = b_sdf[i];
	if (sdf < radius)
	{
		vec3 sdf_n = b_sdf_normal[i];
		auto wallp = pos - sdf_n * sdf;

		float fDT = dot(vel * -sdf_n, vec3(1.));
		if (fDT > 0.0) {
			float mj = Dns[PT_Wall];
			fDT *= u_info.COL * mj / (mi + mj);
			vec_ix2 -= -sdf_n * fDT;
		}
	}
	b_acc[i] = vec_ix2;

	for (int i = 0; i < dFluid.PNum; i++)
	{
		b_vel[i] = b_acc[i];
	}
}

void MkPrs() 
{
	int i = (int)gl_GlobalInvocationID.x;
	if (b_type[i] != PT_Fluid && b_type[i] != PT_Smoke) {
		return;
	}

	vec3 pos = b_pos[i];
	float ni = 0.0;

	ivec4 idx = ToGridCellIndex(pos);
	for (int jz = idx.z - 1; jz <= idx.z + 1; jz++) {
		if (jz < 0 || jz >= u_info.GridCellNum.z) { continue; }
		for (int jy = idx.y - 1; jy <= idx.y + 1; jy++) {
			if (jy < 0 || jy >= u_info.GridCellNum.y) { continue; }
			for (int jx = idx.x - 1; jx <= idx.x + 1; jx++) {
				if (jx < 0 || jx >= u_info.GridCellNum.x) { continue; }
				int jb = ToGridIndex(dFluid, ivec3(jx, jy, jz));
				for (int j = GridLinkHead[jb]; j != -1; j = GridLinkNext[j])
				{
					if (i == j) { continue; }
					float dist2 = distance2(b_pos[j], pos);
					if (dist2 >= radius2) { continue; }
					float dist = sqrt(dist2);
					float w = WEI(dist, radius);
					ni += w;
				}
			}
		}
	}
	float mi = Dns[b_type[i]];
	float pressure = (ni > u_info.n0) * (ni - u_info.n0) * mi;
	b_prs[i] = pressure;

	for (int z = 0; z < u_info.GridCellNum.z; z++) {
		for (int y = 0; y < u_info.GridCellNum.y; y++) {
			for (int x = 0; x < u_info.GridCellNum.x; x++) {
				int i = ToGridIndex(dFluid, ivec3(x, y, z));
				{
					if (dFluid.m_WallSDF[i] > radius * 2 * sqrt(3.f))
					{
						continue;
					}

				}

				float ni = 0.0;
				for (int jz = z - 1; jz <= z + 1; jz++) {
					if (jz < 0 || jz >= u_info.GridCellNum.z) { continue; }
					for (int jy = y - 1; jy <= y + 1; jy++) {
						if (jy < 0 || jy >= u_info.GridCellNum.y) { continue; }
						for (int jx = x - 1; jx <= x + 1; jx++) {
							if (jx < 0 || jx >= u_info.GridCellNum.x) { continue; }
							int jb = ToGridIndex(dFluid, ivec3(jx, jy, jz));
							for (int j = GridLinkHead[jb]; j != -1; j = GridLinkNext[j])
							{
								if (b_type[j] != PT_Fluid) {
									continue;
								}
								float sdf = b_sdf[j];
								if (sdf >= radius) { continue; }
								float w = WEI(sdf, radius);
								ni += w;
							}
						}
					}
				}
				float mi = Dns[PT_Wall];
				float pressure = (ni > u_info.n0) * (ni - u_info.n0) * mi;
				wallPrs[i] = pressure;

			}
		}
	}
}

void PrsGrdTrm()
{
	int i = (int)gl_GlobalInvocationID.x;
	if (b_type[i] != PT_Fluid && b_type[i] != PT_Smoke) {
		return;
	}
	vec3 acc = vec3(0.0);
	vec3 pos = b_pos[i];
	float pre_min = b_prs[i];
	ivec4 idx = ToGridCellIndex(pos);
	for (int jz = idx.z - 1; jz <= idx.z + 1; jz++) {
		if (jz < 0 || jz >= u_info.GridCellNum.z) { continue; }
		for (int jy = idx.y - 1; jy <= idx.y + 1; jy++) {
			if (jy < 0 || jy >= u_info.GridCellNum.y) { continue; }
			for (int jx = idx.x - 1; jx <= idx.x + 1; jx++) {
				if (jx < 0 || jx >= u_info.GridCellNum.x) { continue; }
				int jb = ToGridIndex(dFluid, ivec3(jx, jy, jz));
				for (int j = GridLinkHead[jb]; j != -1; j = GridLinkNext[j])
				{
					if (i == j) { continue; }
					if (distance2(b_pos[j], pos) >= radius2) { continue; }
					if (pre_min > b_prs[j])
					{
						pre_min = b_prs[j];
					}
				}

				if (pre_min > wallPrs[jb])
				{
					float sdf = b_sdf[jb];
					if (sdf < radius)
					{
						pre_min = wallPrs[jb];
					}
				}

			}
		}
	}
	for (int jz = idx.z - 1; jz <= idx.z + 1; jz++) {
		if (jz < 0 || jz >= u_info.GridCellNum.z) { continue; }
		for (int jy = idx.y - 1; jy <= idx.y + 1; jy++) {
			if (jy < 0 || jy >= u_info.GridCellNum.y) { continue; }
			for (int jx = idx.x - 1; jx <= idx.x + 1; jx++) {
				if (jx < 0 || jx >= u_info.GridCellNum.x) { continue; }
				int jb = ToGridIndex(dFluid, ivec3(jx, jy, jz));
				for (int j = GridLinkHead[jb]; j != -1; j = GridLinkNext[j])
				{
					if (i == j) { continue; }
					auto v = b_pos[j] - pos;
					float dist2 = dot(v, v);
					if (dist2 >= radius2) { continue; }

					float dist = sqrt(dist2);
					float w = WEI(dist, radius);
					w *= (b_prs[j] - pre_min) / (dist2);
					acc += v * w;
				}
			}
		}
	}
	float sdf = b_sdf[i];
	if (sdf < radius)
	{
		float w = WEI(sdf, radius);
		w *= (wallPrs[idx.w] - pre_min);

		float sdf_n = b_sdf_normal[i];
		auto wallp = pos - sdf_n * sdf;
		acc += -sdf_n * w;
	}

	b_acc[i] = acc * invDns[PT_Fluid] * -1.f;
}

void UpPcl2()
{
	int i = (int)gl_GlobalInvocationID.x;
	if (b_type[i] != PT_Fluid && b_type[i] != PT_Smoke) {
		return;
	}
	b_vel[i] += b_acc[i] * DT;
	b_acc[i] = vec3(0.0);
}

void init()
{
	AlcBkt();
	SetPara();
}
void run()
{
	MkBkt();
	VscTrm();
	UpPcl1();
	ChkCol();
	MkPrs();
	PrsGrdTrm();
	UpPcl2();
}