void AlcBkt()
{
	n = (dFluid.m_constant.GridMax - dFluid.m_constant.GridMin) / u_info.ParticleDst;
	int count = 0;
	for (int iz = 0; iz < n.z; iz++) {
		for (int iy = 0; iy < n.y; iy++) {
			for (int ix = 0; ix < n.x; ix++) {
				int ip = iz * n.x * n.y + iy * n.x + ix;
				if (ix < 3 || ix >= n.x - 3 || iz < 3 || iz >= n.z - 3 || iy < 3) {
					// 壁を作る
#if defined(REFERENCE)
					b_type[count] = PT_Wall;
					b_pos[count] = dFluid.m_constant.GridMin + u_info.ParticleDst * vec3(ivec3(ix, iy, iz));
					count++;
#endif
				}
				else if (iy >= 10 && iy <= 15 && ix <= 15 && iz <= 15) {
					// ダムを造る
					b_type[count] = PT_Fluid;
					b_pos[count] = dFluid.m_constant.GridMin + u_info.ParticleDst * vec3(ivec3(ix, iy, iz));
					count++;
				}
			}
		}
	}
	dFluid.PNum_Active = count;
}

void SetPara(FluidData& dFluid) {
	float tn0 = 0.0;
	float tlmd = 0.0;
	for (int ix = -4; ix < 5; ix++) {
		for (int iy = -4; iy < 5; iy++) {
			for (int iz = -4; iz < 5; iz++) {
				vec3 p = u_info.ParticleDst * vec3(ix, iy, iz);
				float dist2 = dot(p, p);
				if (dist2 <= radius2) {
					if (dist2 == 0.0)continue;
					float dist = sqrt(dist2);
					tn0 += WEI(dist, radius);
					tlmd += dist2 * WEI(dist, radius);
				}
			}
		}
	}


	dFluid.m_constant.n0 = tn0;			//初期粒子数密度
	dFluid.m_constant.lmd = tlmd / tn0;	//ラプラシアンモデルの係数λ
	dFluid.m_constant.rlim = u_info.ParticleDst * DST_LMT_RAT;//これ以上の粒子間の接近を許さない距離
	dFluid.m_constant.rlim2 = dFluid.m_constant.rlim * dFluid.m_constant.rlim;
	dFluid.m_constant.COL = 1.0 + COL_RAT;

	Dns[PT_Fluid] = DNS_FLD;
	Dns[PT_Smoke] = DNS_SMORK;
	Dns[PT_Wall] = DNS_WLL;
	invDns[PT_Fluid] = 1.0 / DNS_FLD;
	invDns[PT_Wall] = 1.0 / DNS_WLL;
	invDns[PT_Smoke] = 1.f / Dns[PT_Smoke];
}


void MkBkt(FluidData& dFluid)
{
	std::fill(GridLinkHead.begin(), GridLinkHead.end(), -1);
	for (int i = 0; i < dFluid.PNum; i++)
	{
		if (b_type[i] == PT_Ghost)continue;
		int ib = ToGridIndex(dFluid, b_pos[i]);
		int pnumber = GridLinkHead[ib];
		GridLinkHead[ib] = i;
		GridLinkNext[i] = pnumber;
	}
}
