#version 460

#extension GL_GOOGLE_include_directive : require

#define USE_LDC 0
#include "LDC.glsl"


/* Solves for x in  A*x = b.
	'A' contains the matrix row-wise.
	'b' and 'x' are column vectors.
Uses cramers rule.
*/
vec3 solve3x3(in float A[3][3], in float b[3]) {
	float det = determinant(mat3(
		A[0][0], A[0][1], A[0][2],
		A[1][0], A[1][1], A[1][2],
		A[2][0], A[2][1], A[2][2]));

	if (abs(det) <= 1e-12) {
		return vec3(0.5);
	}

	return vec3 
	(
		determinant(mat3(
			b[0],    A[0][1], A[0][2],
			b[1],    A[1][1], A[1][2],
			b[2],    A[2][1], A[2][2])),

		determinant(mat3(
			A[0][0], b[0],    A[0][2],
			A[1][0], b[1],    A[1][2],
			A[2][0], b[2],    A[2][2])),

		determinant(mat3(
			A[0][0], A[0][1], b[0],
			A[1][0], A[1][1], b[1],
			A[2][0], A[2][1], b[2]))
	) / det;
}

/*
Solves A*x = b for over-determined systems.

Solves using  At*A*x = At*b   trick where At is the transponate of A
*/
vec3 leastSquares(in int N, in vec3[27] A, in float b[27])
{
	float At_A[3][3];
	float At_b[3];

	for (int i=0; i<3; ++i)
	{
		for (int j=0; j<3; ++j)
		{
			float sum = 0.;
			for (int k=0; k<N; ++k)
			{
				sum += A[k][i] * A[k][j];
			}
			At_A[i][j] = sum;
		}
	}

	for (int i=0; i<3; ++i)
	{
		float sum = 0.;
		for (int k=0; k<N; ++k)
		{
			sum += A[k][i] * b[k];
		}

		At_b[i] = sum;
	}
	return solve3x3(At_A, At_b);
}

layout (local_size_x = 64) in;

void main() 
{
	vec3 axis[] = {vec3(1., 0., 0.),vec3(0., 1., 0.),vec3(0., 0., 1.),};
	uvec3 reso = gl_NumWorkGroups * gl_WorkGroupSize;

	vec3 extent = u_info.m_aabb_max.xyz-u_info.m_aabb_min.xyz;
	vec3 voxel_size = extent / reso;

	vec3 plane_normal[27];
	float d[27];
	uint bbb[24];
	int normal_num = 0;

	for(int z = 0; z<2; z++)
	for(int y = 0; y<2; y++)
	for(int x = 0; x<2; x++)
	{
		uvec3 _i = gl_GlobalInvocationID+uvec3(x, y, z);
		uint idx = _i.x + _i.y*reso.x + _i.z*reso.x*reso.y;
		if(b_dcv_hashmap[idx]<0){ return; }

		LDCCell cell = b_ldc_cell[idx];
		uint use_axis = (cell.useaxis_xyz&0xffu);
//		vec3 point = vec3((uvec3(cell.useaxis_xyz)>>uvec3(8, 16, 24)) & uvec3(0xffu));
//		point = point / 255.;


		for(int i = 0; i < 3; i++)
		{
			if((use_axis&(1<<i)) == 0){ continue; }


			bool cancel = false;
			for(int _i = 0; _i < normal_num; _i++)
			{
				if(bbb[_i] == cell.primitive_index[i])
				{
					cancel = true;
					break;
				}
			}

			if(cancel){continue;}

			uvec3 i0 = b_index[cell.primitive_index[i]];
			vec3 a = b_vertex[i0.x];
			vec3 b = b_vertex[i0.y];
			vec3 c = b_vertex[i0.z];
			vec3 nrm = normalize(cross(b - a, c - a));
			plane_normal[normal_num] = nrm;
			d[normal_num] = dot(nrm, a);
			bbb[normal_num] = cell.primitive_index[i];

			normal_num++;
		}

	}

	if(normal_num == 0){ return; }
	if(normal_num == 1)
	{

	}

	float n = 0.01;
	plane_normal[normal_num] = axis[0]*n;
	plane_normal[normal_num+1] = axis[1]*n;
	plane_normal[normal_num+2] = axis[2]*n;
	d[normal_num] = dot(axis[0], vec3(0.5));
	d[normal_num+1] = dot(axis[1], vec3(0.5));
	d[normal_num+2] = dot(axis[2], vec3(0.5));
//	normal_num+=3;

	uvec3 _i = gl_GlobalInvocationID;
		uint idx = _i.x + _i.y*reso.x + _i.z*reso.x*reso.y;
	b_dcv_vertex[idx] = leastSquares(normal_num, plane_normal, d)*voxel_size + gl_GlobalInvocationID*voxel_size;
//	b_dcv_vertex[idx] = plane_normal[0]*100.;
//	b_dcv_vertex[idx] = gl_GlobalInvocationID*voxel_size;

}