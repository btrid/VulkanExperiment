#version 460

#extension GL_GOOGLE_include_directive : require

#define USE_AS 0
#define USE_LDC 1
#include "LDC.glsl"

layout(location = 0) rayPayloadEXT float RayMaxT;
layout(location = 1) rayPayloadEXT uint PrimitiveID;


void main() 
{
	uint grid = gl_LaunchIDEXT.x + gl_LaunchIDEXT.y*gl_LaunchSizeEXT.x + gl_LaunchIDEXT.z*gl_LaunchSizeEXT.x*gl_LaunchSizeEXT.y;
	int head = -1;
	b_ldc_point_link_head[grid] = head;

//	if(gl_LaunchIDEXT.z == 0){ return; }
//	if(gl_LaunchIDEXT.z == 1){ return; }

	vec3 axis[3] = {vec3(1., 0., 0.), vec3(0., 1., 0.),vec3(0., 0., 1.)};
	vec3 f = axis[(gl_LaunchIDEXT.z+0)%3];
	vec3 s = axis[(gl_LaunchIDEXT.z+1)%3]; 
	vec3 u = axis[(gl_LaunchIDEXT.z+2)%3];

	vec3 extent = u_info.m_aabb_max.xyz-u_info.m_aabb_min.xyz;
	vec3 min = u_info.m_aabb_min.xyz;

	vec3 rate = vec3(gl_LaunchIDEXT) / vec3(gl_LaunchSizeEXT);
	vec3 origin = min + (s*rate.x*extent[(gl_LaunchIDEXT.z+1)%3]+u*rate.y*extent[(gl_LaunchIDEXT.z+2)%3]);

	RayMaxT = 0.;
	float tmax = extent[gl_LaunchIDEXT.z];

	for (;;)
	{
		traceRayEXT(topLevelAS, gl_RayFlagsNoOpaqueEXT, 0xff, 0, 0, 0, origin.xyz, RayMaxT, f, tmax, 0);
		if(RayMaxT < -1.)
		{
			break;
		}

		int index = atomicAdd(b_ldc_counter, 1);
		LDCPoint point;
		point.p = RayMaxT;
		point.primitive_index = PrimitiveID;
		point.inout_next = head;

		b_ldc_point[index] = point;
		b_ldc_point_link_head[grid] = index;

		head = index;

		RayMaxT += tmax * Voxel_Reso[gl_LaunchSizeEXT.z];
	}

}
