#version 460

#extension GL_GOOGLE_include_directive : require

#define USE_AS 0
#define USE_LDC 1
#include "LDC.glsl"

layout(location = 0) rayPayloadEXT float RayMaxT;
//layout(location = 1) rayPayloadEXT LDCPoint Point;


void main() 
{
	vec3 axis[3] = {vec3(1., 0., 0.), vec3(0., 1., 0.),vec3(0., 0., 1.)};
	vec3 f = axis[(gl_LaunchIDEXT.z+0)%3];
	vec3 s = axis[(gl_LaunchIDEXT.z+1)%3]; 
	vec3 u = axis[(gl_LaunchIDEXT.z+2)%3];

	vec3 extent = u_info.m_aabb_max.xyz-u_info.m_aabb_min.xyz;
	vec3 min = u_info.m_aabb_min.xyz;

	vec3 rate = vec3(gl_LaunchIDEXT) / vec3(gl_LaunchSizeEXT) * extent;
	vec3 origin = min + (s*rate.x+u*rate.y)-f*0.5;

	RayMaxT = 0.;
	float tmax = extent[gl_LaunchIDEXT.z]+1.;

	uint grid = gl_LaunchIDEXT.x + gl_LaunchIDEXT.y*gl_LaunchSizeEXT.x + gl_LaunchIDEXT.z*gl_LaunchSizeEXT.x*gl_LaunchSizeEXT.y;
	int head = -1;
	b_ldc_point_link_head[grid] = head;
	for (;;)
	{
		traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin.xyz, RayMaxT, f, tmax, 0);
		if(RayMaxT < -1.)
		{
			break;
		}

/*		int index = atomicAdd(b_ldc_counter, 1);
		Point.p = clamp(Point.p-0.5, 0, tmax-1.5);
		Point.inout_next |=  head;
		b_ldc_point[index] = Point;
		b_ldc_point_link_head[grid] = index;
		head = index;
*/
		RayMaxT += 0.05;
	}

}
