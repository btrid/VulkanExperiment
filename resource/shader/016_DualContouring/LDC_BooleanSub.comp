#version 460

#extension GL_GOOGLE_include_directive : require

#define USE_DC 0
#define USE_DC_Boolean 1
#include "DualContouring.glsl"

layout (local_size_x = 64) in;


void main() 
{
	int grid = int(gl_GlobalInvocationID.x + gl_GlobalInvocationID.y*Voxel_Reso.x + gl_GlobalInvocationID.z*Voxel_Reso.x*Voxel_Reso.y);
	int index_a = b_ldc_point_link_head[grid];
	int index_b = b_ldc_point_link_head_b[grid];
	if(index_a <0){ return; }
	if(index_b <0){ return; }

	LDCPoint invalid_point;
	invalid_point.p = -1.;
	invalid_point.next = -1;
	LDCPoint point_a = b_ldc_point[index_a];
	LDCPoint point_b = b_ldc_point_b[index_b];

	bool is_incident_a = false;
	bool is_incident_b = false;

	int head = -1;
	for(;(point_a.p>=0)||(point_b.p>=0);)
	{
		if(point_a.p>point_b.p)
		{
			if(!is_incident_b)
			{
				int index = atomicAdd(b_ldc_counter, 1);
				LDCPoint point = point_a;
				point.next = head;
				b_ldc_point[index] = point;
				head = index;
			}

			is_incident_a = !is_incident_a;
			if(point_a.next>=0) { point_a = b_ldc_point[point_a.next]; }
			else{ point_a = invalid_point;}
		}
		else if(point_b.p>=point_a.p)
		{
			if(is_incident_a)
			{
				int index = atomicAdd(b_ldc_counter, 1);
				LDCPoint point = point_b;
				point.next = head;
				b_ldc_point[index] = point;
				head = index;
			}
			is_incident_b = !is_incident_b;

			if(point_b.next>=0) { point_b = b_ldc_point_b[point_b.next]; }
			else { point_b = invalid_point;}
		}
	}

	b_ldc_point_link_head[grid] = head;
}