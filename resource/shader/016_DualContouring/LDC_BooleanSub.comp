#version 460

#extension GL_GOOGLE_include_directive : require

#define USE_DC 0
#define USE_Model 1
#include "DualContouring.glsl"

layout (local_size_x = 64) in;

LDCPoint getLDCPoint(inout float t, in float tmax, in vec3 origin, in vec3 f)
{
	rayQueryEXT rayQuery;
	rayQueryInitializeEXT(rayQuery,	topLevelAS, gl_RayFlagsOpaqueEXT, 0xFF, origin, t, f, tmax);
	while(rayQueryProceedEXT(rayQuery)) {}

	t = rayQueryGetIntersectionTEXT(rayQuery, true);
	if(t >= tmax)
	{ 
		return g_invalid_point;
	}
	else
	{
		uvec3 i0 = b_index[rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true)];
		vec3 a = b_vertex[i0.x];
		vec3 b = b_vertex[i0.y];
		vec3 c = b_vertex[i0.z];
		vec3 normal = normalize(cross(b - a, c - a));

		LDCPoint point;
		point.p = tmax-t;
		point.normal = pack_normal_octahedron(normal);
		return point;
	}
}

void main() 
{
	int grid = int(gl_GlobalInvocationID.x + gl_GlobalInvocationID.y*Voxel_Reso.x + gl_GlobalInvocationID.z*Voxel_Reso.x*Voxel_Reso.y);
	int index_a = b_ldc_point_link_head[grid];
	if(index_a <0){ return; }


	vec3 axis[3] = {vec3(1., 0., 0.), vec3(0., 1., 0.),vec3(0., 0., 1.)};
	vec3 f = axis[(gl_GlobalInvocationID.z+0)%3];
	vec3 s = axis[(gl_GlobalInvocationID.z+1)%3]; 
	vec3 u = axis[(gl_GlobalInvocationID.z+2)%3];

	vec3 extent = Voxel_Block_Size;
	vec3 min = u_info.m_aabb_min.xyz;

	vec3 rate = vec3(gl_GlobalInvocationID) / vec3(gl_NumWorkGroups*gl_WorkGroupSize);
	vec3 origin = min + (s*rate.x*extent[(gl_GlobalInvocationID.z+1)%3]+u*rate.y*extent[(gl_GlobalInvocationID.z+2)%3]);
	origin += extent*f;
	f=-f;

	float t = 0.;
	float tmax = extent[gl_GlobalInvocationID.z];

	LDCPoint point_b = getLDCPoint(t, tmax, origin, f);
	if(point_b.p < 0.){ return; }

	LDCPoint point_a = b_ldc_point[index_a];
	bool is_incident_a = false;
	bool is_incident_b = false;
	int head = -1;

	for(;(point_a.p>=0)||(point_b.p>=0);)
	{
		if(point_a.p>point_b.p)
		{
			if(!is_incident_b)
			{
				int index = atomicAdd(b_ldc_counter, 1);
				LDCPoint point = point_a;
				point.next = head;
				b_ldc_point[index] = point;
				head = index;
			}

			is_incident_a = !is_incident_a;
			if(point_a.next>=0) { point_a = b_ldc_point[point_a.next]; }
			else{ point_a = g_invalid_point;}
		}
		else
		{
			if(is_incident_a)
			{
				int index = atomicAdd(b_ldc_counter, 1);
				LDCPoint point = point_b;
				point.next = head;
				b_ldc_point[index] = point;
				head = index;
			}
			is_incident_b = !is_incident_b;

			point_b = getLDCPoint(t, tmax, origin, f);
		}
	}

	b_ldc_point_link_head[grid] = head;
}