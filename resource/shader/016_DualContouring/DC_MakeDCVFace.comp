#version 460

#extension GL_GOOGLE_include_directive : require

#define USE_LDC 0
#include "LDC.glsl"

layout (local_size_x = 64, local_size_y=1) in;

void main() 
{
	vec3 axis[] = {vec3(1., 0., 0.),vec3(0., 1., 0.),vec3(0., 0., 1.),};
	uvec3 reso = gl_NumWorkGroups * gl_WorkGroupSize;

//	if(any(greaterThanEqual(gl_GlobalInvocationID, reso-1))){ return; }

	vec3 extent = u_info.m_aabb_max.xyz-u_info.m_aabb_min.xyz;
	vec3 voxel_size = extent / reso;

	uint i0 = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y*reso.x + gl_GlobalInvocationID.z*reso.x*reso.y;

	uvec3 offset[3][3] = {
		{{1,0,0}, {0, 1, 0}, {1, 1, 0}},
		{{0,1,0}, {0, 0, 1}, {0, 1, 1}},
		{{1,0,0}, {0, 0, 1}, {1, 0, 1}},
	};
	if(b_dcv_hashmap[i0]<0){ return; }

	for(int i = 0; i < 3; i++)
	{
		if(any(greaterThanEqual(gl_GlobalInvocationID + uvec3(i!=1, i!=2, i!=0), reso))){ continue; }
		uvec3 i31 = gl_GlobalInvocationID + offset[i][0];
		uint i1 = i31.x + i31.y*reso.x + i31.z*reso.x*reso.y;
		uvec3 i32 = gl_GlobalInvocationID + offset[i][1];
		uint i2 = i32.x + i32.y*reso.x + i32.z*reso.x*reso.y;
		uvec3 i33 = gl_GlobalInvocationID + offset[i][2];
		uint i3 = i33.x + i33.y*reso.x + i33.z*reso.x*reso.y;
		if(b_dcv_hashmap[i1]<0||b_dcv_hashmap[i2]<0||b_dcv_hashmap[i3]<0){ continue; }

		uint face_index =atomicAdd(b_dcv_index_counter.vertexCount, 6);
		b_dcv_index[face_index/3] = uvec3(i0, i1, i2);
		b_dcv_index[face_index/3+1] = uvec3(i1, i3, i2);
	}

}