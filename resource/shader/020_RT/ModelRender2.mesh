
#version 450

#define NVMESHLET_USE_PACKBASIC 1
#extension GL_GOOGLE_include_directive : enable

#include "config.h"
#include "common.h"

#define SETPOINT_CAMERA 0
#include "btrlib/Camera.glsl"

#define USE_Render_Scene 1
#include "pbr.glsl"

#define USE_Model_Resource 2
#define USE_Model_Render 3
#include "Model.glsl"

// MESH CONFIG
#define GROUP_SIZE    WARP_SIZE

layout(local_size_x=GROUP_SIZE) in;
layout(max_vertices=NVMESHLET_VERTEX_COUNT, max_primitives=NVMESHLET_PRIMITIVE_COUNT) out;
layout(triangles) out;

#include "nvmeshlet_utils.glsl"

/////////////////////////////////////////////////
// MESH INPUT
taskNV in Task {
  uint    baseID;
  uint8_t subIDs[GROUP_SIZE];
} IN;

////////////////////////////////////////////////////////////
// OUTPUT

layout(location=1) out Interpolants 
{
	vec3  wPos;
	float _d1;
	vec3  wNormal;
	float _d2;
	vec2 Texcoord_0;
	flat uint64_t MaterialAddress;
	flat uint meshletID;
} OUT[];

//////////////////////////////////////////////////
// EXECUTION

Mesh u_mesh;
ObjectData u_object;

vec4 procVertex(uint meshletID, const uint vert, uint vidx)
{
	Vertex vertex  = Vertex(u_mesh.VertexAddress);

	vec3 oPos = vertex.b_v[vidx];
	vec3 wPos = (u_object.worldMatrix  * vec4(oPos,1)).xyz;
	vec4 hPos = u_camera[0].u_projection * u_camera[0].u_view * vec4(wPos,1);

	gl_MeshVerticesNV[vert].gl_Position = hPos;

	OUT[vert].wPos = wPos;
	OUT[vert]._d1 = 0;
	OUT[vert]._d2 = 0;
	OUT[vert].meshletID = meshletID;

#if USE_CLIPPING
	gl_MeshVerticesNV[vert].gl_ClipDistance[0] = dot(scene.wClipPlanes[0], vec4(wPos,1));
	gl_MeshVerticesNV[vert].gl_ClipDistance[1] = dot(scene.wClipPlanes[1], vec4(wPos,1));
	gl_MeshVerticesNV[vert].gl_ClipDistance[2] = dot(scene.wClipPlanes[2], vec4(wPos,1));
#endif

	return hPos;
}

// To benefit from batched loading, and reduce latency 
// let's make use of a dedicated load phase.
// (explained at the end of the file in the USE_BATCHED_LATE_FETCH section)

struct TempAttributes {
  vec3 normal;
  vec2 tex;
};

void fetchAttributes(inout TempAttributes temp, uint vert, uint vidx)
{
	Vertex normal  = Vertex(u_mesh.IndexAddress);
	temp.normal = normal.b_v[vidx];

	Texcoord tex0 = Texcoord(u_mesh.TexcoordAddress);
	temp.tex = tex0.b_t[vidx];
}

void storeAttributes(inout TempAttributes temp, const uint vert, uint vidx)
{
  vec3 oNormal = temp.normal;
  vec3 wNormal = mat3(u_object.worldMatrixIT) * oNormal;
  OUT[vert].wNormal = wNormal;
  OUT[vert].Texcoord_0 = temp.tex;
  OUT[vert].MaterialAddress = u_mesh.MaterialAddress;
}

void procAttributes(uint meshletID, const uint vert, uint vidx)
{
  TempAttributes  temp;
  fetchAttributes(temp, vert, vidx);
  storeAttributes(temp, vert, vidx);
}


//////////////////////////////////////////////////
// MESH EXECUTION
#define NVMSH_BARRIER() \
  memoryBarrierShared(); \
  barrier();
  
#define NVMSH_INDEX_BITS      8
#define NVMSH_PACKED4X8_GET(packed, idx)   (((packed) >> (NVMSH_INDEX_BITS * (idx))) & 255)


// only for tight packing case, 8 indices are loaded per thread
#define NVMSH_PRIMITIVE_INDICES_RUNS  ((NVMESHLET_PRIMITIVE_COUNT * 3 + GROUP_SIZE * 8 - 1) / (GROUP_SIZE * 8))

// processing loops
#define NVMSH_VERTEX_RUNS     ((NVMESHLET_VERTEX_COUNT + GROUP_SIZE - 1) / GROUP_SIZE)
#define NVMSH_PRIMITIVE_RUNS  ((NVMESHLET_PRIMITIVE_COUNT + GROUP_SIZE - 1) / GROUP_SIZE)
  
#if 1
  #define nvmsh_writePackedPrimitiveIndices4x8NV writePackedPrimitiveIndices4x8NV
#else
  #define nvmsh_writePackedPrimitiveIndices4x8NV(idx, topology) {\
        gl_PrimitiveIndicesNV[ (idx) + 0 ] = (NVMSH_PACKED4X8_GET((topology), 0)); \
        gl_PrimitiveIndicesNV[ (idx) + 1 ] = (NVMSH_PACKED4X8_GET((topology), 1)); \
        gl_PrimitiveIndicesNV[ (idx) + 2 ] = (NVMSH_PACKED4X8_GET((topology), 2)); \
        gl_PrimitiveIndicesNV[ (idx) + 3 ] = (NVMSH_PACKED4X8_GET((topology), 3));} 
#endif
  
///////////////////////////////////////////////////////////////////////////////

void main()
{
	IndirectCmd RenderCmd = b_cmd[0];
	u_object = b_object[0];
	u_mesh = MeshBuffer(RenderCmd.PrimitiveAddress).b_mesh[gl_DrawIDARB];

	// gl_WorkGroupID.x runs from [0 .. parentTask.gl_TaskCountNV - 1]
	uint meshletID = IN.baseID + IN.subIDs[gl_WorkGroupID.x];
	uint laneID = gl_LocalInvocationID.x;

	// decode meshletDesc
	BindlessBufferU32x4 MeshletDescs = BindlessBufferU32x4(u_mesh.MeshletDesc);
	uvec4 desc = MeshletDescs.b_uvec4[meshletID];
	uint vertMax;
	uint primMax;
	uint vidxStart;
	uint vidxBits;
	uint vidxDiv;
	uint primStart;
	uint primDiv;
	decodeMeshlet(desc, vertMax, primMax, primStart, primDiv, vidxStart, vidxBits, vidxDiv);

	uint primCount = primMax + 1;
	uint vertCount = vertMax + 1;

	BindlessBufferU32 MeshletPack = BindlessBufferU32(u_mesh.MeshletPack);
	// LOAD PHASE
	// VERTEX PROCESSING  
	for (uint i = 0; i < uint(NVMSH_VERTEX_RUNS); i++) 
	{
		uint vert = laneID + i * GROUP_SIZE;
		uint vertLoad = min(vert, vertMax);
		{
			uint idx   = (vertLoad) / vidxDiv;
			uint shift = (vertLoad) & (vidxDiv-1);
			
			uint vidx = MeshletPack.b_uint[idx + vidxStart];
			vidx <<= vidxBits * (1-shift); 
			vidx >>= vidxBits;

			vec4 hPos = procVertex(meshletID, vert, vidx);
			
			procAttributes(meshletID, vert, vidx);
		}
	}

	// PRIMITIVE TOPOLOGY  
	{
		BindlessBufferU32x2 MeshletPack2 = BindlessBufferU32x2(u_mesh.MeshletPack);
		uint readBegin = primStart / 2;
		uint readIndex = primCount * 3 - 1;
		uint readMax   = readIndex / 8;

		for (uint i = 0; i < uint(NVMSH_PRIMITIVE_INDICES_RUNS); i++)
		{
			uint read = laneID + i * GROUP_SIZE;
			uint readUsed = min(read, readMax);
			uvec2 topology = MeshletPack2.b_uvec2[readBegin + readUsed];
			nvmsh_writePackedPrimitiveIndices4x8NV(readUsed * 8 + 0, topology.x);
			nvmsh_writePackedPrimitiveIndices4x8NV(readUsed * 8 + 4, topology.y);
		}
	}



	if (laneID == 0) 
	{
		gl_PrimitiveCountNV = primCount;
		/* #if USE_STATS
		atomicAdd(stats.meshletsOutput, 1);
		atomicAdd(stats.trisOutput, primCount);
		atomicAdd(stats.attrInput,  vertCount);
		atomicAdd(stats.attrOutput, vertCount);
		#endif
		*/  
	}
}