#version 450

#extension GL_GOOGLE_include_directive : enable
#define SETPOINT_CAMERA 0
#include "btrlib/Camera.glsl"

#define USE_Render_Scene 1
#include "pbr.glsl"

#define USE_Model_Resource 2
#define USE_Model_Render 3
#include "Model.glsl"

/////////////////////////////////////////////////////////////////////////

#include "common.h"
#include "nvmeshlet_utils.glsl"

/////////////////////////////////////////////////////////////////////////

#define WARP_SIZE  32
#define GROUP_SIZE WARP_SIZE

layout(local_size_x=GROUP_SIZE) in;

//////////////////////////////////////////////////////////////////////////
// OUTPUT

taskNV out Task
{
  uint      baseID;
  uint8_t   subIDs[GROUP_SIZE];
} OUT;

/////////////////////////////////////////////////
// EXECUTION

void main()
{
	IndirectCmd RenderCmd = b_cmd[gl_DrawIDARB];
	ObjectData instance = b_object[gl_DrawIDARB];
	Mesh mesh = MeshBuffer(RenderCmd.PrimitiveAddress).b_mesh[0];

	uint baseID = gl_WorkGroupID.x * GROUP_SIZE;
	uint laneID = gl_LocalInvocationID.x;

	BindlessBufferU32x4 b_meshlet_desc = BindlessBufferU32x4(mesh.MeshletDesc);
	uvec4 desc = b_meshlet_desc.b_uvec4[baseID + laneID];

//	bool render = !(all(equal(desc, uvec4(0))) || earlyCull(desc, mesh, instance));
	bool render = !all(equal(desc, uvec4(0)));

	uvec4 vote  = subgroupBallot(render);
	uint  tasks = subgroupBallotBitCount(vote);

	if (laneID == 0) 
	{
		gl_TaskCountNV = tasks;
		OUT.baseID = baseID;
	}
	{
		uint idxOffset = subgroupBallotExclusiveBitCount(vote);
		if (render)
		{
			OUT.subIDs[idxOffset] = uint8_t(laneID);
		}
	}
}