#version 450

//#pragma optionNV (unroll all)
//#pragma optionNV (inline all)


//#extension GL_ARB_shading_language_include : require
#extension GL_GOOGLE_cpp_style_line_directive : require

#include </Light.glsl>

layout (local_size_x = 32, local_size_y = 32) in;

layout(std140, binding=0) uniform LightInfoUniform {
	LightInfo u_light_info;
};

layout(std430, binding=8) readonly restrict buffer TiledFrustomBuffer {
	Frustom2 b_tiled_frustom[];
};
layout(std430, binding=9) readonly restrict buffer LightBuffer {
	LightParam b_light[];
};
layout(std430, binding=10) restrict buffer LLHeadBuffer {
	uint b_LLhead[];
};
layout(std430, binding=11) writeonly restrict buffer LLBuffer {
	LightLL b_light_LL[];
};
layout(std430, binding=12) coherent restrict buffer LightCounter {
	uint b_light_count;
};


void main()
{
	uvec3 index = uvec3(gl_GlobalInvocationID.xy, 0);
	if(any(greaterThan(index.xy, u_light_info.m_tile_num))) { return; }
	uint index1D = index.x + index.y * u_light_info.m_tile_num.x;

	Frustom2 f = b_tiled_frustom[index.x + index.y * u_light_info.m_tile_num.x];
	b_LLhead[index1D] = uint(-1);
	for(uint i = 0; i < u_light_info.m_active_light_num; i++)
	{
		if(isCulling2(f, b_light[i].m_position))
		{
			continue;
		}
		uint light_index = atomicAdd(b_light_count, 1);
		b_light_LL[light_index].next = b_LLhead[index1D];
		b_light_LL[light_index].light_index = i;
		b_LLhead[index1D] = light_index;
	}
}