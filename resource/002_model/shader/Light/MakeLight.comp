
#version 450

#pragma optionNV (unroll all)
#pragma optionNV (inline all)

#extension GL_GOOGLE_cpp_style_line_directive : require

#include </Light.glsl>

layout (local_size_x = 32, local_size_y = 32) in;

layout(std140, binding=0) uniform LightInfoUniform {
	LightInfo u_light_info;
};
//layout(std140, binding=1) uniform FrustomUniform {
//	Frustom u_frustom;
//};
layout(std140, binding=1) uniform FrustomUniform {
	FrustomPoint u_frustom;
};
layout(std430, binding=8) writeonly restrict buffer TiledFrustomBuffer {
	Frustom2 u_tiled_frustom[];
};

void main()
{
	uvec3 index = uvec3(gl_GlobalInvocationID.xy, 0);
	if(any(greaterThanEqual(index.xy, u_light_info.m_tile_num))) { return; }

	vec3 per_size = vec3(vec2(1.) / u_light_info.m_tile_num, 0.);
//	plane_[PLANE_TOP] = Plane(rtn_, ltn_, ltf_);
//	plane_[PLANE_BOTTOM] = Plane(lbn_, rbn_, rbf_);
//	plane_[PLANE_LEFT] = Plane(ltn_, lbn_, lbf_);
//	plane_[PLANE_RIGHT] = Plane(rbn_, rtn_, rbf_);
	vec3 ltn = u_frustom.m_ltn + index*per_size;
	vec3 lbn = u_frustom.m_ltn + (index+uvec3(0, 1, 0))*per_size;
	vec3 rtn = u_frustom.m_ltn + (index+uvec3(1, 0, 0))*per_size;
	vec3 rbn = u_frustom.m_ltn + (index+uvec3(1, 1, 0))*per_size;
	vec3 ltf = u_frustom.m_ltf + index*per_size;
	vec3 lbf = u_frustom.m_ltf + (index+uvec3(0, 1, 0))*per_size;
	vec3 rtf = u_frustom.m_ltf + (index+uvec3(1, 0, 0))*per_size;
	vec3 rbf = u_frustom.m_ltf + (index+uvec3(1, 1, 0))*per_size;
	Frustom2 f;
	f.p[0] = MakePlane(rtn, ltn, ltf);
	f.p[1] = MakePlane(lbn, rbn, rbf);
	f.p[2] = MakePlane(ltn, lbn, lbf);
	f.p[3] = MakePlane(rbn, rtn, rbf);
	u_tiled_frustom[index.x + index.y * u_light_info.m_tile_num.x] = f;
}