#version 450

#pragma optionNV (unroll none)

//#extension GL_ARB_shading_language_include : require
#extension GL_GOOGLE_cpp_style_line_directive : require
#include </Math.glsl>
#include </MultiModel.glsl>

layout (local_size_x = 1024, local_size_y = 1) in;

layout(std140, binding=0) uniform ModelInfoUniform {
	ModelInfo modelInfo;
};


layout(std430, binding=8) readonly restrict buffer AnimationInfoBuffer {
	AnimationInfo animInfo[];
};
layout(std430, binding=9) readonly restrict buffer MotionInfoBuffer {
	MotionInfo motionInfo[];
};

layout(std430, binding=10) readonly restrict buffer MotionTimeBuffer {
	float motionTimeData[];
};
layout(std430, binding=11) readonly restrict buffer MotionDataBuffer {
	MotionSTRData motionData[];
};

layout(std430, binding=12) readonly restrict buffer PlayingAnimationBuffer {
	PlayingAnimation playingMotion[];
};

layout(std430, binding=13) readonly restrict buffer NodeBuffer {
	Node nodes[];
};

layout(std430, binding=14) restrict buffer NodeLocalTransformBuffer {
	mat4 nodeLocalTransforms[];
};

layout(std430, binding=15) restrict buffer MotionWorkBuffer {
	MotionWork motionWorks[];
};

void main() 
{

	uint index = gl_GlobalInvocationID.x;
	if(index >= modelInfo.nodeNum * modelInfo.instanceAliveNum){ return; }

	uint modelIndex = index / modelInfo.nodeNum;
	PlayingAnimation pm = playingMotion[modelIndex];
	AnimationInfo aInfo = animInfo[pm.playingAnimationNo];
	int motionInfoIndex = aInfo.offsetInfo;

	uint nodeIndex = index%modelInfo.nodeNum;
	Node node = nodes[nodeIndex];
	MotionWork mw = motionWorks[index];
	bool isFind = false;
	MotionInfo mi;
	int i = 0;
	for(; i<aInfo.numInfo; i++)
	{
		mi = motionInfo[motionInfoIndex+i];
		if( mi.nodeNo == node.nodeNo) {
			isFind = true;
			break;
		}
	}
	if(!isFind) { return ;}

	// モーションがloopしていたらindexを0にする
	mw.motionDataIndex = ((pm.isLoop != 0 && pm.time >= aInfo.maxTime) ? 0 : mw.motionDataIndex);
	float time = pm.isLoop != 0? mod(pm.time, aInfo.maxTime) : pm.time;
	/*MotionTimeData*/float mt = motionTimeData[mi.offsetData+mi.numData-1];
	i = mw.motionDataIndex;
	for(; i < mi.numData; i++){
		if(motionTimeData[mi.offsetData+i] >= time){
			mt = motionTimeData[mi.offsetData+i];
			break;
		}
	}

	motionWorks[index].motionDataIndex = i;
	MotionSTRData md = motionData[mi.offsetData+i]; 
	mat4 local = mat4(1.);
	local = scaling(local, vec3(md.posAndScale.w)) * translate(mat4(1.), md.posAndScale.xyz) * mat4(quatToMat3(md.rot));
	nodeLocalTransforms[index] = local;

}

