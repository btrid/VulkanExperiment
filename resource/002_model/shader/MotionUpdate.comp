#version 450

#pragma optionNV (unroll none)

//#extension GL_ARB_shading_language_include : require
#extension GL_GOOGLE_cpp_style_line_directive : require
#include </Math.glsl>
#include </MultiModel.glsl>

layout (local_size_x = 512, local_size_y = 1) in;

layout(std140, binding=0) uniform ModelInfoUniform {
	ModelInfo modelInfo;
};


layout(std430, binding=0) readonly restrict buffer AnimationInfoBuffer {
	AnimationInfo animInfo[];
};
layout(std430, binding=1) readonly restrict buffer MotionInfoBuffer {
	MotionInfo motionInfo[];
};

layout(std430, binding=2) readonly restrict buffer MotionTimeBuffer {
	float motionTimeData[];
};
layout(std430, binding=3) readonly restrict buffer MotionDataBuffer {
	MotionSTRData motionData[];
};

layout(std430, binding=4) readonly restrict buffer PlayingAnimationBuffer {
	PlayingAnimation playingMotion[];
};

layout(std430, binding=5) readonly restrict buffer NodeBuffer {
	Node nodes[];
};

layout(std430, binding=6) restrict buffer NodeLocalTransformBuffer {
	mat3x4 nodeLocalTransforms[];
};

layout(std430, binding=7) restrict buffer MotionWorkBuffer {
	MotionWork motionWorks[];
};

void main() 
{

	uint index = gl_GlobalInvocationID.x;
	if(index >= modelInfo.nodeNum * modelInfo.instanceMaxNum){ return; }

	AnimationInfo aInfo = animInfo[playingMotion[index].playingAnimationNo];
	int motionInfoIndex = aInfo.offsetInfo;

	uint nodeIndex = index%modelInfo.nodeNum;
	Node node = nodes[nodeIndex];
	MotionWork mw = motionWorks[index];
	bool isFind = false;
	MotionInfo mi;
	int i = 0;
	for(; i<aInfo.numInfo; i++)
	{
		mi = motionInfo[motionInfoIndex+i];
		if( mi.nodeNo == node.nodeNo) {
			isFind = true;
			break;
		}
	}
	if(!isFind) { return ;}

	PlayingAnimation pm = playingMotion[index / modelInfo.nodeNum];

	// モーションがloopしていたらindexを0にする
	mw.motionDataIndex = ((pm.isLoop != 0 && pm.time >= aInfo.maxTime) ? 0 : mw.motionDataIndex);
	float time = pm.isLoop != 0? mod(pm.time, aInfo.maxTime) : pm.time;
	/*MotionTimeData*/float mt = motionTimeData[mi.offsetData+mi.numData-1];
	i = mw.motionDataIndex;
	for(; i < mi.numData; i++){
		if(motionTimeData[mi.offsetData+i] >= time){
			mt = motionTimeData[mi.offsetData+i];
			break;
		}
	}

	motionWorks[index].motionDataIndex = i;
	MotionSTRData md = motionData[mi.offsetData+i]; 
	mat4 local = mat4(1.);
	local = scaling(local, vec3(md.posAndScale.w)) * translate(mat4(1.), md.posAndScale.xyz) * mat4(quatToMat3(md.rot));
	nodeLocalTransforms[index] = transpose(mat4x3(local));

}

