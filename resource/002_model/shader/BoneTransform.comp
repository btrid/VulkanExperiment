#version 450

#pragma optionNV (unroll none)

//#extension GL_ARB_shading_language_include : require
#extension GL_GOOGLE_cpp_style_line_directive : require
#include </MultiModel.glsl>

layout (local_size_x = 256, local_size_y = 1) in;


layout(std140, binding=0) uniform ModelInfoUniform {
	ModelInfo modelInfo;
};

layout(std430, binding=0) readonly restrict buffer NodeGlobalTransformBuffer {
//	NodeGlobalTransform nodeGlobalTransforms[];
//	mat3x4 nodeGlobalTransforms[];
	mat4 nodeGlobalTransforms[];
};

layout(std430, binding=1) readonly restrict buffer BoneInfoBuffer {
	BoneInfo boneInfo[];
};

layout(std430, binding=2) readonly restrict buffer BoneMapBuffer {
	uint boneMap[];
};

layout(std430, binding=3) restrict buffer BoneTransformBuffer {
	mat4 bones[];
};

void main()
{
	if(gl_GlobalInvocationID.x >= modelInfo.boneNum * modelInfo.instanceNum){ return; }
	mat4 inv = modelInfo.invGlobalMatrix;
	uint index = gl_GlobalInvocationID.x;

	uint boneInfoIndex = index % modelInfo.boneNum;
	uint nodeIndexOffset = boneMap[index / modelInfo.boneNum] * modelInfo.nodeNum;
	bones[index] 
		= inv
//		* nodeGlobalTransforms[nodeIndexOffset + boneInfo[boneInfoIndex].nodeIndex]
//		* mat4(transpose(nodeGlobalTransforms[nodeIndexOffset + boneInfo[boneInfoIndex].nodeIndex]))
		* nodeGlobalTransforms[nodeIndexOffset + boneInfo[boneInfoIndex].nodeIndex]
//		* transpose(mat4(nodeGlobalTransforms[nodeIndexOffset + boneInfo[boneInfoIndex].nodeIndex].global))
		* boneInfo[boneInfoIndex].boneOffset;

//	bones[index] = mat4(1.);

/*
	uint nodeIndexOffset = srcIndex * modelInfo.nodeNum;
	uint boneIndexOffset = index * modelInfo.boneNum;
	for(int i=0; i <modelInfo.boneNum; i++) 
	{
		bones[boneIndexOffset + i] 
			= modelInfo.invGlobalMatrix 
			* nodeTransforms[nodeIndexOffset + boneInfo[i].nodeIndex].global 
			* boneInfo[i].boneOffset;
	}
*/

}