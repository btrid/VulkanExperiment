#version 430

#pragma optionNV (unroll all)
//#pragma optionNV (unroll all)
#pragma optionNV (inline all)
//#pragma optionNV(fastmath on)
//#pragma optionNV(fastprecision on)
//#pragma optionNV(ifcvt all)
//#pragma optionNV(strict on)

//#extension GL_ARB_shading_language_include : require
#extension GL_GOOGLE_cpp_style_line_directive : require
#include </Math.glsl>
#include </MultiModel.glsl>

layout (local_size_x = 1024, local_size_y = 1) in;


layout(std140, binding=0) uniform ModelInfoBuffer {
	ModelInfo modelInfo;
};

layout(std430, binding=8) readonly restrict buffer WorldTransform {
	mat4 worlds[];
};

layout(std430, binding=9) readonly restrict buffer NodeBuffer {
	Node nodes[];
};

layout(std430, binding=10) readonly restrict buffer NodeLocalTransformBuffer {
	mat4 nodeLocalTransforms[];
};
layout(std430, binding=11) coherent restrict buffer NodeGlobalTransformBuffer {
	mat4 nodeGlobalTransforms[];
};

//shared mat4 global_mat[128];
void main() 
{
	if( int(gl_GlobalInvocationID.x) >= modelInfo.instanceAliveNum * modelInfo.nodeNum) { return ;} 
	int root_index = int(gl_GlobalInvocationID.x) / modelInfo.nodeNum * modelInfo.nodeNum;
	int model_index = int(gl_GlobalInvocationID.x) / modelInfo.nodeNum;
	int node_index = int(gl_GlobalInvocationID.x) % modelInfo.nodeNum;

	if(node_index == 0)
	{
		nodeGlobalTransforms[root_index] = worlds[model_index] * nodeLocalTransforms[root_index];
	}
	for(int i=1; i < modelInfo.node_depth_max; i++)
	{
		if(nodes[node_index].depth == i)
		{
			mat4 g = nodeGlobalTransforms[root_index + nodes[node_index].parent] * nodeLocalTransforms[root_index + node_index];
			nodeGlobalTransforms[root_index+node_index] = g;
		}
	}
}
